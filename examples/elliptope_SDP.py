# Autogenerated with SMOP 
from smop.core import *
# elliptope_SDP.m

    
@function
def elliptope_SDP(A=None,p=None,Y0=None,*args,**kwargs):
    varargin = elliptope_SDP.varargin
    nargin = elliptope_SDP.nargin

    # Solver for semidefinite programs (SDP's) with unit diagonal constraints.
# 
# function [Y, problem, S] = elliptope_SDP(A)
# function [Y, problem, S] = elliptope_SDP(A, p)
# function [Y, problem, S] = elliptope_SDP(A, p, Y0)
    
    # A is a real, symmetric matrix of size n.
    
    # This function uses a local optimization method in Manopt to solve the SDP
    
    #   min_X  trace(A*X)  s.t.  diag(X) = 1 and X is positive semidefinite.
    
    # In practice, the symmetric matrix X of size n is parameterized
# as X = Y*Y', where Y has size n x p. By default, p is taken large enough
# (about sqrt(2n)) to ensure that there exists an optimal X whose rank is
# smaller than p. This ensures that the SDP is equivalent to the new
# problem in Y:
    
    #   min_Y  trace(Y'*A*Y)  s.t.  diag(Y*Y') = 1.
    
    # The constraints on Y require each row of Y to have unit norm, which is
# why Manopt is appropriate software to solve this problem. An optional
# initial guess can be specified via the input Y0.
    
    # See the paper below for theory, specifically, for a proof that, for
# almost all A, second-order critical points of the problem in Y are
# globally optimal. In other words: there are no local traps in Y, despite
# non-convexity.
    
    # Outputs:
    
    #       Y: is the best point found (an nxp matrix with unit norm rows.)
#          To find X, form Y*Y' (or, more efficiently, study X through Y.)
# 
#       problem: is the Manopt problem structure used to produce Y.
# 
#       S: is a dual optimality certificate (a symmetric matrix of size n,
#          sparse if A is sparse). The optimality gap (in the cost
#          function) is at most n*min(eig(S)), for both Y and X = Y*Y'.
#          Hence, if min(eig(S)) is close to zero, Y is close to globally
#          optimal. This can be computed via eigs(S, 1, 'SR').
# 
# Paper: https://arxiv.org/abs/1606.04970
    
    # @inproceedings{boumal2016bmapproach,
#   author  = {Boumal, N. and Voroninski, V. and Bandeira, A.S.},
#   title   = {The non-convex {B}urer-{M}onteiro approach works on smooth semidefinite programs},
#   booktitle={Neural Information Processing Systems (NIPS 2016)},
#   year    = {2016}
# }
# 
# See also: maxcut elliptope_SDP_complex
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, June 28, 2016
# Contributors:
# Change log:
    
    # If no inputs are provided, since this is an example file, generate
    # a random Erdos-Renyi graph. This is for illustration purposes only.
    if logical_not(exist('A','var')) or isempty(A):
        n=100
# elliptope_SDP.m:64
        A=triu(rand(n) <= 0.1,1)
# elliptope_SDP.m:65
        A=(A + A.T) / (dot(2,n))
# elliptope_SDP.m:66
    
    n=size(A,1)
# elliptope_SDP.m:69
    assert_(n >= 2,'A must be at least 2x2.')
    assert_(isreal(A),'A must be real.')
    assert_(size(A,2) == n,'A must be square.')
    
    A=(A + A.T) / 2
# elliptope_SDP.m:75
    
    if logical_not(exist('p','var')) or isempty(p):
        p=ceil(sqrt(dot(8,n) + 1) / 2)
# elliptope_SDP.m:79
    
    
    assert_(p >= 2 and p == round(p),'p must be an integer >= 2.')
    
    manifold=obliquefactory(p,n,true)
# elliptope_SDP.m:85
    problem.M = copy(manifold)
# elliptope_SDP.m:87
    
    # the cost function and its derivatives. This is good code to write
    # when prototyping. Below, a more advanced use of Manopt is shown,
    # where the redundant computation A*Y is avoided between the gradient
    # and the cost evaluation.
    # # problem.cost  = @(Y) .5*sum(sum((A*Y).*Y));
    # # problem.egrad = @(Y) A*Y;
    # # problem.ehess = @(Y, Ydot) A*Ydot;
    
    # Products with A dominate the cost, hence we store the result.
    # This allows to share the results among cost, grad and hess.
    # This is completely optional.
    
@function
def prepare(Y=None,store=None,*args,**kwargs):
    varargin = prepare.varargin
    nargin = prepare.nargin

    if logical_not(isfield(store,'AY')):
        AY=dot(A,Y)
# elliptope_SDP.m:104
        store.AY = copy(AY)
# elliptope_SDP.m:105
        store.diagAYYt = copy(sum(multiply(AY,Y),2))
# elliptope_SDP.m:106
    
    return store
    
if __name__ == '__main__':
    pass
    
    
    # Define the cost function to be /minimized/.
    problem.cost = copy(cost)
# elliptope_SDP.m:111
    
@function
def cost(Y=None,store=None,*args,**kwargs):
    varargin = cost.varargin
    nargin = cost.nargin

    store=prepare(Y,store)
# elliptope_SDP.m:113
    f=dot(0.5,sum(store.diagAYYt))
# elliptope_SDP.m:114
    return f,store
    
if __name__ == '__main__':
    pass
    
    # Define the Riemannian gradient.
    problem.grad = copy(grad)
# elliptope_SDP.m:118
    
@function
def grad(Y=None,store=None,*args,**kwargs):
    varargin = grad.varargin
    nargin = grad.nargin

    store=prepare(Y,store)
# elliptope_SDP.m:120
    G=store.AY - bsxfun(times,Y,store.diagAYYt)
# elliptope_SDP.m:121
    return G,store
    
if __name__ == '__main__':
    pass
    
    # If you want to, you can specify the Riemannian Hessian as well.
    problem.hess = copy(hess)
# elliptope_SDP.m:125
    
@function
def hess(Y=None,Ydot=None,store=None,*args,**kwargs):
    varargin = hess.varargin
    nargin = hess.nargin

    store=prepare(Y,store)
# elliptope_SDP.m:127
    SYdot=dot(A,Ydot) - bsxfun(times,Ydot,store.diagAYYt)
# elliptope_SDP.m:128
    H=manifold.proj(Y,SYdot)
# elliptope_SDP.m:129
    return H,store
    
if __name__ == '__main__':
    pass
    
    # If no initial guess is available, tell Manopt to use a random one.
    if logical_not(exist('Y0','var')) or isempty(Y0):
        Y0=matlabarray([])
# elliptope_SDP.m:135
    
    # Call your favorite solver.
    opts=struct()
# elliptope_SDP.m:139
    opts.verbosity = copy(0)
# elliptope_SDP.m:140
    
    opts.maxinner = copy(500)
# elliptope_SDP.m:141
    
    opts.tolgradnorm = copy(1e-06)
# elliptope_SDP.m:142
    
    Y=trustregions(problem,Y0,opts)
# elliptope_SDP.m:143
    
    if nargout >= 3:
        S=A - spdiags(sum(multiply((dot(A,Y)),Y),2),0,n,n)
# elliptope_SDP.m:147
    
    return H,store
    
if __name__ == '__main__':
    pass
    