# Autogenerated with SMOP 
from smop.core import *
# nonlinear_eigenspace.m

    
@function
def nonlinear_eigenspace(L=None,k=None,alpha=None,*args,**kwargs):
    varargin = nonlinear_eigenspace.varargin
    nargin = nonlinear_eigenspace.nargin

    # Example of nonlinear eigenvalue problem: total energy minimization.
    
    # function Xsol = nonlinear_eigenspace(L, k, alpha)
    
    # L is a discrete Laplacian operator,
# alpha is a given constant, and
# k corresponds to the dimension of the least eigenspace sought.
    
    # This example demonstrates how to use the Grassmann geometry factory 
# to solve the nonlinear eigenvalue problem as the optimization problem:
    
    # minimize 0.5*trace(X'*L*X) + (alpha/4)*(rho(X)*L\(rho(X))) 
# over X such that X'*X = Identity,
    
    # where L is of size n-by-n,
# X is an n-by-k matrix, and
# rho(X) is the diagonal part of X*X'.
    
    # This example is motivated in the paper
# "A Riemannian Newton Algorithm for Nonlinear Eigenvalue Problems",
# Zhi Zhao, Zheng-Jian Bai, and Xiao-Qing Jin,
# SIAM Journal on Matrix Analysis and Applications, 36(2), 752-774, 2015.
    
    # This file is part of Manopt and is copyrighted. See the license file.
    
    # Main author: Bamdev Mishra, June 19, 2015.
# Contributors:
    
    # Change log:
    
    # If no inputs are provided, generate a  discrete Laplacian operator.
    # This is for illustration purposes only.
    # The default example corresponds to Case (c) of Example 6.2 of the
    # above referenced paper.
    
    if logical_not(exist('L','var')) or isempty(L):
        n=100
# nonlinear_eigenspace.m:41
        L=gallery('tridiag',n,- 1,2,- 1)
# nonlinear_eigenspace.m:42
    
    
    n=size(L,1)
# nonlinear_eigenspace.m:45
    assert_(size(L,2) == n,'L must be square.')
    if logical_not(exist('k','var')) or isempty(k) or k > n:
        k=10
# nonlinear_eigenspace.m:49
    
    
    if logical_not(exist('alpha','var')) or isempty(alpha):
        alpha=1
# nonlinear_eigenspace.m:53
    
    
    
    # Grassmann manifold description
    Gr=grassmannfactory(n,k)
# nonlinear_eigenspace.m:58
    problem.M = copy(Gr)
# nonlinear_eigenspace.m:59
    
    problem.cost = copy(cost)
# nonlinear_eigenspace.m:62
    
@function
def cost(X=None,*args,**kwargs):
    varargin = cost.varargin
    nargin = cost.nargin

    rhoX=sum(X ** 2,2)
# nonlinear_eigenspace.m:64
    
    val=dot(0.5,trace(dot(X.T,(dot(L,X))))) + dot((alpha / 4),(dot(rhoX.T,(numpy.linalg.solve(L,rhoX)))))
# nonlinear_eigenspace.m:65
    return val
    
if __name__ == '__main__':
    pass
    
    
    # Euclidean gradient evaluation
    # Note: Manopt automatically converts it to the Riemannian counterpart.
    problem.egrad = copy(egrad)
# nonlinear_eigenspace.m:70
    
@function
def egrad(X=None,*args,**kwargs):
    varargin = egrad.varargin
    nargin = egrad.nargin

    rhoX=sum(X ** 2,2)
# nonlinear_eigenspace.m:72
    
    g=dot(L,X) + dot(dot(alpha,diag(numpy.linalg.solve(L,rhoX))),X)
# nonlinear_eigenspace.m:73
    return g
    
if __name__ == '__main__':
    pass
    
    
    # Euclidean Hessian evaluation
    # Note: Manopt automatically converts it to the Riemannian counterpart.
    problem.ehess = copy(ehess)
# nonlinear_eigenspace.m:78
    
@function
def ehess(X=None,U=None,*args,**kwargs):
    varargin = ehess.varargin
    nargin = ehess.nargin

    rhoX=sum(X ** 2,2)
# nonlinear_eigenspace.m:80
    
    rhoXdot=dot(2,sum(multiply(X,U),2))
# nonlinear_eigenspace.m:81
    h=dot(L,U) + dot(dot(alpha,diag(numpy.linalg.solve(L,rhoXdot))),X) + dot(dot(alpha,diag(numpy.linalg.solve(L,rhoX))),U)
# nonlinear_eigenspace.m:82
    return h
    
if __name__ == '__main__':
    pass
    
    
    
    # Check whether gradient and Hessian computations are correct.
    # checkgradient(problem);
    # pause;
    # checkhessian(problem);
    # pause;
    
    
    # Initialization as suggested in above referenced paper.
    X=randn(n,k)
# nonlinear_eigenspace.m:94
    U,S,V=svd(X,0,nargout=3)
# nonlinear_eigenspace.m:95
    
    X=dot(U,V.T)
# nonlinear_eigenspace.m:96
    U0,S0,V0=eigs(L + dot(alpha,diag(numpy.linalg.solve(L,(sum(X ** 2,2))))),k,'sm',nargout=3)
# nonlinear_eigenspace.m:97
    
    X0=copy(U0)
# nonlinear_eigenspace.m:98
    
    # Note: it calls the trust regions solver as we have all the required
    # ingredients, namely, gradient and Hessian, information.
    Xsol=manoptsolve(problem,X0)
# nonlinear_eigenspace.m:103
    return h
    
if __name__ == '__main__':
    pass
    