# Autogenerated with SMOP 
from smop.core import *
# packing_on_the_sphere.m

    
@function
def packing_on_the_sphere(d=None,n=None,epsilon=None,X0=None,*args,**kwargs):
    varargin = packing_on_the_sphere.varargin
    nargin = packing_on_the_sphere.nargin

    # Return a set of points spread out on the sphere.
    
    # function [X, maxdot] = packing_on_the_sphere(d, n, epsilon, X0)
    
    # Using optimization on the oblique manifold, that is, the product of
# spheres, this function returns a set of n points with unit norm in R^d in
# the form of a matrix X of size nxd, such that the points are spread out
# on the sphere. Ideally, we would minimize the maximum inner product
# between any two points X(i, :) and X(j, :), i~=j, but that is a nonsmooth
# cost function. Instead, we replace the max function by a classical
# log-sum-exp approximation and (attempt to) solve:
    
    # min_{X in OB(d, n)} log( .5*sum_{i~=j} exp( xi'*xj/epsilon ) ),
    
    # with xi = X(:, i) and epsilon is some "diffusion constant". As epsilon
# goes to zero, the cost function is a sharper approximation of the max
# function (under some assumptions), but the cost function becomes stiffer
# and hence harder to optimize.
    
    # The second output, maxdot, is the maximum inner product between any two
# points in the returned X. This number is the one we truly are trying to
# minimize.
    
    # Notice that this cost function is invariant under rotation of X:
# f(X) = f(XQ) for all orthogonal Q in O(d).
# This calls for optimization over the set of symmetric positive
# semidefinite matrices of size n and rank d with unit diagonal, which can
# be thought of as the quotient of the oblique manifold OB(d, n) by O(d):
# See elliptopefactory.
    
    # This is known as the Thomson or, more specifically, the Tammes problem:
# http://en.wikipedia.org/wiki/Tammes_problem
# An interesting page by Neil Sloane collecting best known packings is
# available here http://neilsloane.com/packings/
    
    # This file is part of Manopt and is copyrighted. See the license file.
    
    # Main author: Nicolas Boumal, July 2, 2013
# Contributors:
    
    # Change log:
#   Aug. 14, 2013 (NB) : Code now compatible to experiment with both the
#                        obliquefactory and the elliptopefactory.
    
    #   Jan.  7, 2014 (NB) : Added reference to Neil Sloane's page and the
#                        maxdot output.
    
    #   June 24, 2014 (NB) : Now shifting exponentials to alleviate numerical
#                        trouble when epsilon is too small.
#
    
    if logical_not(exist('d','var')) or isempty(d):
        # Dimension of the embedding space: R^d
        d=3
# packing_on_the_sphere.m:55
    
    if logical_not(exist('n','var')) or isempty(n):
        # Number n of points to place of the sphere in R^d.
        # For example, n=12 yields an icosahedron:
        # https://en.wikipedia.org/wiki/Icosahedron
        # Notice though that platonic solids are not always optimal.
        # Try for example n = 8: you don't get a cube.
        n=24
# packing_on_the_sphere.m:63
    
    if logical_not(exist('epsilon','var')) or isempty(epsilon):
        # This value should be as close to 0 as affordable.
        # If it is too close to zero, optimization first becomes much
        # slower, than simply doesn't work anymore becomes of floating
        # point overflow errors (NaN's and Inf's start to appear).
        # If it is too large, then log-sum-exp is a poor approximation of
        # the max function, and the spread will be less uniform.
        # An okay value seems to be 0.01 or 0.001 for example. Note that a
        # better strategy than using a small epsilon straightaway is to
        # reduce epsilon bit by bit and to warm-start subsequent
        # optimization in that way. Trustregions will be more appropriate
        # for these fine tunings.
        epsilon=0.0015
# packing_on_the_sphere.m:77
    
    
    # Pick your manifold (the elliptope factory quotients out the global
    # rotation invariance of the problem, which is more natural but
    # conceptually a bit more complicated --- for usage with the toolbox it
    # is the same though: just uncomment the appropriate line).
    manifold=obliquefactory(d,n,true)
# packing_on_the_sphere.m:84
    
    
    # Generate a random initial guess if none was given.
    if logical_not(exist('X0','var')) or isempty(X0):
        X0=manifold.rand()
# packing_on_the_sphere.m:89
    
    # Define the cost function with caching system used: the store
    # structure we receive as input is tied to the input point X. Everytime
    # this cost function is called at this point X, we will receive the
    # same store structure back. We may modify the store structure inside
    # the function and return it: the changes will be remembered for next
    # time.
    
@function
def cost(X=None,store=None,*args,**kwargs):
    varargin = cost.varargin
    nargin = cost.nargin

    if logical_not(isfield(store,'ready')):
        XXt=dot(X,X.T)
# packing_on_the_sphere.m:100
        # numerical trouble due to possible overflows.
        s=max(max(triu(XXt,1)))
# packing_on_the_sphere.m:103
        expXXt=exp((XXt - s) / epsilon)
# packing_on_the_sphere.m:104
        expXXt[1:(n + 1):end()]=0
# packing_on_the_sphere.m:106
        u=sum(sum(triu(expXXt,1)))
# packing_on_the_sphere.m:107
        store.XXt = copy(XXt)
# packing_on_the_sphere.m:108
        store.s = copy(s)
# packing_on_the_sphere.m:109
        store.expXXt = copy(expXXt)
# packing_on_the_sphere.m:110
        store.u = copy(u)
# packing_on_the_sphere.m:111
        store.ready = copy(true)
# packing_on_the_sphere.m:112
    
    u=store.u
# packing_on_the_sphere.m:114
    s=store.s
# packing_on_the_sphere.m:115
    f=s + dot(epsilon,log(u))
# packing_on_the_sphere.m:116
    return f,store
    
if __name__ == '__main__':
    pass
    
    # Define the gradient of the cost. When the gradient is called at a
    # point X for which the cost was already called, the store structure we
    # receive remember everything that the cost function stored in it, so
    # we can reuse previously computed elements.
    
@function
def grad(X=None,store=None,*args,**kwargs):
    varargin = grad.varargin
    nargin = grad.nargin

    if logical_not(isfield(store,'ready')):
        __,store=cost(X,store,nargout=2)
# packing_on_the_sphere.m:125
    
    # Compute the Euclidean gradient
    eg=dot(store.expXXt,X) / store.u
# packing_on_the_sphere.m:128
    
    g=manifold.egrad2rgrad(X,eg)
# packing_on_the_sphere.m:130
    return g,store
    
if __name__ == '__main__':
    pass
    
    # Setup the problem structure with its manifold M and cost+grad
    # functions.
    problem.M = copy(manifold)
# packing_on_the_sphere.m:135
    problem.cost = copy(cost)
# packing_on_the_sphere.m:136
    problem.grad = copy(grad)
# packing_on_the_sphere.m:137
    
    # checkgradient(problem);
    # pause;
    
    # Call a solver on our problem with a few options defined. We did not
    # specify the Hessian but it is still okay to call trustregion: Manopt
    # will approximate the Hessian with finite differences of the gradient.
    opts.tolgradnorm = copy(1e-08)
# packing_on_the_sphere.m:146
    opts.maxtime = copy(1200)
# packing_on_the_sphere.m:147
    opts.maxiter = copy(100000.0)
# packing_on_the_sphere.m:148
    
    X=conjugategradient(problem,X0,opts)
# packing_on_the_sphere.m:150
    
    XXt=dot(X,X.T)
# packing_on_the_sphere.m:153
    dots=XXt[find(triu(ones(n),1))]
# packing_on_the_sphere.m:154
    
    maxdot=max(dots)
# packing_on_the_sphere.m:155
    
    # estimate its spectrum at the solution. It should reflect the
    # invariance of the cost function under a global rotatioon of the
    # sphere, which is an invariance under the group O(d) of dimension
    # d(d-1)/2 : this translates into d(d-1)/2 zero eigenvalues in the
    # spectrum of the Hessian.
    # The approximate Hessian is not a linear operator, and is it a
    # fortiori not symmetric. The result of this computation is thus not
    # reliable. It does display the zero eigenvalues as expected though.
    if manifold.dim() < 300:
        evs=real(hessianspectrum(problem,X))
# packing_on_the_sphere.m:167
        figure
        stem(arange(1,length(evs)),sort(evs),'.')
        title(cat('Eigenvalues of the approximate Hessian of the cost ','function at the solution'))
    
    
    
    # Show how the inner products X(:, i)'*X(:, j) are distributed.
    figure
    hist(real(acos(dots)),20)
    title('Histogram of the geodesic distances')
    
    fprintf('Maximum inner product between two points: %g\\n',maxdot)
    
    if d == 2:
        # For the circle, the optimal solution consists in spreading the
        # points with angles uniformly sampled in (0, 2pi). This
        # corresponds to the following value for the max inner product:
        fprintf('Optimal value for the max inner product: %g\\n',cos(dot(2,pi) / n))
        figure
        t=linspace(- pi,pi,201)
# packing_on_the_sphere.m:191
        plot(cos(t),sin(t),'-','LineWidth',3,'Color',cat(152,186,220) / 255)
        daspect(cat(1,1,1))
        box('off')
        axis('off')
        hold('on')
        plot(X[:,1],X[:,2],'r.','MarkerSize',25)
        hold('off')
    
    if d == 3:
        figure
        sphere_x,sphere_y,sphere_z=sphere(50,nargout=3)
# packing_on_the_sphere.m:203
        handle=surf(sphere_x,sphere_y,sphere_z)
# packing_on_the_sphere.m:204
        set(handle,'FaceColor',cat(152,186,220) / 255)
        set(handle,'FaceAlpha',0.5)
        set(handle,'EdgeColor',cat(152,186,220) / 255)
        set(handle,'EdgeAlpha',0.5)
        daspect(cat(1,1,1))
        box('off')
        axis('off')
        hold('on')
        Y=dot(1.02,X.T)
# packing_on_the_sphere.m:214
        plot3(Y[1,:],Y[2,:],Y[3,:],'r.','MarkerSize',25)
        # within some tolerance.
        min_distance=real(acos(maxdot))
# packing_on_the_sphere.m:218
        connected=real(acos(XXt)) <= dot(1.2,min_distance)
# packing_on_the_sphere.m:219
        Ic,Jc=find(triu(connected,1),nargout=2)
# packing_on_the_sphere.m:220
        for k in arange(1,length(Ic)).reshape(-1):
            i=Ic[k]
# packing_on_the_sphere.m:222
            j=Jc[k]
# packing_on_the_sphere.m:222
            plot3(Y[1,cat(i,j)],Y[2,cat(i,j)],Y[3,cat(i,j)],'k-')
        hold('off')
    
    return g,store
    
if __name__ == '__main__':
    pass
    