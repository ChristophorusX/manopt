# Autogenerated with SMOP 
from smop.core import *
# radio_interferometric_calibration.m

    
@function
def radio_interferometric_calibration(N=None,K=None,*args,**kwargs):
    varargin = radio_interferometric_calibration.varargin
    nargin = radio_interferometric_calibration.nargin

    # Returns the gain matrices of N stations with K receivers.
    
    # function xsol = radio_interferometric_calibration(N, K)
    
    # N >= K is always assumed.
    
    # The example considers calibration of an array of N stations.
# We simulate a system with N stations, each having K receivers.
# For radio astronomy, K = 2.
    
    # For a detailed exposition of the problem at hand, refer to the paper:
# "Radio interferometric calibration using a Riemannian manifold",
# Sarod Yatawatta, ICASSP, 2013.
# Available at http://dx.doi.org/10.1109/ICASSP.2013.6638382.
    
    # The source of the signal is unpolarized (given by the matrix C).
# The measured data is the cross correlation of the signals at each receiver.
# So there will be N(N-1)/2 possible cross correlations.
# Noise with given SNR is added to the signal.
    
    # The objective is to estimate the gains of each receiver (K x K) matrix,
# so the total size of the solutions is N x (K x K), which is written
# as an NK x K matrix.
    
    # Note: each station gain matrix (KxK) can have a KxK unitary ambiguity,
# therefore we use the quotient manifold structure. The unitary ambiguity 
# is common to all stations, so the solution obtained by 
# optimization routine always has an unkown unitary matrix that makes the 
# solution different from the true solution.
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Sarod Yatawatta, June 29, 2015.
# Contributors: Bamdev Mishra.
# Change log:
#    
#   June 28, 2016 (BM):
#       Modified the egrad and ehess operations according to 
#       the modified metric in the symfixedrankYYcomplexfactory file, 
#       where a factor of 2 was removed from the metric. Accordingly, 
#       a factor of 2 was added to egrad and ehess operations.
    
    # Generate some random data to test the function
    
    if logical_not(exist('N','var')) or isempty(N):
        N=10
# radio_interferometric_calibration.m:47
    
    if logical_not(exist('K','var')) or isempty(K):
        K=2
# radio_interferometric_calibration.m:50
    
    
    assert_(N >= K,'N must be larger than or equal to K.')
    
    B=dot(N,(N - 1)) / 2
# radio_interferometric_calibration.m:56
    
    C=eye(K)
# radio_interferometric_calibration.m:61
    
    J=dot(0.2,rand(dot(K,N),K)) + dot(1j,rand(dot(K,N),K))
# radio_interferometric_calibration.m:64
    
    V=zeros(dot(K,B),K)
# radio_interferometric_calibration.m:67
    ck=1
# radio_interferometric_calibration.m:69
    for ci in arange(1,N - 1).reshape(-1):
        for cj in arange(ci + 1,N).reshape(-1):
            V[dot(K,(ck - 1)) + 1:dot(K,ck),:]=dot(dot(J[dot(K,(ci - 1)) + 1:dot(K,ci),:],C),J[dot(K,(cj - 1)) + 1:dot(K,cj),:].T)
# radio_interferometric_calibration.m:73
            ck=ck + 1
# radio_interferometric_calibration.m:74
    
    
    # Generate noise
    SNR=10000
# radio_interferometric_calibration.m:79
    
    nn=randn(dot(K,B),K) + dot(1j,randn(dot(K,B),K))
# radio_interferometric_calibration.m:80
    noise_var=norm(V) ** 2 / (dot(norm(nn) ** 2,SNR))
# radio_interferometric_calibration.m:81
    nn=dot(nn,sqrt(noise_var))
# radio_interferometric_calibration.m:82
    
    V=V + nn
# radio_interferometric_calibration.m:85
    
    # First, we use the manifold desctription.
    # Second, we define the problem cost, gradient and Hessian functions.
    
    
    # Manifold description
    # Note that the actual dimension is KN x K.
    problem.M = copy(symfixedrankYYcomplexfactory(dot(K,N),K))
# radio_interferometric_calibration.m:95
    
    problem.cost = copy(cost)
# radio_interferometric_calibration.m:99
    
@function
def cost(x=None,*args,**kwargs):
    varargin = cost.varargin
    nargin = cost.nargin

    fval=0.0
# radio_interferometric_calibration.m:101
    ck=1
# radio_interferometric_calibration.m:102
    for p in arange(1,N - 1).reshape(-1):
        for q in arange(p + 1,N).reshape(-1):
            res=V[dot(K,(ck - 1)) + 1:dot(K,ck),:] - dot(dot(x[dot(K,(p - 1)) + 1:dot(K,p),:],C),x[dot(K,(q - 1)) + 1:dot(K,q),:].T)
# radio_interferometric_calibration.m:105
            fval=fval + real(dot(ravel(res).T,ravel(res)))
# radio_interferometric_calibration.m:106
            ck=ck + 1
# radio_interferometric_calibration.m:107
    
    return fval
    
if __name__ == '__main__':
    pass
    
    
    # Euclidean gradient of the cost function.
    # Manopt automatically converts it to the Riemannian couterpart.
    # The code involves for-loops for readability, but could be vectorized
    # for improved speed.
    problem.egrad = copy(egrad)
# radio_interferometric_calibration.m:116
    
@function
def egrad(x=None,*args,**kwargs):
    varargin = egrad.varargin
    nargin = egrad.nargin

    grad=zeros(dot(K,N),K)
# radio_interferometric_calibration.m:118
    ck=1
# radio_interferometric_calibration.m:119
    for p in arange(1,N - 1).reshape(-1):
        for q in arange(p + 1,N).reshape(-1):
            res=dot(2,(V[dot(K,(ck - 1)) + 1:dot(K,ck),:] - dot(dot(x[dot(K,(p - 1)) + 1:dot(K,p),:],C),x[dot(K,(q - 1)) + 1:dot(K,q),:].T)))
# radio_interferometric_calibration.m:122
            grad[dot(K,(p - 1)) + 1:dot(K,p),:]=grad[dot(K,(p - 1)) + 1:dot(K,p),:] - dot(dot(res,x[dot(K,(q - 1)) + 1:dot(K,q),:]),C.T)
# radio_interferometric_calibration.m:123
            grad[dot(K,(q - 1)) + 1:dot(K,q),:]=grad[dot(K,(q - 1)) + 1:dot(K,q),:] - dot(dot(res.T,x[dot(K,(p - 1)) + 1:dot(K,p),:]),C)
# radio_interferometric_calibration.m:124
            ck=ck + 1
# radio_interferometric_calibration.m:125
    
    return grad
    
if __name__ == '__main__':
    pass
    
    
    # Euclidean Hessian of the cost function along a search direction eta.
    # Manopt automatically converts it to the Riemannian couterpart.
    problem.ehess = copy(ehess)
# radio_interferometric_calibration.m:132
    
@function
def ehess(x=None,eta=None,*args,**kwargs):
    varargin = ehess.varargin
    nargin = ehess.nargin

    hess=zeros(dot(K,N),K)
# radio_interferometric_calibration.m:134
    ck=1
# radio_interferometric_calibration.m:135
    for p in arange(1,N - 1).reshape(-1):
        for q in arange(p + 1,N).reshape(-1):
            res=dot(2,(V[dot(K,(ck - 1)) + 1:dot(K,ck),:] - dot(dot(x[dot(K,(p - 1)) + 1:dot(K,p),:],C),x[dot(K,(q - 1)) + 1:dot(K,q),:].T)))
# radio_interferometric_calibration.m:138
            resdot=dot(2,(dot(dot(- x[dot(K,(p - 1)) + 1:dot(K,p),:],C),eta[dot(K,(q - 1)) + 1:dot(K,q),:].T) - dot(dot(eta[dot(K,(p - 1)) + 1:dot(K,p),:],C),x[dot(K,(q - 1)) + 1:dot(K,q),:].T)))
# radio_interferometric_calibration.m:139
            hess[dot(K,(p - 1)) + 1:dot(K,p),:]=hess[dot(K,(p - 1)) + 1:dot(K,p),:] - dot((dot(res,eta[dot(K,(q - 1)) + 1:dot(K,q),:]) + dot(resdot,x[dot(K,(q - 1)) + 1:dot(K,q),:])),C.T)
# radio_interferometric_calibration.m:141
            hess[dot(K,(q - 1)) + 1:dot(K,q),:]=hess[dot(K,(q - 1)) + 1:dot(K,q),:] - dot((dot(res.T,eta[dot(K,(p - 1)) + 1:dot(K,p),:]) + dot(resdot.T,x[dot(K,(p - 1)) + 1:dot(K,p),:])),C)
# radio_interferometric_calibration.m:142
            ck=ck + 1
# radio_interferometric_calibration.m:143
    
    return hess
    
if __name__ == '__main__':
    pass
    
    
    
    
    # Execute some checks on the derivatives for early debugging.
    # checkgradient(problem);
    # pause;
    # checkhessian(problem);
    # pause;
    
    
    # Solve.
    xsol,xcost,info=trustregions(problem,nargout=3)
# radio_interferometric_calibration.m:158
    fprintf('Final cost: %g.\\n',xcost)
    
    fs=11
# radio_interferometric_calibration.m:163
    figure
    semilogy(cat(info.iter),cat(info.gradnorm),'o-.','Color','blue','MarkerSize',6,'LineWidth',1.1)
    ax1=copy(gca)
# radio_interferometric_calibration.m:166
    set(ax1,'FontSize',fs)
    xlabel(ax1,'Iteration #','FontSize',fs)
    ylabel(ax1,'Gradient norm','FontSize',fs)
    title('Convergence of the trust-regions algorithm')
    
    if K == 2:
        # This has a closed-form solution.
        u,ignore,v=svd(dot(xsol.T,J),nargout=3)
# radio_interferometric_calibration.m:176
        # Error in position
        E=J - dot(dot(xsol,u),v.T)
# radio_interferometric_calibration.m:179
        E=E / norm(J)
# radio_interferometric_calibration.m:182
        figure
        ax1=subplot(1,2,1)
# radio_interferometric_calibration.m:186
        quiver(real(J[:,1]),imag(J[:,1]),real(E[:,1]),imag(E[:,1]))
        hold('all')
        scatter(real(J[:,1]),imag(J[:,1]))
        set(ax1,'FontSize',fs)
        xlabel('Real E_1')
        ylabel('Imag E_1')
        title('Position error 1st coordinate')
        axis('equal')
        ax2=subplot(1,2,2)
# radio_interferometric_calibration.m:195
        quiver(real(J[:,2]),imag(J[:,2]),real(E[:,2]),imag(E[:,2]))
        hold('all')
        scatter(real(J[:,2]),imag(J[:,2]))
        set(ax2,'FontSize',fs)
        xlabel('Real E_2')
        ylabel('Imag E_2')
        title('Position error 2nd coordinate')
        axis('equal')
    
    
    return hess
    
if __name__ == '__main__':
    pass
    