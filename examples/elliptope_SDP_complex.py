# Autogenerated with SMOP 
from smop.core import *
# elliptope_SDP_complex.m

    
@function
def elliptope_SDP_complex(A=None,p=None,Y0=None,*args,**kwargs):
    varargin = elliptope_SDP_complex.varargin
    nargin = elliptope_SDP_complex.nargin

    # Solver for complex semidefinite programs (SDP's) with unit diagonal.
# 
# function [Y, problem, S] = elliptope_SDP_complex(A)
# function [Y, problem, S] = elliptope_SDP_complex(A, p)
# function [Y, problem, S] = elliptope_SDP_complex(A, p, Y0)
    
    # A is a Hermitian matrix of size n.
    
    # This function uses a local optimization method in Manopt to solve the SDP
    
    #   min_X trace(A*X) s.t. diag(X) = 1, X is complex, positive semidefinite.
    
    # In practice, the Hermitian matrix X of size n is parameterized as
# X = Y*Y', where Y has size n x p. By default, p is taken large enough
# (that is, sqrt(n)) to ensure that there exists an optimal X whose rank is
# smaller than p. This ensures that the SDP is equivalent to the new
# problem in Y:
    
    #   min_Y  trace(Y'*A*Y)  s.t.  diag(Y*Y') = 1, Y complex
    
    # The constraints on Y require each row of Y to have unit norm, which is
# why Manopt is appropriate software to solve this problem. An optional
# initial guess can be specified via the input Y0.
    
    # See the paper below for theory, specifically, for a proof that, for
# almost all A, second-order critical points of the problem in Y are
# globally optimal. In other words: there are no local traps in Y, despite
# non-convexity.
    
    # Outputs:
    
    #       Y: is the best point found (an nxp matrix with unit norm rows.)
#          To find X, form Y*Y' (or, more efficiently, study X through Y.)
# 
#       problem: is the Manopt problem structure used to produce Y.
# 
#       S: is a dual optimality certificate (a Hermitian matrix of size n,
#          sparse if A is sparse). The optimality gap (in the cost
#          function) is at most n*min(eig(S)), for both Y and X = Y*Y'.
#          Hence, if min(eig(S)) is close to zero, Y is close to globally
#          optimal. This can be computed via eigs(S, 1, 'SR').
# 
# Paper: https://arxiv.org/abs/1606.04970
    
    # @inproceedings{boumal2016bmapproach,
#   author  = {Boumal, N. and Voroninski, V. and Bandeira, A.S.},
#   title   = {The non-convex {B}urer-{M}onteiro approach works on smooth semidefinite programs},
#   booktitle={Neural Information Processing Systems (NIPS 2016)},
#   year    = {2016}
# }
# 
# See also: maxcut elliptope_SDP
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Oct. 21, 2016
# Contributors:
# Change log:
    
    # If no inputs are provided, since this is an example file, generate
    # a random complex matrix. This is for illustration purposes only.
    if logical_not(exist('A','var')) or isempty(A):
        n=100
# elliptope_SDP_complex.m:64
        A=randn(n) + dot(1j,randn(n))
# elliptope_SDP_complex.m:65
        A=(A + A.T) / sqrt(dot(2,n))
# elliptope_SDP_complex.m:66
    
    n=size(A,1)
# elliptope_SDP_complex.m:69
    assert_(n >= 2,'A must be at least 2x2.')
    assert_(size(A,2) == n,'A must be square.')
    
    A=(A + A.T) / 2
# elliptope_SDP_complex.m:74
    
    if logical_not(exist('p','var')) or isempty(p):
        p=floor(sqrt(n) + 1)
# elliptope_SDP_complex.m:78
    
    
    assert_(p >= 1 and p == round(p),'p must be an integer >= 1.')
    
    manifold=obliquecomplexfactory(p,n,true)
# elliptope_SDP_complex.m:84
    problem.M = copy(manifold)
# elliptope_SDP_complex.m:86
    
    # the cost function and its derivatives. This is good code to write
    # when prototyping. Below, a more advanced use of Manopt is shown,
    # where the redundant computation A*Y is avoided between the gradient
    # and the cost evaluation.
    # # problem.cost  = @(Y) .5*sum(sum(real((A*Y).*conj(Y))));
    # # problem.egrad = @(Y) A*Y;
    # # problem.ehess = @(Y, Ydot) A*Ydot;
    
    # Products with A dominate the cost, hence we store the result.
    # This allows to share the results among cost, grad and hess.
    # This is completely optional.
    
@function
def prepare(Y=None,store=None,*args,**kwargs):
    varargin = prepare.varargin
    nargin = prepare.nargin

    if logical_not(isfield(store,'AY')):
        AY=dot(A,Y)
# elliptope_SDP_complex.m:103
        store.AY = copy(AY)
# elliptope_SDP_complex.m:104
        store.diagAYYt = copy(sum(real(multiply(AY,conj(Y))),2))
# elliptope_SDP_complex.m:105
    
    return store
    
if __name__ == '__main__':
    pass
    
    
    # Define the cost function to be /minimized/.
    problem.cost = copy(cost)
# elliptope_SDP_complex.m:110
    
@function
def cost(Y=None,store=None,*args,**kwargs):
    varargin = cost.varargin
    nargin = cost.nargin

    store=prepare(Y,store)
# elliptope_SDP_complex.m:112
    f=dot(0.5,sum(store.diagAYYt))
# elliptope_SDP_complex.m:113
    return f,store
    
if __name__ == '__main__':
    pass
    
    # Define the Riemannian gradient.
    problem.grad = copy(grad)
# elliptope_SDP_complex.m:117
    
@function
def grad(Y=None,store=None,*args,**kwargs):
    varargin = grad.varargin
    nargin = grad.nargin

    store=prepare(Y,store)
# elliptope_SDP_complex.m:119
    G=store.AY - bsxfun(times,Y,store.diagAYYt)
# elliptope_SDP_complex.m:120
    return G,store
    
if __name__ == '__main__':
    pass
    
    # If you want to, you can specify the Riemannian Hessian as well.
    problem.hess = copy(hess)
# elliptope_SDP_complex.m:124
    
@function
def hess(Y=None,Ydot=None,store=None,*args,**kwargs):
    varargin = hess.varargin
    nargin = hess.nargin

    store=prepare(Y,store)
# elliptope_SDP_complex.m:126
    SYdot=dot(A,Ydot) - bsxfun(times,Ydot,store.diagAYYt)
# elliptope_SDP_complex.m:127
    H=manifold.proj(Y,SYdot)
# elliptope_SDP_complex.m:128
    return H,store
    
if __name__ == '__main__':
    pass
    
    # If no initial guess is available, tell Manopt to use a random one.
    if logical_not(exist('Y0','var')) or isempty(Y0):
        Y0=matlabarray([])
# elliptope_SDP_complex.m:134
    
    # Call your favorite solver.
    opts=struct()
# elliptope_SDP_complex.m:138
    opts.verbosity = copy(0)
# elliptope_SDP_complex.m:139
    
    opts.maxinner = copy(500)
# elliptope_SDP_complex.m:140
    
    opts.tolgradnorm = copy(1e-06)
# elliptope_SDP_complex.m:141
    
    Y=trustregions(problem,Y0,opts)
# elliptope_SDP_complex.m:142
    
    if nargout >= 3:
        S=A - spdiags(sum(real(multiply((dot(A,Y)),conj(Y))),2),0,n,n)
# elliptope_SDP_complex.m:146
    
    return H,store
    
if __name__ == '__main__':
    pass
    