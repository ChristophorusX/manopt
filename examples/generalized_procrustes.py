# Autogenerated with SMOP 
from smop.core import *
# generalized_procrustes.m

    
@function
def generalized_procrustes(A_measure=None,*args,**kwargs):
    varargin = generalized_procrustes.varargin
    nargin = generalized_procrustes.nargin

    # Rotationally align clouds of points (generalized Procrustes problem)
    
    # function X = generalized_procrustes(A_measure)
    
    # The input is a 3D matrix A_measure of size nxmxN. Each of the N slices
# A_measure(:, :, i) is a cloud of m points in R^n. These clouds are
# assumed to be (noisy) rotated versions of a reference cloud Atrue.
# This algorithm tries to find the optimal rotations to apply to the
# individual clouds such that they will match each other as much as
# possible following a least-squares cost.
    
    # The output A is an estimate of the cloud Atrue (up to rotation). The
# output R is a 3D matrix of size nxnxN containing the rotation matrices
# such that R(:, :, i) * A is approximately equal to A_measure(:, :, i).
    
    # This file is part of Manopt and is copyrighted. See the license file.
    
    # Main author: Nicolas Boumal, July 8, 2013
# Contributors:
    
    # Change log:
#
    
    if logical_not(exist('A_measure','var')):
        # Generate random data to test the method.
        # There are N clouds of m points in R^n. Each of them is a noisy,
        # rotated version of a reference cloud A. Rotations are uniformly
        # random and noise on each rotated cloud is iid normal with
        # standard deviation sigma.
        n=3
# generalized_procrustes.m:31
        m=10
# generalized_procrustes.m:32
        N=50
# generalized_procrustes.m:33
        Atrue=randn(n,m)
# generalized_procrustes.m:35
        sigma=0.3
# generalized_procrustes.m:37
        A_measure=multiprod(randrot(n,N),Atrue) + dot(sigma,randn(n,m,N))
# generalized_procrustes.m:38
    else:
        n,m,N=size(A_measure,nargout=3)
# generalized_procrustes.m:40
    
    
    # Construct a manifold structure representing the product of groups of
    # rotations with the Euclidean space for A. We optimize simultaneously
    # for the reference cloud and for the rotations that affect each of the
    # measured clouds. Notice that there is a group invariance because
    # there is no way of telling which orientation the reference cloud
    # should be in.
    tuple.R = copy(rotationsfactory(n,N))
# generalized_procrustes.m:49
    tuple.A = copy(euclideanfactory(n,m))
# generalized_procrustes.m:50
    M=productmanifold(tuple)
# generalized_procrustes.m:51
    
    # structures with fields X.A and X.R, containing matrices of sizes
    # respectively nxm and nxnxN. The store structure (the caching system)
    # is used to keep the residue matrix E in memory, as it is also used in
    # the computation of the gradient and of the Hessian. This way, we
    # prevent redundant computations.
    
@function
def cost(X=None,store=None,*args,**kwargs):
    varargin = cost.varargin
    nargin = cost.nargin

    if logical_not(isfield(store,'E')):
        R=X.R
# generalized_procrustes.m:61
        A=X.A
# generalized_procrustes.m:62
        store.E = copy(multiprod(R,A) - A_measure)
# generalized_procrustes.m:63
    
    E=store.E
# generalized_procrustes.m:65
    f=(dot(ravel(E).T,ravel(E))) / (dot(2,N))
# generalized_procrustes.m:66
    return f,store
    
if __name__ == '__main__':
    pass
    
    # Riemannian gradient of the cost function.
    
@function
def grad(X=None,store=None,*args,**kwargs):
    varargin = grad.varargin
    nargin = grad.nargin

    R=X.R
# generalized_procrustes.m:71
    A=X.A
# generalized_procrustes.m:72
    if logical_not(isfield(store,'E')):
        __,store=cost(X,store,nargout=2)
# generalized_procrustes.m:74
    
    E=store.E
# generalized_procrustes.m:76
    
    # and wrt the cloud A,
    egrad.R = copy(multiprod(E,A.T / N))
# generalized_procrustes.m:79
    egrad.A = copy(A - mean(multiprod(multitransp(R),A_measure),3))
# generalized_procrustes.m:80
    
    # gradient.
    g=M.egrad2rgrad(X,egrad)
# generalized_procrustes.m:83
    store.egrad = copy(egrad)
# generalized_procrustes.m:84
    return g,store
    
if __name__ == '__main__':
    pass
    
    # It is not necessary to define the Hessian of the cost. We do it
    # mostly to illustrate how to do it and to study the spectrum of the
    # Hessian at the solution (see further down).
    
@function
def hess(X=None,Xdot=None,store=None,*args,**kwargs):
    varargin = hess.varargin
    nargin = hess.nargin

    R=X.R
# generalized_procrustes.m:91
    A=X.A
# generalized_procrustes.m:92
    
    # skew symmetric matrices. To obtain the corresponding vectors in
        # the ambient space, we need a little transformation. This
        # transformation is typically not needed when we compute the
        # formulas for the gradient and the Hessian directly in Riemannian
        # form instead of resorting the egrad2rgrad and ehess2rhess. These
        # latter tools are convenient for prototyping but are not always
        # the most efficient form to execute the computations.
    Rdot=tuple.R.tangent2ambient(R,Xdot.R)
# generalized_procrustes.m:101
    Adot=Xdot.A
# generalized_procrustes.m:102
    if logical_not(isfield(store,'egrad')):
        __,store=grad(X,store,nargout=2)
# generalized_procrustes.m:104
    
    E=store.E
# generalized_procrustes.m:106
    egrad=store.egrad
# generalized_procrustes.m:107
    ehess.R = copy(multiprod(multiprod(Rdot,A) + multiprod(R,Adot),A.T) + multiprod(E,Adot.T))
# generalized_procrustes.m:109
    ehess.R = copy(ehess.R / N)
# generalized_procrustes.m:111
    ehess.A = copy(Adot - mean(multiprod(multitransp(Rdot),A_measure),3))
# generalized_procrustes.m:112
    h=M.ehess2rhess(X,egrad,ehess,Xdot)
# generalized_procrustes.m:114
    return h,store
    
if __name__ == '__main__':
    pass
    
    # Setup the problem structure with manifold M and cost+grad functions.
    problem.M = copy(M)
# generalized_procrustes.m:118
    problem.cost = copy(cost)
# generalized_procrustes.m:119
    problem.grad = copy(grad)
# generalized_procrustes.m:120
    problem.hess = copy(hess)
# generalized_procrustes.m:121
    
    # checkgradient(problem);
    # pause;
    # checkhessian(problem);
    # pause;
    
    # Call a solver on our problem. This can probably be much improved if a
	# clever initial guess is used instead of a random one.
    X=trustregions(problem)
# generalized_procrustes.m:131
    A=X.A
# generalized_procrustes.m:132
    R=X.R
# generalized_procrustes.m:133
    
    # reference cloud) matches A (the found cloud). Since the recovery is
    # up to rotation, apply Kabsch algorithm (or standard Procrustes),
    # i.e., compute the polar factorization to best align Atrue and A.
    if exist('Atrue','var'):
        U,__,V=svd(dot(Atrue,A.T),nargout=3)
# generalized_procrustes.m:140
        Ahat=dot((dot(U,V.T)),A)
# generalized_procrustes.m:141
        fprintf('Registration error: %g.\\n',norm(Atrue - Ahat,'fro'))
    
    
    # Plot the spectrum of the Hessian at the solution found.
    # Notice that the invariance of f under a rotation yields dim SO(n),
    # that is, n*(n-1)/2 zero eigenvalues in the Hessian spectrum at the
    # solution. This indicates that critical points are not isolated and
    # can theoretically prevent quadratic convergence. One solution to
    # circumvent this would be to fix one rotation arbitrarily. Another
    # solution would be to work on a quotient manifold. Both can be
    # achieved in Manopt: they simply require a little more work on the
    # manifold description side.
    if M.dim() <= 512:
        stairs(sort(hessianspectrum(problem,X)))
        title('Spectrum of the Hessian at the solution found.')
        xlabel('Eigenvalue number (sorted)')
        ylabel('Value of the eigenvalue')
    
    
    return h,store
    
if __name__ == '__main__':
    pass
    