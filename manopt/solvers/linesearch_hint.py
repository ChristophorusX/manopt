# Autogenerated with SMOP 
from smop.core import *
# linesearch/linesearch_hint.m

    
@function
def linesearch_hint(problem=None,x=None,d=None,f0=None,df0=None,options=None,storedb=None,key=None,*args,**kwargs):
    varargin = linesearch_hint.varargin
    nargin = linesearch_hint.nargin

    # Armijo line-search based on the line-search hint in the problem structure.
    
    # function [stepsize, newx, newkey, lsstats] = 
#            linesearch_hint(problem, x, d, f0, df0, options, storedb, key)
    
    # Base line-search algorithm for descent methods, based on a simple
# backtracking method. The search direction provided has to be a descent
# direction, as indicated by a negative df0 = directional derivative of f
# at x along d.
    
    # The algorithm obtains an initial step size candidate from the problem
# structure, typically through the problem.linesearch function. If that
# step does not fulfill the Armijo sufficient decrease criterion, that step
# size is reduced geometrically until a satisfactory step size is obtained
# or until a failure criterion triggers.
# 
# Below, the step is constructed as alpha*d, and the step size is the norm
# of that vector, thus: stepsize = alpha*norm_d. The step is executed by
# retracting the vector alpha*d from the current point x, giving newx.
    
    # Inputs/Outputs : see help for linesearch
    
    # See also: steepestdescent conjugategradients linesearch
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, July 17, 2014.
# Contributors: 
# Change log:
    
    #   April 3, 2015 (NB):
#       Works with the new StoreDB class system.
    
    #   April 8, 2015 (NB):
#       Got rid of lsmem input/output.
    
    # Allow omission of the key, and even of storedb.
    if logical_not(exist('key','var')):
        if logical_not(exist('storedb','var')):
            storedb=StoreDB()
# linesearch/linesearch_hint.m:42
        key=storedb.getNewKey()
# linesearch/linesearch_hint.m:44
    
    # Backtracking default parameters. These can be overwritten in the
    # options structure which is passed to the solver.
    default_options.ls_contraction_factor = copy(0.5)
# linesearch/linesearch_hint.m:49
    default_options.ls_suff_decr = copy(0.0001)
# linesearch/linesearch_hint.m:50
    default_options.ls_max_steps = copy(25)
# linesearch/linesearch_hint.m:51
    if logical_not(exist('options','var')) or isempty(options):
        options=struct()
# linesearch/linesearch_hint.m:54
    
    options=mergeOptions(default_options,options)
# linesearch/linesearch_hint.m:56
    contraction_factor=options.ls_contraction_factor
# linesearch/linesearch_hint.m:58
    suff_decr=options.ls_suff_decr
# linesearch/linesearch_hint.m:59
    max_ls_steps=options.ls_max_steps
# linesearch/linesearch_hint.m:60
    
    # assumed that the present line-search is only called when the problem
    # structure provides enough information for the call here to work.
    alpha=getLinesearch(problem,x,d,storedb,key)
# linesearch/linesearch_hint.m:65
    
    newx=problem.M.retr(x,d,alpha)
# linesearch/linesearch_hint.m:68
    newkey=storedb.getNewKey()
# linesearch/linesearch_hint.m:69
    newf=getCost(problem,newx,storedb,newkey)
# linesearch/linesearch_hint.m:70
    cost_evaluations=1
# linesearch/linesearch_hint.m:71
    
    while newf > f0 + dot(dot(suff_decr,alpha),df0):

        # Reduce the step size,
        alpha=dot(contraction_factor,alpha)
# linesearch/linesearch_hint.m:77
        newx=problem.M.retr(x,d,alpha)
# linesearch/linesearch_hint.m:80
        newkey=storedb.getNewKey()
# linesearch/linesearch_hint.m:81
        newf=getCost(problem,newx,storedb,newkey)
# linesearch/linesearch_hint.m:82
        cost_evaluations=cost_evaluations + 1
# linesearch/linesearch_hint.m:83
        if cost_evaluations >= max_ls_steps:
            break

    
    
    # If we got here without obtaining a decrease, we reject the step.
    if newf > f0:
        alpha=0
# linesearch/linesearch_hint.m:94
        newx=copy(x)
# linesearch/linesearch_hint.m:95
        newkey=copy(key)
# linesearch/linesearch_hint.m:96
        newf=copy(f0)
# linesearch/linesearch_hint.m:97
    
    
    # As seen outside this function, stepsize is the size of the vector we
    # retract to make the step from x to newx. Since the step is alpha*d:
    norm_d=problem.M.norm(x,d)
# linesearch/linesearch_hint.m:102
    stepsize=dot(alpha,norm_d)
# linesearch/linesearch_hint.m:103
    
    lsstats.costevals = copy(cost_evaluations)
# linesearch/linesearch_hint.m:106
    lsstats.stepsize = copy(stepsize)
# linesearch/linesearch_hint.m:107
    lsstats.alpha = copy(alpha)
# linesearch/linesearch_hint.m:108
    return stepsize,newx,newkey,lsstats
    
if __name__ == '__main__':
    pass
    