# Autogenerated with SMOP 
from smop.core import *
# preconditioners/preconhessiansolve.m

    
@function
def preconhessiansolve(problem=None,options=None,*args,**kwargs):
    varargin = preconhessiansolve.varargin
    nargin = preconhessiansolve.nargin

    # Preconditioner based on the inverse Hessian, by solving linear systems.
    
    # function preconfun = preconhessiansolve(problem)
# function preconfun = preconhessiansolve(problem, options)
    
    # Input:
    
    # A Manopt problem structure (already containing the manifold and enough
# information to compute the Hessian of the cost) and an options structure
# (optional, currently ignored). Notice that if the Hessian is not positive
# definite, then its inverse is not positive definite either and this
# preconditioner is not suitable.
    
    # If the Hessian cannot be computed on 'problem', a warning is issued. An
# approximation of the Hessian will be used instead, and the present
# preconditioner will attempt to invert that (although it may not be a
# linear operator). If no approximate Hessian is provided either, a generic
# approximation is used. Behavior is unspecified.
    
    # Output:
# 
# Returns a function handle, encapsulating a generic preconditioner of the
# Hessian based on solving linear systems of the form:
#   Hessian(x)[preconfun(x, xdot)] = xdot,
# where x is the point on the manifold, xdot is the input to the
# preconditioner (a tangent vector) and preconfun(x, xdot) is returned
# (also a tangent vector). The solve may be approximate.
# 
# The returned preconfun has this calling pattern:
# 
#   function precxdot = preconfun(x, xdot)
#   function precxdot = preconfun(x, xdot, storedb)
#   function precxdot = preconfun(x, xdot, storedb, key)
# 
# x is a point on the manifold problem.M, xdot is a tangent vector to that
# manifold at x, storedb is a StoreDB object, and key is the StoreDB key to
# point x.
    
    # Usage:
    
    # Typically, the user will set problem.M and other fields to define the
# cost, the gradient and the Hessian (typically, problem.cost, problem.grad
# and problem.hess, or problem.egrad and problem.ehess). Then, to use this
# generic purpose Hessian preconditioner:
    
    #   problem.precon = preconhessiansolve(problem, options);
    
    # Passing that problem structure to the conjugategradients solver
# (which uses preconditioning) configured in steepest descent mode results
# in a type of Riemannian Newton method.
    
    # See also: conjugategradients
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, April 9, 2015.
# Contributors: 
# Change log:
    
    # Check availability of the Hessian, or at least of an approximation.
    if logical_not(canGetHessian(problem)) and logical_not(canGetApproxHessian(problem)):
        # Note: we do not give a warning if an approximate Hessian is
        # explicitly given in the problem description, as in that case the
        # user seems to be aware of the issue.
        warning('manopt:getHessian:approx',cat('No Hessian provided. Using an FD approximation instead.\\n','To disable this warning: warning(\'off\', \'manopt:getHessian:approx\')'))
        problem.approxhess = copy(approxhessianFD(problem))
# preconditioners/preconhessiansolve.m:68
    
    # Set local defaults here, and merge with user options, if any.
    localdefaults=struct()
# preconditioners/preconhessiansolve.m:72
    if logical_not(exist('options','var')) or isempty(options):
        options=struct()
# preconditioners/preconhessiansolve.m:74
    
    options=mergeOptions(localdefaults,options)
# preconditioners/preconhessiansolve.m:76
    
    # funhandle makes it possible to make storedb and key optional.
    preconfun=funhandle
# preconditioners/preconhessiansolve.m:80
    
@function
def funhandle(x=None,xdot=None,storedb=None,key=None,*args,**kwargs):
    varargin = funhandle.varargin
    nargin = funhandle.nargin

    # Allow omission of the key, and even of storedb.
    if logical_not(exist('key','var')):
        if logical_not(exist('storedb','var')):
            storedb=StoreDB()
# preconditioners/preconhessiansolve.m:85
        key=storedb.getNewKey()
# preconditioners/preconhessiansolve.m:87
    
    precxdot=hessiansolvehelper(options,problem,x,xdot,storedb,key)
# preconditioners/preconhessiansolve.m:89
    return precxdot
    
if __name__ == '__main__':
    pass
    
    
    return precxdot
    
if __name__ == '__main__':
    pass
    
    
@function
def hessiansolvehelper(options=None,problem=None,x=None,xdot=None,storedb=None,key=None,*args,**kwargs):
    varargin = hessiansolvehelper.varargin
    nargin = hessiansolvehelper.nargin

    # This function does the actual work.
    
    # Exclude the case where xdot is zero
    norm_xdot=problem.M.norm(x,xdot)
# preconditioners/preconhessiansolve.m:100
    if norm_xdot < eps:
        precxdot=problem.M.zerovec(x)
# preconditioners/preconhessiansolve.m:102
        return precxdot
    
    
    # Get a shorthand for the Hessian of the cost on M at x.
    hessian=lambda u=None: getHessian(problem,x,u,storedb,key)
# preconditioners/preconhessiansolve.m:107
    
    M=problem.M
# preconditioners/preconhessiansolve.m:110
    tgtspace=tangentspacefactory(M,x)
# preconditioners/preconhessiansolve.m:111
    prblm.M = copy(tgtspace)
# preconditioners/preconhessiansolve.m:112
    prblm.cost = copy(cost)
# preconditioners/preconhessiansolve.m:113
    prblm.grad = copy(grad)
# preconditioners/preconhessiansolve.m:114
    prblm.hess = copy(lambda u=None,udot=None: dot(2,hessian[hessian[udot]]) / norm_xdot)
# preconditioners/preconhessiansolve.m:115
    
@function
def cost(u=None,store=None,*args,**kwargs):
    varargin = cost.varargin
    nargin = cost.nargin

    if logical_not(isfield(store,'residue')):
        Hu=hessian[u]
# preconditioners/preconhessiansolve.m:119
        store.residue = copy(M.lincomb(x,1,Hu,- 1,xdot))
# preconditioners/preconhessiansolve.m:120
    
    f=M.norm(x,store.residue) ** 2 / norm_xdot
# preconditioners/preconhessiansolve.m:122
    return f,store
    
if __name__ == '__main__':
    pass
    
    
@function
def grad(u=None,store=None,*args,**kwargs):
    varargin = grad.varargin
    nargin = grad.nargin

    if logical_not(isfield(store,'residue')):
        Hu=hessian[u]
# preconditioners/preconhessiansolve.m:126
        store.residue = copy(M.lincomb(x,1,Hu,- 1,xdot))
# preconditioners/preconhessiansolve.m:127
    
    g=dot(2,hessian[store.residue]) / norm_xdot
# preconditioners/preconhessiansolve.m:129
    return g,store
    
if __name__ == '__main__':
    pass
    
    
    # checkgradient(prblm); pause;
    # checkhessian(prblm); pause;
    
    localdefaults.solver = copy(trustregions)
# preconditioners/preconhessiansolve.m:135
    localdefaults.verbosity = copy(0)
# preconditioners/preconhessiansolve.m:136
    
    if logical_not(exist('options','var')) or isempty(options):
        options=struct()
# preconditioners/preconhessiansolve.m:139
    
    options=mergeOptions(localdefaults,options)
# preconditioners/preconhessiansolve.m:141
    
    precxdot=manoptsolve(prblm,M.zerovec(),options)
# preconditioners/preconhessiansolve.m:144
    return g,store
    
if __name__ == '__main__':
    pass
    