# Autogenerated with SMOP 
from smop.core import *
# neldermead/neldermead.m

    
@function
def neldermead(problem=None,x=None,options=None,*args,**kwargs):
    varargin = neldermead.varargin
    nargin = neldermead.nargin

    # Nelder Mead optimization algorithm for derivative-free minimization.
    
    # function [x, cost, info, options] = neldermead(problem)
# function [x, cost, info, options] = neldermead(problem, x0)
# function [x, cost, info, options] = neldermead(problem, x0, options)
# function [x, cost, info, options] = neldermead(problem, [], options)
    
    # Apply a Nelder-Mead minimization algorithm to the problem defined in
# the problem structure, starting with the population x0 if it is provided
# (otherwise, a random population on the manifold is generated). A
# population is a cell containing points on the manifold. The number of
# elements in the cell must be dim+1, where dim is the dimension of the
# manifold: problem.M.dim().
    
    # To specify options whilst not specifying an initial guess, give x0 as []
# (the empty matrix).
    
    # This algorithm is a plain adaptation of the Euclidean Nelder-Mead method
# to the Riemannian setting. It comes with no convergence guarantees and
# there is room for improvement. In particular, we compute centroids as
# Karcher means, which seems overly expensive: cheaper forms of
# average-like quantities might work better.
# This solver is useful nonetheless for problems for which no derivatives
# are available, and it may constitute a starting point for the development
# of other Riemannian derivative-free methods.
    
    # None of the options are mandatory. See in code for details.
    
    # Requires problem.M.pairmean(x, y) to be defined (computes the average
# between two points, x and y).
    
    # If options.statsfun is defined, it will receive a cell of points x (the
# current simplex being considered at that iteration), and, if required,
# one store structure corresponding to the best point, x{1}. The points are
# ordered by increasing cost: f(x{1}) <= f(x{2}) <= ... <= f(x{dim+1}),
# where dim = problem.M.dim().
    
    # Based on http://www.optimization-online.org/DB_FILE/2007/08/1742.pdf.
    
    # See also: manopt/solvers/pso/pso
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Dec. 30, 2012.
# Contributors: 
# Change log:
    
    #   April 4, 2015 (NB):
#       Working with the new StoreDB class system.
#       Clarified interactions with statsfun and store.
    
    #   Nov. 11, 2016 (NB):
#       If options.verbosity is < 2, prints minimal output.
    
    
    # Verify that the problem description is sufficient for the solver.
    if logical_not(canGetCost(problem)):
        warning('manopt:getCost','No cost provided. The algorithm will likely abort.')
    
    
    # Dimension of the manifold
    dim=problem.M.dim()
# neldermead/neldermead.m:63
    
    localdefaults.storedepth = copy(0)
# neldermead/neldermead.m:66
    
    localdefaults.maxcostevals = copy(max(1000,dot(2,dim)))
# neldermead/neldermead.m:67
    localdefaults.maxiter = copy(max(2000,dot(4,dim)))
# neldermead/neldermead.m:68
    localdefaults.reflection = copy(1)
# neldermead/neldermead.m:70
    localdefaults.expansion = copy(2)
# neldermead/neldermead.m:71
    localdefaults.contraction = copy(0.5)
# neldermead/neldermead.m:72
    
    # localdefaults.shrinkage = .5;
    
    # Merge global and local defaults, then merge w/ user options, if any.
    localdefaults=mergeOptions(getGlobalDefaults(),localdefaults)
# neldermead/neldermead.m:77
    if logical_not(exist('options','var')) or isempty(options):
        options=struct()
# neldermead/neldermead.m:79
    
    options=mergeOptions(localdefaults,options)
# neldermead/neldermead.m:81
    
    timetic=tic()
# neldermead/neldermead.m:84
    
    if logical_not(exist('x','var')) or isempty(x):
        x=cell(dim + 1,1)
# neldermead/neldermead.m:88
        for i in arange(1,dim + 1).reshape(-1):
            x[i]=problem.M.rand()
# neldermead/neldermead.m:90
    
    
    # Create a store database and a key for each point.
    storedb=StoreDB(options.storedepth)
# neldermead/neldermead.m:95
    key=cell(size(x))
# neldermead/neldermead.m:96
    for i in arange(1,dim + 1).reshape(-1):
        key[i]=storedb.getNewKey()
# neldermead/neldermead.m:98
    
    
    # Compute objective-related quantities for x, and setup a
    # function evaluations counter.
    costs=zeros(dim + 1,1)
# neldermead/neldermead.m:103
    for i in arange(1,dim + 1).reshape(-1):
        costs[i]=getCost(problem,x[i],storedb,key[i])
# neldermead/neldermead.m:105
    
    costevals=dim + 1
# neldermead/neldermead.m:107
    
    costs,order=sort(costs,nargout=2)
# neldermead/neldermead.m:110
    x=x[order]
# neldermead/neldermead.m:111
    key=key[order]
# neldermead/neldermead.m:112
    
    # At any point, iter is the number of fully executed iterations so far.
    iter=0
# neldermead/neldermead.m:116
    
    # savestats will be called twice for the initial iterate (number 0),
    # which is unfortunate, but not problematic.
    stats=savestats()
# neldermead/neldermead.m:121
    info[1]=stats
# neldermead/neldermead.m:122
    info[min(10000,options.maxiter + 1)].iter = copy([])
# neldermead/neldermead.m:123
    
    while true:

        # Make sure we don't use to much memory for the store database.
        storedb.purge()
        stats=savestats()
# neldermead/neldermead.m:131
        info[iter + 1]=stats
# neldermead/neldermead.m:132
        iter=iter + 1
# neldermead/neldermead.m:133
        timetic=tic()
# neldermead/neldermead.m:136
        costs,order=sort(costs,nargout=2)
# neldermead/neldermead.m:139
        x=x[order]
# neldermead/neldermead.m:140
        key=key[order]
# neldermead/neldermead.m:141
        if options.verbosity >= 2:
            fprintf('Cost evals: %7d\\tBest cost: %+.4e\\t',costevals,costs[1])
        # Run standard stopping criterion checks.
        stop,reason=stoppingcriterion(problem,x,options,info,iter,nargout=2)
# neldermead/neldermead.m:150
        if stop:
            if options.verbosity >= 1:
                fprintf(cat(reason,'\\n'))
            break
        # Compute a centroid for the dim best points.
        xbar=centroid(problem.M,x[1:end() - 1])
# neldermead/neldermead.m:160
        vec=problem.M.log(xbar,x[end()])
# neldermead/neldermead.m:163
        xr=problem.M.exp(xbar,vec,- options.reflection)
# neldermead/neldermead.m:166
        keyr=storedb.getNewKey()
# neldermead/neldermead.m:167
        costr=getCost(problem,xr,storedb,keyr)
# neldermead/neldermead.m:168
        costevals=costevals + 1
# neldermead/neldermead.m:169
        # replace it by the reflected point and start new iteration.
        if costr >= costs[1] and costr < costs[end() - 1]:
            if options.verbosity >= 2:
                fprintf('Reflection\\n')
            costs[end()]=costr
# neldermead/neldermead.m:177
            x[end()]=xr
# neldermead/neldermead.m:178
            key[end()]=keyr
# neldermead/neldermead.m:179
            continue
        # If the reflected point is better than the best point, expand.
        if costr < costs[1]:
            xe=problem.M.exp(xbar,vec,- options.expansion)
# neldermead/neldermead.m:185
            keye=storedb.getNewKey()
# neldermead/neldermead.m:186
            coste=getCost(problem,xe,storedb,keye)
# neldermead/neldermead.m:187
            costevals=costevals + 1
# neldermead/neldermead.m:188
            if coste < costr:
                if options.verbosity >= 2:
                    fprintf('Expansion\\n')
                costs[end()]=coste
# neldermead/neldermead.m:193
                x[end()]=xe
# neldermead/neldermead.m:194
                key[end()]=keye
# neldermead/neldermead.m:195
                continue
            else:
                if options.verbosity >= 2:
                    fprintf('Reflection (failed expansion)\\n')
                costs[end()]=costr
# neldermead/neldermead.m:201
                x[end()]=xr
# neldermead/neldermead.m:202
                key[end()]=keyr
# neldermead/neldermead.m:203
                continue
        # If the reflected point is worse than the second to worst point,
		# contract.
        if costr >= costs[end() - 1]:
            if costr < costs[end()]:
                # do an outside contraction
                xoc=problem.M.exp(xbar,vec,- options.contraction)
# neldermead/neldermead.m:213
                keyoc=storedb.getNewKey()
# neldermead/neldermead.m:214
                costoc=getCost(problem,xoc,storedb,keyoc)
# neldermead/neldermead.m:215
                costevals=costevals + 1
# neldermead/neldermead.m:216
                if costoc <= costr:
                    if options.verbosity >= 2:
                        fprintf('Outside contraction\\n')
                    costs[end()]=costoc
# neldermead/neldermead.m:221
                    x[end()]=xoc
# neldermead/neldermead.m:222
                    key[end()]=keyoc
# neldermead/neldermead.m:223
                    continue
            else:
                # do an inside contraction
                xic=problem.M.exp(xbar,vec,options.contraction)
# neldermead/neldermead.m:228
                keyic=storedb.getNewKey()
# neldermead/neldermead.m:229
                costic=getCost(problem,xic,storedb,keyic)
# neldermead/neldermead.m:230
                costevals=costevals + 1
# neldermead/neldermead.m:231
                if costic <= costs[end()]:
                    if options.verbosity >= 2:
                        fprintf('Inside contraction\\n')
                    costs[end()]=costic
# neldermead/neldermead.m:236
                    x[end()]=xic
# neldermead/neldermead.m:237
                    key[end()]=keyic
# neldermead/neldermead.m:238
                    continue
        # If we get here, shrink the simplex around x{1}.
        if options.verbosity >= 2:
            fprintf('Shrinkage\\n')
        for i in arange(2,dim + 1).reshape(-1):
            x[i]=problem.M.pairmean(x[1],x[i])
# neldermead/neldermead.m:249
            key[i]=storedb.getNewKey()
# neldermead/neldermead.m:250
            costs[i]=getCost(problem,x[i],storedb,key[i])
# neldermead/neldermead.m:251
        costevals=costevals + dim
# neldermead/neldermead.m:253

    
    
    
    info=info[1:iter]
# neldermead/neldermead.m:258
    
    cost=costs[1]
# neldermead/neldermead.m:261
    x=x[1]
# neldermead/neldermead.m:262
    key=key[1]
# neldermead/neldermead.m:263
    
    
@function
def savestats(*args,**kwargs):
    varargin = savestats.varargin
    nargin = savestats.nargin

    stats.iter = copy(iter)
# neldermead/neldermead.m:269
    stats.cost = copy(costs[1])
# neldermead/neldermead.m:270
    stats.costevals = copy(costevals)
# neldermead/neldermead.m:271
    if iter == 0:
        stats.time = copy(toc(timetic))
# neldermead/neldermead.m:273
    else:
        stats.time = copy(info[iter].time + toc(timetic))
# neldermead/neldermead.m:275
    
    # The statsfun can only possibly receive one store structure. We
        # pass the key to the best point, so that the best point's store
        # will be passed. But the whole cell x of points is passed through.
    stats=applyStatsfun(problem,x,storedb,key[1],options,stats)
# neldermead/neldermead.m:280
    return stats
    
if __name__ == '__main__':
    pass
    
    
    return stats
    
if __name__ == '__main__':
    pass
    