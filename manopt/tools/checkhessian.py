# Autogenerated with SMOP 
from smop.core import *
# checkhessian.m

    
@function
def checkhessian(problem=None,x=None,d=None,*args,**kwargs):
    varargin = checkhessian.varargin
    nargin = checkhessian.nargin

    # Checks the consistency of the cost function and the Hessian.
    
    # function checkhessian(problem)
# function checkhessian(problem, x)
# function checkhessian(problem, x, d)
    
    # checkhessian performs a numerical test to check that the directional
# derivatives and Hessian defined in the problem structure agree up to
# second order with the cost function at some point x, along some direction
# d. The test is based on a truncated Taylor series (see online Manopt
# documentation).
# 
# It is also tested that the result of applying the Hessian along that
# direction is indeed a tangent vector, and that the Hessian operator is
# symmetric w.r.t. the Riemannian metric.
# 
# Both x and d are optional and will be sampled at random if omitted.
    
    # See also: checkdiff checkgradient checkretraction
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Dec. 30, 2012.
# Contributors: 
# Change log:
    
    #   April 3, 2015 (NB):
#       Works with the new StoreDB class system.
    
    #   Nov. 1, 2016 (NB):
#       Issues a call to getGradient rather than getDirectionalDerivative.
    
    
    # Verify that the problem description is sufficient.
    if logical_not(canGetCost(problem)):
        error('It seems no cost was provided.')
    
    if logical_not(canGetGradient(problem)):
        warning('manopt:checkhessian:nograd','It seems no gradient was provided.')
    
    if logical_not(canGetHessian(problem)):
        warning('manopt:checkhessian:nohess','It seems no Hessian was provided.')
    
    
    x_isprovided=exist('x','var') and logical_not(isempty(x))
# checkhessian.m:47
    d_isprovided=exist('d','var') and logical_not(isempty(d))
# checkhessian.m:48
    if logical_not(x_isprovided) and d_isprovided:
        error('If d is provided, x must be too, since d is tangent at x.')
    
    
    # If x and / or d are not specified, pick them at random.
    if logical_not(x_isprovided):
        x=problem.M.rand()
# checkhessian.m:56
    
    if logical_not(d_isprovided):
        d=problem.M.randvec(x)
# checkhessian.m:59
    
    
    ## Check that the directional derivative and the Hessian at x along d
    ## yield a second order model of the cost function.
    
    # Compute the value f0 at f, directional derivative df0 at x along d,
    # and Hessian along [d, d].
    storedb=StoreDB()
# checkhessian.m:67
    xkey=storedb.getNewKey()
# checkhessian.m:68
    f0=getCost(problem,x,storedb,xkey)
# checkhessian.m:69
    df0=problem.M.inner(x,d,getGradient(problem,x,storedb,xkey))
# checkhessian.m:70
    d2f0=problem.M.inner(x,d,getHessian(problem,x,d,storedb,xkey))
# checkhessian.m:71
    
    # of it) originating from x, along direction d, for stepsizes in a
    # large range given by h.
    h=logspace(- 8,0,51)
# checkhessian.m:76
    value=zeros(size(h))
# checkhessian.m:77
    for i in arange(1,length(h)).reshape(-1):
        y=problem.M.exp(x,d,h[i])
# checkhessian.m:79
        ykey=storedb.getNewKey()
# checkhessian.m:80
        value[i]=getCost(problem,y,storedb,ykey)
# checkhessian.m:81
    
    
    # Compute the quadratic approximation of the cost function using f0,
    # df0 and d2f0 at the same points.
    model=polyval(cat(dot(0.5,d2f0),df0,f0),h)
# checkhessian.m:86
    
    err=abs(model - value)
# checkhessian.m:89
    
    loglog(h,err)
    title(sprintf(cat('Hessian check.\\nThe slope of the continuous line ','should match that of the dashed\\n(reference) line ','over at least a few orders of magnitude for h.')))
    xlabel('h')
    ylabel('Approximation error')
    line('xdata',cat(1e-08,1.0),'ydata',cat(1e-16,100000000.0),'color','k','LineStyle','--','YLimInclude','off','XLimInclude','off')
    
    # as the cube of the stepsize, i.e., in loglog scale, the error
    # should have a slope of 3.
    window_len=10
# checkhessian.m:106
    range_,poly=identify_linear_piece(log10(h),log10(err),window_len,nargout=2)
# checkhessian.m:107
    hold('all')
    loglog(h[range_],10.0 ** polyval(poly,log10(h[range_])),'LineWidth',3)
    hold('off')
    fprintf('The slope should be 3. It appears to be: %g.\\n',poly[1])
    fprintf(cat('If it is far from 3, then directional derivatives or ','the Hessian might be erroneous.\\n'))
    fprintf(cat('Note: if the exponential map is only approximate, and it ','is not a second-order approximation,\\nthen it is normal ','for the slope test to reach 2 instead of 3. Check the ','factory for this.\\n','If tested at a critical point, then even for a first-order ','retraction the slope test should yield 3.\\n'))
    
    if isfield(problem.M,'tangent'):
        hess=getHessian(problem,x,d,storedb,xkey)
# checkhessian.m:125
        phess=problem.M.tangent(x,hess)
# checkhessian.m:126
        residual=problem.M.lincomb(x,1,hess,- 1,phess)
# checkhessian.m:127
        err=problem.M.norm(x,residual)
# checkhessian.m:128
        fprintf('The residual should be zero, or very close. ')
        fprintf('Residual: %g.\\n',err)
        fprintf(cat('If it is far from 0, then the Hessian is not in the ','tangent plane.\\n'))
    else:
        fprintf(cat('Unfortunately, Manopt was unable to verify that the ','Hessian is indeed a tangent vector.\\nPlease verify ','this manually.'))
    
    
    ## Check that the Hessian at x is symmetric.
    d1=problem.M.randvec(x)
# checkhessian.m:140
    d2=problem.M.randvec(x)
# checkhessian.m:141
    h1=getHessian(problem,x,d1,storedb,xkey)
# checkhessian.m:142
    h2=getHessian(problem,x,d2,storedb,xkey)
# checkhessian.m:143
    v1=problem.M.inner(x,d1,h2)
# checkhessian.m:144
    v2=problem.M.inner(x,h1,d2)
# checkhessian.m:145
    value=v1 - v2
# checkhessian.m:146
    fprintf(cat('<d1, H[d2]> - <H[d1], d2> should be zero, or very close.','\\n\\tValue: %g - %g = %g.\\n'),v1,v2,value)
    fprintf('If it is far from 0, then the Hessian is not symmetric.\\n')
    return
    
if __name__ == '__main__':
    pass
    