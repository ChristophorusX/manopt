# Autogenerated with SMOP 
from smop.core import *
# identify_linear_piece.m

    
@function
def identify_linear_piece(x=None,y=None,window_length=None,*args,**kwargs):
    varargin = identify_linear_piece.varargin
    nargin = identify_linear_piece.nargin

    # Identify a segment of the curve (x, y) that appears to be linear.
    
    # function [range poly] = identify_linear_piece(x, y, window_length)
    
    # This function attempts to identify a contiguous segment of the curve
# defined by the vectors x and y that appears to be linear. A line is fit
# through the data over all windows of length window_length and the best
# fit is retained. The output specifies the range of indices such that
# x(range) is the portion over which (x, y) is the most linear and the
# output poly specifies a first order polynomial that best fits (x, y) over
# that range, following the usual matlab convention for polynomials
# (highest degree coefficients first).
    
    # See also: checkdiff checkgradient checkhessian
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, July 8, 2013.
# Contributors: 
# Change log:
    
    residues=zeros(length(x) - window_length,1)
# identify_linear_piece.m:22
    polys=zeros(2,length(residues))
# identify_linear_piece.m:23
    for i in arange(1,length(residues)).reshape(-1):
        range_=arange(i,(i + window_length))
# identify_linear_piece.m:25
        poly,meta=polyfit(x[range_],y[range_],1,nargout=2)
# identify_linear_piece.m:26
        residues[i]=meta.normr
# identify_linear_piece.m:27
        polys[:,i]=poly.T
# identify_linear_piece.m:28
    
    unused,best=min(residues,nargout=2)
# identify_linear_piece.m:30
    
    range_=arange(best,(best + window_length))
# identify_linear_piece.m:31
    poly=polys[:,best].T
# identify_linear_piece.m:32
    return range_,poly
    
if __name__ == '__main__':
    pass
    