# Autogenerated with SMOP 
from smop.core import *
# surfprofile.m

    
@function
def surfprofile(problem=None,x=None,d1=None,d2=None,t1=None,t2=None,*args,**kwargs):
    varargin = surfprofile.varargin
    nargin = surfprofile.nargin

    # Plot the cost function as a surface over a 2-dimensional subspace.
    
    # function surfprofile(problem, x, d1, d2, t1, t2)
# function costs = surfprofile(problem, x, d1, d2, t1, t2)
    
    # Evaluates the cost function at points
    
    #   gamma(t1, t2) = exponential_x(t1*d1 + t2*d2)
# 
# where the exponential map at x is specified by problem.M.exp (retr is
# used instead if needed). d1 and d2 are two tangent vectors to problem.M
# at the point x. The values assigned to t1 and t2 are as specified in the
# two input vectors t1 and t2.
# 
# If the function is called with an output, the plot is not drawn and the
# values of the cost are returned in a matrix of size
# length(t1)*length(t2). To plot a surf, call surf(t1, t2, costs.') (notice
# the transpose).
    
    # If x is omitted, a point is generated at random. If d1 is omitted, a
# random tangent vector at x is generated. If d2 is omitted, a random
# tangent vector at x is generated, orthogonally to d1. If t1, t2 are
# omitted, they are generated with linspace's in [-1, 1].
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Sep. 1, 2014.
# Contributors: 
# Change log:
    
    #   April 3, 2015 (NB):
#       Works with the new StoreDB class system.
    
    #   Nov. 12, 2016 (NB):
#       Most inputs are now optional.
    
    # Verify that the problem description is sufficient.
    if logical_not(canGetCost(problem)):
        error('It seems no cost was provided.')
    
    
    if logical_not(exist('x','var')) or isempty(x):
        x=problem.M.rand()
# surfprofile.m:44
        if (exist('d1','var') and logical_not(isempty(d1))) or (exist('d2','var') and logical_not(isempty(d2))):
            error('If x is omitted, d1, d2 should not be specified.')
    
    if logical_not(exist('d1','var')) or isempty(d1):
        d1=problem.M.randvec(x)
# surfprofile.m:51
    
    if logical_not(exist('d2','var')) or isempty(d2):
        d2=problem.M.randvec(x)
# surfprofile.m:54
        coeff=problem.M.inner(x,d1,d2) / problem.M.inner(x,d1,d1)
# surfprofile.m:56
        d2=problem.M.lincomb(x,1,d2,- coeff,d1)
# surfprofile.m:57
    
    if logical_not(exist('t1','var')) or isempty(t1):
        t1=linspace(- 1,1,51)
# surfprofile.m:60
    
    if logical_not(exist('t2','var')) or isempty(t2):
        t2=linspace(- 1,1,51)
# surfprofile.m:63
    
    
    
    if isfield(problem.M,'exp'):
        expo=problem.M.exp
# surfprofile.m:68
        str='Exp'
# surfprofile.m:69
    else:
        expo=problem.M.retr
# surfprofile.m:71
        str='Retr'
# surfprofile.m:72
    
    
    storedb=StoreDB()
# surfprofile.m:75
    linesearch_fun=lambda ta=None,tb=None: getCost(problem,expo[x,problem.M.lincomb(x,ta,d1,tb,d2)],storedb)
# surfprofile.m:76
    costs=zeros(length(t1),length(t2))
# surfprofile.m:80
    for i in arange(1,length(t1)).reshape(-1):
        for j in arange(1,length(t2)).reshape(-1):
            costs[i,j]=linesearch_fun[t1[i],t2[j]]
# surfprofile.m:83
    
    
    if nargout == 0:
        surf(t1,t2,costs.T)
        xlabel('t1')
        ylabel('t2')
        zlabel(cat('f(',str,'_x(t1*d1+t2*d2))'))
    
    
    return costs
    
if __name__ == '__main__':
    pass
    