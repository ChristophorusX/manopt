# Autogenerated with SMOP 
from smop.core import *
# powermanifold.m

    
@function
def powermanifold(M=None,n=None,*args,**kwargs):
    varargin = powermanifold.varargin
    nargin = powermanifold.nargin

    # Returns a structure describing a power manifold M^n = M x M x ... x M.
    
    # function Mn = powermanifold(M, n)
    
    # Input: a manifold structure M and an integer n >= 1.
# 
# Output: a manifold structure Mn representing M x ... x M (n copies of M)
# with the metric of M extended element-wise. Points and vectors are stored
# as cells of size nx1.
    
    # This code is for prototyping uses. The structures returned are often
# inefficient representations of power manifolds owing to their use of
# for-loops, but they should allow to rapidly try out an idea.
    
    # Example (an inefficient representation of the oblique manifold (3, 10)):
# Mn = powermanifold(spherefactory(3), 10)
# disp(Mn.name());
# x = Mn.rand()
    
    # See also: productmanifold
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Dec. 30, 2012.
# Contributors: 
# Change log:
#   NB, July 4, 2013: Added support for vec, mat, tangent.
#                     Added support for egrad2rgrad and ehess2rhess.
    
    
    assert_(n >= 1,'n must be an integer larger than or equal to 1.')
    Mn.name = copy(lambda : sprintf('[%s]^%d',M.name(),n))
# powermanifold.m:33
    Mn.dim = copy(lambda : dot(n,M.dim()))
# powermanifold.m:35
    Mn.inner = copy(inner)
# powermanifold.m:37
    
@function
def inner(x=None,u=None,v=None,*args,**kwargs):
    varargin = inner.varargin
    nargin = inner.nargin

    val=0
# powermanifold.m:39
    for i in arange(1,n).reshape(-1):
        val=val + M.inner(x[i],u[i],v[i])
# powermanifold.m:41
    
    return val
    
if __name__ == '__main__':
    pass
    
    Mn.norm = copy(lambda x=None,d=None: sqrt(Mn.inner(x,d,d)))
# powermanifold.m:45
    Mn.dist = copy(dist)
# powermanifold.m:47
    
@function
def dist(x=None,y=None,*args,**kwargs):
    varargin = dist.varargin
    nargin = dist.nargin

    sqd=0
# powermanifold.m:49
    for i in arange(1,n).reshape(-1):
        sqd=sqd + M.dist(x[i],y[i]) ** 2
# powermanifold.m:51
    
    d=sqrt(sqd)
# powermanifold.m:53
    return d
    
if __name__ == '__main__':
    pass
    
    Mn.typicaldist = copy(typicaldist)
# powermanifold.m:56
    
@function
def typicaldist(*args,**kwargs):
    varargin = typicaldist.varargin
    nargin = typicaldist.nargin

    sqd=0
# powermanifold.m:58
    for i in arange(1,n).reshape(-1):
        sqd=sqd + M.typicaldist() ** 2
# powermanifold.m:60
    
    d=sqrt(sqd)
# powermanifold.m:62
    return d
    
if __name__ == '__main__':
    pass
    
    
    Mn.proj = copy(proj)
# powermanifold.m:65
    
@function
def proj(x=None,u=None,*args,**kwargs):
    varargin = proj.varargin
    nargin = proj.nargin

    for i in arange(1,n).reshape(-1):
        u[i]=M.proj(x[i],u[i])
# powermanifold.m:68
    
    return u
    
if __name__ == '__main__':
    pass
    
    
    Mn.tangent = copy(tangent)
# powermanifold.m:72
    
@function
def tangent(x=None,u=None,*args,**kwargs):
    varargin = tangent.varargin
    nargin = tangent.nargin

    for i in arange(1,n).reshape(-1):
        u[i]=M.tangent(x[i],u[i])
# powermanifold.m:75
    
    return u
    
if __name__ == '__main__':
    pass
    
    
    if isfield(M,'tangent2ambient'):
        Mn.tangent2ambient = copy(tangent2ambient)
# powermanifold.m:80
    else:
        Mn.tangent2ambient = copy(lambda x=None,u=None: u)
# powermanifold.m:82
    
    
@function
def tangent2ambient(x=None,u=None,*args,**kwargs):
    varargin = tangent2ambient.varargin
    nargin = tangent2ambient.nargin

    for i in arange(1,n).reshape(-1):
        u[i]=M.tangent2ambient(x[i],u[i])
# powermanifold.m:86
    
    return u
    
if __name__ == '__main__':
    pass
    
    
    Mn.egrad2rgrad = copy(egrad2rgrad)
# powermanifold.m:90
    
@function
def egrad2rgrad(x=None,g=None,*args,**kwargs):
    varargin = egrad2rgrad.varargin
    nargin = egrad2rgrad.nargin

    for i in arange(1,n).reshape(-1):
        g[i]=M.egrad2rgrad(x[i],g[i])
# powermanifold.m:93
    
    return g
    
if __name__ == '__main__':
    pass
    
    
    Mn.ehess2rhess = copy(ehess2rhess)
# powermanifold.m:97
    
@function
def ehess2rhess(x=None,eg=None,eh=None,h=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    for i in arange(1,n).reshape(-1):
        h[i]=M.ehess2rhess(x[i],eg[i],eh[i],h[i])
# powermanifold.m:100
    
    return h
    
if __name__ == '__main__':
    pass
    
    
    Mn.exp = copy(expo)
# powermanifold.m:104
    
@function
def expo(x=None,u=None,t=None,*args,**kwargs):
    varargin = expo.varargin
    nargin = expo.nargin

    if nargin < 3:
        t=1.0
# powermanifold.m:107
    
    for i in arange(1,n).reshape(-1):
        x[i]=M.exp(x[i],u[i],t)
# powermanifold.m:110
    
    return x
    
if __name__ == '__main__':
    pass
    
    
    Mn.retr = copy(retr)
# powermanifold.m:114
    
@function
def retr(x=None,u=None,t=None,*args,**kwargs):
    varargin = retr.varargin
    nargin = retr.nargin

    if nargin < 3:
        t=1.0
# powermanifold.m:117
    
    for i in arange(1,n).reshape(-1):
        x[i]=M.retr(x[i],u[i],t)
# powermanifold.m:120
    
    return x
    
if __name__ == '__main__':
    pass
    
    
    if isfield(M,'log'):
        Mn.log = copy(loga)
# powermanifold.m:125
    
    
@function
def loga(x=None,y=None,*args,**kwargs):
    varargin = loga.varargin
    nargin = loga.nargin

    u=cell(n,1)
# powermanifold.m:128
    for i in arange(1,n).reshape(-1):
        u[i]=M.log(x[i],y[i])
# powermanifold.m:130
    
    return u
    
if __name__ == '__main__':
    pass
    
    
    Mn.hash = copy(hash)
# powermanifold.m:134
    
@function
def hash(x=None,*args,**kwargs):
    varargin = hash.varargin
    nargin = hash.nargin

    str=''
# powermanifold.m:136
    for i in arange(1,n).reshape(-1):
        str=matlabarray(cat(str,M.hash(x[i])))
# powermanifold.m:138
    
    str=matlabarray(cat('z',hashmd5(str)))
# powermanifold.m:140
    return str
    
if __name__ == '__main__':
    pass
    
    Mn.lincomb = copy(lincomb)
# powermanifold.m:143
    
@function
def lincomb(x=None,a1=None,u1=None,a2=None,u2=None,*args,**kwargs):
    varargin = lincomb.varargin
    nargin = lincomb.nargin

    if nargin == 3:
        for i in arange(1,n).reshape(-1):
            x[i]=M.lincomb(x[i],a1,u1[i])
# powermanifold.m:147
    else:
        if nargin == 5:
            for i in arange(1,n).reshape(-1):
                x[i]=M.lincomb(x[i],a1,u1[i],a2,u2[i])
# powermanifold.m:151
        else:
            error('Bad usage of powermanifold.lincomb')
    
    return x
    
if __name__ == '__main__':
    pass
    
    Mn.rand = copy(rand)
# powermanifold.m:158
    
@function
def rand(*args,**kwargs):
    varargin = rand.varargin
    nargin = rand.nargin

    x=cell(n,1)
# powermanifold.m:160
    for i in arange(1,n).reshape(-1):
        x[i]=M.rand()
# powermanifold.m:162
    
    return x
    
if __name__ == '__main__':
    pass
    
    Mn.randvec = copy(randvec)
# powermanifold.m:166
    
@function
def randvec(x=None,*args,**kwargs):
    varargin = randvec.varargin
    nargin = randvec.nargin

    u=cell(n,1)
# powermanifold.m:168
    for i in arange(1,n).reshape(-1):
        u[i]=M.randvec(x[i])
# powermanifold.m:170
    
    u=Mn.lincomb(x,1 / sqrt(n),u)
# powermanifold.m:172
    return u
    
if __name__ == '__main__':
    pass
    
    Mn.zerovec = copy(zerovec)
# powermanifold.m:175
    
@function
def zerovec(x=None,*args,**kwargs):
    varargin = zerovec.varargin
    nargin = zerovec.nargin

    u=cell(n,1)
# powermanifold.m:177
    for i in arange(1,n).reshape(-1):
        u[i]=M.zerovec(x[i])
# powermanifold.m:179
    
    return u
    
if __name__ == '__main__':
    pass
    
    if isfield(M,'transp'):
        Mn.transp = copy(transp)
# powermanifold.m:184
    
    
@function
def transp(x1=None,x2=None,u=None,*args,**kwargs):
    varargin = transp.varargin
    nargin = transp.nargin

    for i in arange(1,n).reshape(-1):
        u[i]=M.transp(x1[i],x2[i],u[i])
# powermanifold.m:188
    
    return u
    
if __name__ == '__main__':
    pass
    
    if isfield(M,'pairmean'):
        Mn.pairmean = copy(pairmean)
# powermanifold.m:193
    
    
@function
def pairmean(x1=None,x2=None,*args,**kwargs):
    varargin = pairmean.varargin
    nargin = pairmean.nargin

    y=cell(n,1)
# powermanifold.m:196
    for i in arange(1,n).reshape(-1):
        y[i]=M.pairmean(x1[i],x2[i])
# powermanifold.m:198
    
    return y
    
if __name__ == '__main__':
    pass
    
    # Compute the length of a vectorized tangent vector of M at x, assuming
    # this length is independent of the point x (that should be fine).
    if isfield(M,'vec'):
        rand_x=M.rand()
# powermanifold.m:205
        zero_u=M.zerovec(rand_x)
# powermanifold.m:206
        len_vec=length(M.vec(rand_x,zero_u))
# powermanifold.m:207
        Mn.vec = copy(vec)
# powermanifold.m:209
        if isfield(M,'mat'):
            Mn.mat = copy(mat)
# powermanifold.m:212
    
    
    
@function
def vec(x=None,u_mat=None,*args,**kwargs):
    varargin = vec.varargin
    nargin = vec.nargin

    u_vec=zeros(len_vec,n)
# powermanifold.m:218
    for i in arange(1,n).reshape(-1):
        u_vec[:,i]=M.vec(x[i],u_mat[i])
# powermanifold.m:220
    
    u_vec=ravel(u_vec)
# powermanifold.m:222
    return u_vec
    
if __name__ == '__main__':
    pass
    
    
@function
def mat(x=None,u_vec=None,*args,**kwargs):
    varargin = mat.varargin
    nargin = mat.nargin

    u_mat=cell(n,1)
# powermanifold.m:226
    u_vec=reshape(u_vec,len_vec,n)
# powermanifold.m:227
    for i in arange(1,n).reshape(-1):
        u_mat[i]=M.mat(x[i],u_vec[:,i])
# powermanifold.m:229
    
    return u_mat
    
if __name__ == '__main__':
    pass
    
    if isfield(M,'vecmatareisometries'):
        Mn.vecmatareisometries = copy(M.vecmatareisometries)
# powermanifold.m:234
    else:
        Mn.vecmatareisometries = copy(lambda : false)
# powermanifold.m:236
    
    return u_mat
    
if __name__ == '__main__':
    pass
    