# Autogenerated with SMOP 
from smop.core import *
# hessianmatrix.m

    
@function
def hessianmatrix(problem=None,x=None,basis=None,*args,**kwargs):
    varargin = hessianmatrix.varargin
    nargin = hessianmatrix.nargin

    # Computes a matrix which represents the Hessian in some tangent basis.
    
    # [H, basis] = hessianmatrix(problem, x)
# [H, basis] = hessianmatrix(problem, x, basis)
    
    # problem is a Manopt problem structure with a manifold and cost function.
# x is a point on the manifold problem.M.
# basis (optional) is an orthonormal basis for the tangent space to the
# manifold at x. If no basis is supplied, one will be generated at random.
# If the basis spans only a subspace of the tangent space at x,
# then the returned matrix represents the Hessian restricted to that subspace.
    
    # H is an n-by-n symmetric matrix (with n the number of vectors in the basis)
# such that H(i, j) is the inner product between basis{i}
# and Hess(basis{j}), with respect to the metric on the tangent space to
# problem.M at x, where Hess(basis{j}) is the vector obtained after
# applying the Hessian at x to basis{j}.
    
    # For optimization, it is usually not useful to compute the Hessian matrix,
# as this quickly becomes expensive. This tool is provided mostly for
# exploration and debugging rather than to be used algorithmically in
# solvers. To access the spectrum of the Hessian, it may be more practical
# to call hessianextreme or hessianspectrum. This should coincide with eig(H).
    
    # See also: hessianspectrum hessianextreme tangentorthobasis orthogonalize
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, July 14, 2016.
# Contributors: 
# Change log:
    
    # Unless an orthonormal basis for the tangent space at x is provided,
    # pick a random one.
    if logical_not(exist('basis','var')) or isempty(basis):
        n=problem.M.dim()
# hessianmatrix.m:37
        basis=tangentorthobasis(problem.M,x,n)
# hessianmatrix.m:38
    else:
        n=numel(basis)
# hessianmatrix.m:40
    
    
    # Create a store database and get a key for x
    storedb=StoreDB(1)
# hessianmatrix.m:44
    key=storedb.getNewKey()
# hessianmatrix.m:45
    
    Hbasis=cell(n,1)
# hessianmatrix.m:48
    for k in arange(1,numel(Hbasis)).reshape(-1):
        Hbasis[k]=getHessian(problem,x,basis[k],storedb,key)
# hessianmatrix.m:50
    
    
    # H is the matrix which contains the inner products of
    # the ((basis vectors)) with the ((Hessian applied to basis vectors)).
    H=zeros(n)
# hessianmatrix.m:55
    for i in arange(1,n).reshape(-1):
        H[i,i]=problem.M.inner(x,basis[i],Hbasis[i])
# hessianmatrix.m:57
        for j in arange((i + 1),n).reshape(-1):
            H[i,j]=problem.M.inner(x,basis[i],Hbasis[j])
# hessianmatrix.m:59
            H[j,i]=H[i,j]
# hessianmatrix.m:60
    
    return H,basis
    
if __name__ == '__main__':
    pass
    