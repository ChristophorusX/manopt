# Autogenerated with SMOP 
from smop.core import *
# orthogonalize.m

    
@function
def orthogonalize(M=None,x=None,basis=None,*args,**kwargs):
    varargin = orthogonalize.varargin
    nargin = orthogonalize.nargin

    # Orthonormalizes a basis of tangent vectors in the Manopt framework.
    
    # function [orthobasis, L] = orthogonalize(M, x, basis)
    
    # M is a Manopt manifold structure obtained from a factory.
# x is a point on the manifold M.
# basis is a cell containing n linearly independent tangent vectors at x.
    
    # orthobasis is a cell of same size as basis which contains an orthonormal
# basis for the same subspace as that spanned by basis. Orthonormality is
# assessed with respect to the metric on the tangent space to M at x.
# L is upper triangular of size n x n if basis has n vectors, such that,
# basis{k} = sum_j=1^k orthobasis{j} * L(j, k) (akin to R in a QR
# factorization.)
    
    # See also: grammatrix tangentorthobasis
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, April 28, 2016.
# Contributors: 
# Change log:
    
    n=numel(basis)
# orthogonalize.m:25
    orthobasis=cell(size(basis))
# orthogonalize.m:26
    
    G=grammatrix(M,x,basis)
# orthogonalize.m:29
    
    # product were the classical dot product, then G = V'*V. We are looking
    # for R, an invertible matrix such that V*R is orthogonal. Thus, R
    # satisfies R'*V'*V*R = eye(n); equivalently:
    #  G = inv(R)'*inv(R).
    # Computing a Cholesky factorization of G yields L such that G = L'*L.
    # Thus, R = inv(L). Each column of R states exactly which linear
    # combinations of the vectors in 'basis' must be computed to produce
    # the orthonormal basis.
    
    # Of course, in that formalism, we could directly take a qr of V, but
    # in the actual setting V is not available; the only simple object
    # available is G.
    
    # If this simple code turns out not to be satisfactory (most likely
	# because of numerical instability), it may be good to consider
	# implementing a modified Gram-Schmidt algorithm instead, and even to
	# provide a helper function which calls it twice.
    L=chol(G)
# orthogonalize.m:49
    R=inv(L)
# orthogonalize.m:50
    
    # We now compute the n linear combinations.
    
    for k in arange(1,n).reshape(-1):
        orthobasis[k]=lincomb(M,x,basis[1:k],R[1:k,k])
# orthogonalize.m:57
    
    return orthobasis,L
    
if __name__ == '__main__':
    pass
    