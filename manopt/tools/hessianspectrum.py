# Autogenerated with SMOP 
from smop.core import *
# hessianspectrum.m

    
@function
def hessianspectrum(problem=None,x=None,usepreconstr=None,storedb=None,key=None,*args,**kwargs):
    varargin = hessianspectrum.varargin
    nargin = hessianspectrum.nargin

    # Returns the eigenvalues of the (preconditioned) Hessian at x.
# 
# function lambdas = hessianspectrum(problem, x)
# function lambdas = hessianspectrum(problem, x, useprecon)
# function lambdas = hessianspectrum(problem, x, useprecon, storedb)
# function lambdas = hessianspectrum(problem, x, useprecon, storedb, key)
    
    # If useprecon is not set, or if it is set to 'noprecon' (default), this
# computes and returns the eigenvalues of the Hessian operator (which needs
# to be symmetric but not necessarily definite) on the tangent space at x.
# There are problem.M.dim() eigenvalues. Matlab's eigs is used internally.
    
    # If useprecon is set to 'precon', the eigenvalues of the composition of
# the Hessian with the preconditioner at x are computed: Precon o Hessian.
# The preconditioner must have been defined in the problem structure and
# has to be symmetric, positive definite. It is supposed to approximate the
# inverse of the (Riemannian) Hessian. Ideally, the preconditioned Hessian
# is better conditioned (smaller ratio of largest to smallest eigenvalue in
# magnitude) than the non-preconditioned spectrum. The present tool can
# help assess that.
    
    # The typical ways to define a preconditioner are via problem.precon or
# problem.sqrtprecon (see comment below). These should be function handles
# with the same input/output system as problem.hess for the Hessian.
    
    # If the Hessian is not available from the problem structure, an
# approximate Hessian will be used. There are no guarantees of
# interpretability, but this may nevertheless be useful at times.
    
    # Even though the Hessian and the preconditioner are both symmetric, their
# composition is not symmetric. This can slow down the call to 'eigs'
# substantially. If possible, you may specify the square root of the
# preconditioner in the problem structure, as sqrtprecon. This operator on
# the tangent space at x must also be symmetric, positive definite, and
# such that SqrtPrecon o SqrtPrecon = Precon. Then, the spectrum of the
# symmetric operator SqrtPrecon o Hessian o SqrtPrecon is computed: it is
# the same as the spectrum of Precon o Hessian, but is usually faster to
# compute. If both Precon and SqrtPrecon are provided, only SqrtPrecon will
# be used.
    
    # The input and the output of the Hessian and of the preconditioner are
# projected on the tangent space to avoid undesired contributions of the
# ambient space.
    
    # storedb is a StoreDB object, key is the StoreDB key to point x.
    
    # Requires the manifold description in problem.M to have these functions:
# 
#   u_vec = vec(x, u_mat) :
#       Returns a column vector representation of the normal (usually
#       matrix) representation of the tangent vector u_mat. vec must be an
#       isometry between the tangent space (with its Riemannian metric) and
#       a subspace of R^n where n = length(u_vec), with the 2-norm on R^n.
#       In other words: it is an orthogonal projector.
    
    #   u_mat = mat(x, u_vec) :
#       The inverse of vec (its adjoint).
    
    #   u_mat_clean = tangent(x, u_mat) :
#       Subtracts from the tangent vector u_mat any component that would
#       make it "not really tangent", by projection.
    
    #   answer = vecmatareisometries() :
#       Returns true if the linear maps encoded by vec and mat are
#       isometries, false otherwise. It is better if the answer is yes.
    
    # See also: hessianextreme canGetPrecon canGetSqrtPrecon
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, July 3, 2013.
# Contributors: 
# Change log:
    
    #   Dec. 18, 2014 (NB):
#       The lambdas are now sorted when they are returned.
    
    #   April 3, 2015 (NB):
#       Works with the new StoreDB class system.
#       Does no longer accept sqrtprecon as an input: the square root of
#       the preconditioner may now be specified directly in the problem
#       structure, following the same syntax as the preconditioner precon.
    
    #   April 4, 2015 (NB):
#       By default, the spectrum is computed without the preconditioner's
#       effect, even if it is available. A new input option allows to
#       switch this behavior without the need to change the problem
#       structure.
    
    # Allow omission of the key, and even of storedb.
    if logical_not(exist('key','var')):
        if logical_not(exist('storedb','var')):
            storedb=StoreDB()
# hessianspectrum.m:93
        key=storedb.getNewKey()
# hessianspectrum.m:95
    
    # Manage the option to use or not use a preconditioner.
    # The input is a string. It is here transformed into a Boolean.
    if logical_not(exist('usepreconstr','var')) or isempty(usepreconstr):
        usepreconstr='noprecon'
# hessianspectrum.m:101
    
    if 'noprecon' == lower(usepreconstr):
        useprecon=copy(false)
# hessianspectrum.m:105
    else:
        if 'precon' == lower(usepreconstr):
            useprecon=copy(true)
# hessianspectrum.m:107
        else:
            # A bit of legacy code heads up.
            if isa(usepreconstr,'function_handle'):
                warning('manopt:hessianspectrum:oldsyntax',cat('This function no longer expects sqrtprecon ','as input. Place it in the problem structure.'))
            error('Input useprecon must be either \'precon\' or \'noprecon\'.')
    
    if logical_not(canGetHessian(problem)):
        warning('manopt:hessianspectrum:nohessian',cat('The Hessian appears to be unavailable.\\n','Will try to use an approximate Hessian instead.\\n','Since this approximation may not be linear or ','symmetric,\\nthe computation might fail and the ','results (if any)\\nmight make no sense.'))
    
    vec=lambda u_mat=None: problem.M.vec(x,u_mat)
# hessianspectrum.m:127
    mat=lambda u_vec=None: problem.M.mat(x,u_vec)
# hessianspectrum.m:128
    tgt=lambda u_mat=None: problem.M.tangent(x,u_mat)
# hessianspectrum.m:129
    
    # dim: dimension of the tangent space
    # necessarily, n >= dim.
    # The vectorized operators we build below will have at least n - dim
    # zero eigenvalues.
    n=length(vec[problem.M.zerovec(x)])
# hessianspectrum.m:136
    dim=problem.M.dim()
# hessianspectrum.m:137
    
    # sure precomputable things are precomputed.
    if canGetGradient(problem):
        unused1,unused2=getCostGrad(problem,x,storedb,key,nargout=2)
# hessianspectrum.m:142
    
    
    hess=lambda u_mat=None: tgt[getHessian(problem,x,tgt[u_mat],storedb,key)]
# hessianspectrum.m:145
    hess_vec=lambda u_vec=None: vec[hess[mat[u_vec]]]
# hessianspectrum.m:146
    
    # eigenvalue problem if the vec/mat pair of the manifold is an
    # isometry:
    vec_mat_are_isometries=problem.M.vecmatareisometries()
# hessianspectrum.m:151
    if logical_not(useprecon):
        # No preconditioner to use: simply use the Hessian as is.
        eigs_opts.issym = copy(vec_mat_are_isometries)
# hessianspectrum.m:158
        eigs_opts.isreal = copy(true)
# hessianspectrum.m:159
        lambdas=eigs(hess_vec,n,dim,'LM',eigs_opts)
# hessianspectrum.m:160
    else:
        if canGetSqrtPrecon(problem):
            # There is a preconditioner, and we have its square root: deal with
        # the symmetric composition SqrtPrecon o Hessian o SqrtPrecon.
            sqrtprec=lambda u_mat=None: tgt[getSqrtPrecon(problem,x,tgt[u_mat],storedb,key)]
# hessianspectrum.m:167
            sqrtprec_vec=lambda u_vec=None: vec[sqrtprec[mat[u_vec]]]
# hessianspectrum.m:168
            eigs_opts.issym = copy(vec_mat_are_isometries)
# hessianspectrum.m:170
            eigs_opts.isreal = copy(true)
# hessianspectrum.m:171
            lambdas=eigs(lambda u_vec=None: sqrtprec_vec[hess_vec[sqrtprec_vec[u_vec]]],n,dim,'LM',eigs_opts)
# hessianspectrum.m:172
        else:
            if canGetPrecon(problem):
                # There is a preconditioner, but we don't have its square root:
        # deal with the non-symmetric composition Precon o Hessian.
                prec=lambda u_mat=None: tgt[getPrecon(problem,x,tgt[u_mat],storedb,key)]
# hessianspectrum.m:181
                prec_vec=lambda u_vec=None: vec[prec[mat[u_vec]]]
# hessianspectrum.m:182
                eigs_opts.issym = copy(false)
# hessianspectrum.m:185
                eigs_opts.isreal = copy(true)
# hessianspectrum.m:186
                lambdas=eigs(lambda u_vec=None: prec_vec[hess_vec[u_vec]],n,dim,'LM',eigs_opts)
# hessianspectrum.m:187
            else:
                error('No preconditioner is available in the problem structure.')
    
    
    lambdas=sort(lambdas)
# hessianspectrum.m:196
    return lambdas
    
if __name__ == '__main__':
    pass
    