# Autogenerated with SMOP 
from smop.core import *
# tangentspherefactory.m

    
@function
def tangentspherefactory(M=None,x=None,*args,**kwargs):
    varargin = tangentspherefactory.varargin
    nargin = tangentspherefactory.nargin

    # Returns a manifold struct. for the sphere on the tangent space to M at x.
    
    # N = tangentspherefactory(M, x)
    
    # N defines a manifold that is the unit sphere on the tangent space to M
# at x. Points are represented as tangent vectors of unit norm. Tangent
# vectors are represented as tangent vectors orthogonal to the root point,
# with respect to the Riemannian metric on the tangent space.
    
    # This is chiefly useful to solve optimization problems involving unit norm
# tangent vectors to M at x, which notably comes up when looking for
# extreme eigenvectors of the Hessian of a cost function on M at x, for
# example. The Riemannian structure on this sphere is that of a Riemannian
# submanifold of the (Euclidean) tangent space, equipped with the
# Riemannian metric of M at that point.
    
    # See also: hessianextreme
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, March 16, 2015.
# Contributors: 
# Change log:
    
    #   Nov 27, 2015 (NB):
#       Extra projection added in the retraction, to prevent numerical
#       drift.
    
    # N is the manifold we build. y will be a point on N, thus also a
    # tangent vector to M at x. This is a typical Riemannian submanifold of
    # a Euclidean space, hence it will be easy to describe in terms of the
    # tools available for M.
    N=struct()
# tangentspherefactory.m:33
    
    # N at y is a subspace of the tangent space to M at x, thus u, u1 and
    # u2 are also tangent vectors to M at x.
    
    N.dim = copy(lambda : M.dim() - 1)
# tangentspherefactory.m:39
    N.inner = copy(lambda y=None,u1=None,u2=None: M.inner(x,u1,u2))
# tangentspherefactory.m:40
    N.norm = copy(lambda y=None,u=None: M.norm(x,u))
# tangentspherefactory.m:41
    N.proj = copy(lambda y=None,v=None: M.lincomb(x,1,v,- M.inner(x,v,y),y))
# tangentspherefactory.m:42
    N.typicaldist = copy(lambda : 1)
# tangentspherefactory.m:43
    N.tangent = copy(N.proj)
# tangentspherefactory.m:44
    N.egrad2rgrad = copy(N.proj)
# tangentspherefactory.m:45
    N.retr = copy(retraction)
# tangentspherefactory.m:46
    N.exp = copy(N.retr)
# tangentspherefactory.m:47
    
@function
def retraction(y=None,u=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin == 2:
        t=1
# tangentspherefactory.m:50
    
    y_plus_tu=M.lincomb(x,1,y,t,u)
# tangentspherefactory.m:52
    
    # but appears to be necessary numerically, sometimes.
        # The reason is that, as many retractions are operated,
        # there is a risk that the points generated would leave
        # the tangent space. If this proves to be a huge slow down,
        # one could consider adding a type of counter that only
        # executes this extra projection every so often, instead
        # of at every call.
    y_plus_tu=M.proj(x,y_plus_tu)
# tangentspherefactory.m:61
    nrm=M.norm(x,y_plus_tu)
# tangentspherefactory.m:62
    yy=M.lincomb(x,1 / nrm,y_plus_tu)
# tangentspherefactory.m:63
    return yy
    
if __name__ == '__main__':
    pass
    
    N.rand = copy(random)
# tangentspherefactory.m:65
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    y=M.randvec(x)
# tangentspherefactory.m:67
    nrm=M.norm(x,y)
# tangentspherefactory.m:68
    y=M.lincomb(x,1 / nrm,y)
# tangentspherefactory.m:69
    return y
    
if __name__ == '__main__':
    pass
    
    N.randvec = copy(randvec)
# tangentspherefactory.m:71
    
@function
def randvec(y=None,*args,**kwargs):
    varargin = randvec.varargin
    nargin = randvec.nargin

    u=N.proj(y,N.rand())
# tangentspherefactory.m:73
    nrm=N.norm(y,u)
# tangentspherefactory.m:74
    u=M.lincomb(x,1 / nrm,u)
# tangentspherefactory.m:75
    return u
    
if __name__ == '__main__':
    pass
    
    N.zerovec = copy(M.zerovec)
# tangentspherefactory.m:77
    N.lincomb = copy(M.lincomb)
# tangentspherefactory.m:78
    N.transp = copy(lambda y1=None,y2=None,u=None: N.proj(y2,u))
# tangentspherefactory.m:79
    N.hash = copy(lambda y=None: cat('z',hashmd5(M.vec(x,y))))
# tangentspherefactory.m:80
    return u
    
if __name__ == '__main__':
    pass
    