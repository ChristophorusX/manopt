# Autogenerated with SMOP 
from smop.core import *
# multiprod.m

    
@function
def multiprod(a=None,b=None,idA=None,idB=None,*args,**kwargs):
    varargin = multiprod.varargin
    nargin = multiprod.nargin

    # Multiplying 1-D or 2-D subarrays contained in two N-D arrays.
# 
#   C = MULTIPROD(A,B) is equivalent  to C = MULTIPROD(A,B,[1 2],[1 2])
#   C = MULTIPROD(A,B,[D1 D2]) is eq. to C = MULTIPROD(A,B,[D1 D2],[D1 D2])
#   C = MULTIPROD(A,B,D1) is equival. to C = MULTIPROD(A,B,D1,D1)
    
    #   MULTIPROD performs multiple matrix products, with array expansion (AX)
#   enabled. Its first two arguments A and B are "block arrays" of any
#   size, containing one or more 1-D or 2-D subarrays, called "blocks" (*).
#   For instance, a 5x6x3 array may be viewed as an array containing five
#   6x3 blocks. In this case, its size is denoted by 5x(6x3). The 1 or 2
#   adjacent dimensions along which the blocks are contained are called the
#   "internal dimensions" (IDs) of the array ().
    
    #   1) 2-D by 2-D BLOCK(S) (*)
#         C = MULTIPROD(A, B, [DA1 DA2], [DB1 DB2]) contains the products
#         of the PxQ matrices in A by the RxS matrices in B. [DA1 DA2] are
#         the IDs of A; [DB1 DB2] are the IDs of B.
    
    #   2) 2-D by 1-D BLOCK(S) (*)
#         C = MULTIPROD(A, B, [DA1 DA2], DB1) contains the products of the
#         PxQ matrices in A by the R-element vectors in B. The latter are
#         considered to be Rx1 matrices. [DA1 DA2] are the IDs of A; DB1 is
#         the ID of B.
    
    #   3) 1-D by 2-D BLOCK(S) (*)
#         C = MULTIPROD(A, B, DA1, [DB1 DB2]) contains the products of the 
#         Q-element vectors in A by the RxS matrices in B. The vectors in A
#         are considered to be 1xQ matrices. DA1 is the ID of A; [DB1 DB2]
#         are the IDs of B.
    
    #   4) 1-D BY 1-D BLOCK(S) (*)
#      (a) If either SIZE(A, DA1) == 1 or SIZE(B, DB1) == 1, or both,
#             C = MULTIPROD(A, B, DA1, DB1) returns products of scalars by 
#             vectors, or vectors by scalars or scalars by scalars.
#      (b) If SIZE(A, DA1) == SIZE(B, DB1), 
#             C = MULTIPROD(A, B, [0 DA1], [DB1 0]) or 
#             C = MULTIPROD(A, B, DA1, DB1) virtually turns the vectors
#             contained in A and B into 1xP and Px1 matrices, respectively,
#             then returns their products, similar to scalar products.
#             Namely, C = DOT2(A, B, DA1, DB1) is equivalent to 
#             C = MULTIPROD(CONJ(A), B, [0 DA1], [DB1 0]).
#      (c) Without limitations on the length of the vectors in A and B,
#             C = MULTIPROD(A, B, [DA1 0], [0 DB1]) turns the vectors
#             contained in A and B into Px1 and 1xQ matrices, respectively,
#             then returns their products, similar to outer products.
#             Namely, C = OUTER(A, B, DA1, DB1) is equivalent to
#             C = MULTIPROD(CONJ(A), B, [DA1 0], [0 DB1]).
    
    #   Common constraints for all syntaxes:
#      The external dimensions of A and B must either be identical or 
#      compatible with AX rules. The internal dimensions of each block
#      array must be adjacent (DA2 == DA1 + 1 and DB2 == DB1 + 1 are
#      required). DA1 and DB1 are allowed to be larger than NDIMS(A) and
#      NDIMS(B). In syntaxes 1, 2, and 3, Q == R is required, unless the
#      blocks in A or B are scalars.
    
    #   Array expansion (AX):
#      AX is a powerful generalization to N-D of the concept of scalar
#      expansion. Indeed, A and B may be scalars, vectors, matrices or
#      multi-dimensional arrays. Scalar expansion is the virtual
#      replication or annihilation of a scalar which allows you to combine
#      it, element by element, with an array X of any size (e.g. X+10,
#      X*10, or []-10). Similarly, in MULTIPROD, the purpose of AX is to
#      automatically match the size of the external dimensions (EDs) of A
#      and B, so that block-by-block products can be performed. ED matching
#      is achieved by means of a dimension shift followed by a singleton
#      expansion:
#      1) Dimension shift (see SHIFTDIM).
#            Whenever DA1 ~= DB1, a shift is applied to impose DA1 == DB1.
#            If DA1 > DB1, B is shifted to the right by DA1 - DB1 steps.
#            If DB1 > DA1, A is shifted to the right by DB1 - DA1 steps.
#      2) Singleton expansion (SX).
#            Whenever an ED of either A or B is singleton and the
#            corresponding ED of the other array is not, the mismatch is
#            fixed by virtually replicating the array (or diminishing it to
#            length 0) along that dimension.
# 
#   MULTIPROD is a generalization for N-D arrays of the matrix
#   multiplication function MTIMES, with AX enabled. Vector inner, outer,
#   and cross products generalized for N-D arrays and with AX enabled are
#   performed by DOT2, OUTER, and CROSS2 (MATLAB Central, file #8782).
#   Elementwise multiplications (see TIMES) and other elementwise binary
#   operations with AX enabled are performed by BAXFUN (MATLAB Central,
#   file #23084). Together, these functions make up the "ARRAYLAB toolbox".
    
    #   Input and output format:
#      The size of the EDs of C is determined by AX. Block size is
#      determined as follows, for each of the above-listed syntaxes:
#      1) C contains PxS matrices along IDs MAX([DA1 DA2], [DB1 DB2]).
#      2) Array     Block size     ID(s)
#         ----------------------------------------------------
#         A         PxQ  (2-D)     [DA1 DA2]
#         B         R    (1-D)     DB1
#         C (a)     P    (1-D)     MAX(DA1, DB1)
#         C (b)     PxQ  (2-D)     MAX([DA1 DA2], [DB1 DB1+1])
#         ----------------------------------------------------
#         (a) The 1-D blocks in B are not scalars (R > 1).
#         (b) The 1-D blocks in B are scalars (R = 1).
#      3) Array     Block size     ID(s)
#         ----------------------------------------------------
#         A           Q  (1-D)     DA1
#         B         RxS  (2-D)     [DB1 DB2]
#         C (a)       S  (1-D)     MAX(DA1, DB1)
#         C (b)     RxS  (2-D)     MAX([DA1 DA1+1], [DB1 DB2])
#         ----------------------------------------------------
#         (a) The 1-D blocks in A are not scalars (Q > 1).
#         (b) The 1-D blocks in A are scalars (Q = 1).
#      4)     Array     Block size         ID(s)
#         --------------------------------------------------------------
#         (a) A         P        (1-D)     DA1
#             B         Q        (1-D)     DB1
#             C         MAX(P,Q) (1-D)     MAX(DA1, DB1)
#         --------------------------------------------------------------
#         (b) A         P        (1-D)     DA1
#             B         P        (1-D)     DB1
#             C         1        (1-D)     MAX(DA1, DB1)
#         --------------------------------------------------------------
#         (c) A         P        (1-D)     DA1
#             B         Q        (1-D)     DB1
#             C         PxQ      (2-D)     MAX([DA1 DA1+1], [DB1 DB1+1])
#         --------------------------------------------------------------
    
    #   Terminological notes:
#   (*) 1-D and 2-D blocks are generically referred to as "vectors" and 
#       "matrices", respectively. However, both may be also called
#       "scalars" if they have a single element. Moreover, matrices with a
#       single row or column (e.g. 1x3 or 3x1) may be also called "row
#       vectors" or "column vectors".
#   () Not to be confused with the "inner dimensions" of the two matrices
#       involved in a product X * Y, defined as the 2nd dimension of X and
#       the 1st of Y (DA2 and DB1 in syntaxes 1, 2, 3).
    
    #   Examples:
#    1) If  A is .................... a 5x(6x3)x2 array,
#       and B is .................... a 5x(3x4)x2 array,
#       C = MULTIPROD(A, B, [2 3]) is a 5x(6x4)x2 array.
    
    #       A single matrix A pre-multiplies each matrix in B
#       If  A is ........................... a (1x3)    single matrix,
#       and B is ........................... a 10x(3x4) 3-D array,
#       C = MULTIPROD(A, B, [1 2], [3 4]) is a 10x(1x4) 3-D array.
    
    #       Each matrix in A pre-multiplies each matrix in B (all possible
#       combinations)
#       If  A is .................... a (6x3)x5   array,
#       and B is .................... a (3x4)x1x2 array,
#       C = MULTIPROD(A, B, [1 2]) is a (6x4)x5x2 array.
    
    #   2a) If  A is ........................... a 5x(6x3)x2 4-D array,
#       and B is ........................... a 5x(3)x2   3-D array,
#       C = MULTIPROD(A, B, [2 3], [2]) is   a 5x(6)x2   3-D array.
    
    #   2b) If  A is ........................... a 5x(6x3)x2 4-D array,
#       and B is ........................... a 5x(1)x2   3-D array,
#       C = MULTIPROD(A, B, [2 3], [2]) is   a 5x(6x3)x2 4-D array.
    
    #   4a) If both A and B are .................. 5x(6)x2   3-D arrays,
#       C = MULTIPROD(A, B, 2) is .......... a 5x(1)x2   3-D array, while
#   4b) C = MULTIPROD(A, B, [2 0], [0 2]) is a 5x(6x6)x2 4-D array
    
    #   See also DOT2, OUTER, CROSS2, BAXFUN, MULTITRANSP, MULTITRACE, MULTISCALE.
    
    # $ Version: 2.1 $
# CODE      by:            Paolo de Leva
#                          (Univ. of Rome, Foro Italico, IT)    2009 Jan 24
#           optimized by:  Paolo de Leva
#                          Jinhui Bai (Georgetown Univ., D.C.)  2009 Jan 24
# COMMENTS  by:            Paolo de Leva                        2009 Feb 24
# OUTPUT    tested by:     Paolo de Leva                        2009 Feb 24
# -------------------------------------------------------------------------
    
    assert_(nargin >= 2 and nargin <= 4,'Takes from 2 to 4 inputs.')
    if 2 == nargin:
        idA=matlabarray(cat(1,2))
# multiprod.m:177
        idB=matlabarray(cat(1,2))
# multiprod.m:177
    else:
        if 3 == nargin:
            idB=copy(idA)
# multiprod.m:178
    
    # ESC 1 - Special simple case (both A and B are 2D), solved using C = A * B
    
    if ndims(a) == 2 and ndims(b) == 2 and isequal(idA,cat(1,2)) and isequal(idB,cat(1,2)):
        c=dot(a,b)
# multiprod.m:185
        return c
    
    # MAIN 0 - Checking and evaluating array size, block size, and IDs
    
    sizeA0=size(a)
# multiprod.m:190
    sizeB0=size(b)
# multiprod.m:191
    sizeA,sizeB,shiftC,delC,sizeisnew,idA,idB,squashOK,sxtimesOK,timesOK,mtimesOK,sumOK=sizeval(idA,idB,sizeA0,sizeB0,nargout=12)
# multiprod.m:193
    # MAIN 1 - Applying dimension shift (first step of AX) and 
#          turning both A and B into arrays of either 1-D or 2-D blocks
    
    if sizeisnew[1]:
        a=reshape(a,sizeA)
# multiprod.m:199
    
    if sizeisnew[2]:
        b=reshape(b,sizeB)
# multiprod.m:200
    
    # MAIN 2 - Performing products with or without SX (second step of AX)
    
    if squashOK:
        c=squash2D_mtimes(a,b,idA,idB,sizeA,sizeB,squashOK)
# multiprod.m:205
    else:
        if timesOK:
            if sumOK:
                c=sum(multiply(a,b),sumOK)
# multiprod.m:207
            else:
                c=multiply(a,b)
# multiprod.m:208
        else:
            if sxtimesOK:
                if sumOK:
                    c=sum(bsxfun(times,a,b),sumOK)
# multiprod.m:210
                else:
                    c=bsxfun(times,a,b)
# multiprod.m:211
            else:
                if mtimesOK:
                    c=dot(a,b)
# multiprod.m:213
    
    # MAIN 3 - Reshaping C (by inserting or removing singleton dimensions)
    
    sizeC,sizeCisnew=adjustsize(size(c),shiftC,false,delC,false,nargout=2)
# multiprod.m:218
    if sizeCisnew:
        c=reshape(c,sizeC)
# multiprod.m:219
    
    
@function
def squash2D_mtimes(a=None,b=None,idA=None,idB=None,sizeA=None,sizeB=None,squashOK=None,*args,**kwargs):
    varargin = squash2D_mtimes.varargin
    nargin = squash2D_mtimes.nargin

    # SQUASH2D_MTIMES  Multiproduct with single-block expansion (SBX).
#    Actually, no expansion is performed. The multi-block array is
#    rearranged from N-D to 2-D, then MTIMES is applied, and eventually the
#    result is rearranged back to N-D. No additional memory is required.
#    One and only one of the two arrays must be single-block, and its IDs
#    must be [1 2] (MAIN 1 removes leading singletons). Both arrays
#    must contain 2-D blocks (MAIN 1 expands 1-D blocks to 2-D).
    
    if squashOK == 1:
        # STEP 1 - Moving IDA(2) to last dimension
        nd=length(sizeA)
# multiprod.m:234
        d2=idA[2]
# multiprod.m:235
        order=matlabarray(cat(arange(1,(d2 - 1)),arange((d2 + 1),nd),d2))
# multiprod.m:236
        a=permute(a,order)
# multiprod.m:237
        # STEP 2 - Squashing A from N-D to 2-D
        q=sizeB[1]
# multiprod.m:240
        s=sizeB[2]
# multiprod.m:241
        lengthorder=length(order)
# multiprod.m:242
        collapsedsize=sizeA[order[1:lengthorder - 1]]
# multiprod.m:243
        n=prod(collapsedsize)
# multiprod.m:244
        a=reshape(a,cat(n,q))
# multiprod.m:245
        fullsize=matlabarray(cat(collapsedsize,s))
# multiprod.m:246
    else:
        # STEP 1 - Moving IDB(1) to first dimension
        nd=length(sizeB)
# multiprod.m:251
        d1=idB[1]
# multiprod.m:252
        order=matlabarray(cat(d1,arange(1,(d1 - 1)),arange((d1 + 1),nd)))
# multiprod.m:253
        b=permute(b,order)
# multiprod.m:254
        # STEP 2 - Squashing B from N-D to 2-D
        p=sizeA[1]
# multiprod.m:257
        q=sizeA[2]
# multiprod.m:258
        lengthorder=length(order)
# multiprod.m:259
        collapsedsize=sizeB[order[2:lengthorder]]
# multiprod.m:260
        n=prod(collapsedsize)
# multiprod.m:261
        b=reshape(b,cat(q,n))
# multiprod.m:262
        fullsize=matlabarray(cat(p,collapsedsize))
# multiprod.m:263
    
    # FINAL STEPS - Multiplication, reshape to N-D, inverse permutation
    invorder[order]=arange(1,lengthorder)
# multiprod.m:268
    c=permute(reshape(dot(a,b),fullsize),invorder)
# multiprod.m:269
    
@function
def sizeval(idA0=None,idB0=None,sizeA0=None,sizeB0=None,*args,**kwargs):
    varargin = sizeval.varargin
    nargin = sizeval.nargin

    #SIZEVAL   Evaluation of array size, block size, and IDs
#    Possible values for IDA and IDB:
#        [DA1 DA2], [DB1 DB2]
#        [DA1 DA2], [DB1]
#        [DA1],     [DB1 DB2]
#        [DA1],     [DB1]
#        [DA1 0],   [0 DB1]
#        [0 DA1],   [DB1 0]
    
    #    sizeA/B     Equal to sizeA0/B0 if RESHAPE is not needed in MAIN 1
#    shiftC, delC    Variables controlling MAIN 3.
#    sizeisnew   1x2 logical array; activates reshaping of A and B.
#    idA/B       May change only if squashOK ~= 0
#    squashOK    If only A or B is a multi-block array (M-B) and the other
#                is single-block (1-B), it will be rearranged from N-D to
#                2-D. If both A and B are 1-B or M-B arrays, squashOK = 0.
#                If only A (or B) is a M-B array, squashOK = 1 (or 2).
#    sxtimesOK, timesOK, mtimesOK    Flags controlling MAIN 2 (TRUE/FALSE).
#    sumOK       Dimension along which SUM is performed. If SUM is not
#                needed, sumOK = 0.
    
    # Initializing output arguments
    
    idA=copy(idA0)
# multiprod.m:298
    idB=copy(idB0)
# multiprod.m:299
    squashOK=0
# multiprod.m:300
    sxtimesOK=copy(false)
# multiprod.m:301
    timesOK=copy(false)
# multiprod.m:302
    mtimesOK=copy(false)
# multiprod.m:303
    sumOK=0
# multiprod.m:304
    shiftC=0
# multiprod.m:305
    delC=0
# multiprod.m:306
    # Checking for gross input errors
    
    NidA=numel(idA)
# multiprod.m:310
    NidB=numel(idB)
# multiprod.m:311
    idA1=idA[1]
# multiprod.m:312
    idB1=idB[1]
# multiprod.m:313
    if NidA > 2 or NidB > 2 or NidA == 0 or NidB == 0 or logical_not(isreal(idA1)) or logical_not(isreal(idB1)) or logical_not(isnumeric(idA1)) or logical_not(isnumeric(idB1)) or 0 > idA1 or 0 > idB1 or idA1 != fix(idA1) or idB1 != fix(idB1) or logical_not(isfinite(idA1)) or logical_not(isfinite(idB1)):
        error('MULTIPROD:InvalidDimensionArgument',cat('Internal-dimension arguments (e.g., [IDA1 IDA2]) must\\n','contain only one or two non-negative finite integers'))
    
    # Checking Syntaxes containing zeros (4b/c)
    
    declared_outer=copy(false)
# multiprod.m:327
    idA2=idA[NidA]
# multiprod.m:328
    
    idB2=idB[NidB]
# multiprod.m:329
    if any(idA == 0) or any(idB == 0):
        # "Inner products": C = MULTIPROD(A, B, [0 DA1], [DB1 0])
        if idA1 == 0 and idA2 > 0 and idB1 > 0 and idB2 == 0:
            idA1=copy(idA2)
# multiprod.m:335
            idB2=copy(idB1)
# multiprod.m:336
        else:
            if idA1 > 0 and idA2 == 0 and idB1 == 0 and idB2 > 0:
                declared_outer=copy(true)
# multiprod.m:339
                idA2=copy(idA1)
# multiprod.m:340
                idB1=copy(idB2)
# multiprod.m:341
            else:
                error('MULTIPROD:InvalidDimensionArgument',cat('Misused zeros in the internal-dimension arguments\\n','(see help heads 4b and 4c)'))
        NidA=1
# multiprod.m:347
        NidB=1
# multiprod.m:348
        idA=copy(idA1)
# multiprod.m:349
        idB=copy(idB1)
# multiprod.m:350
    else:
        if (NidA == 2 and idA2 != idA1 + 1) or (NidB == 2 and idB2 != idB1 + 1):
            error('MULTIPROD:InvalidDimensionArgument',cat('If an array contains 2-D blocks, its two internal dimensions','must be adjacent (e.g. IDA2 == IDA1+1)'))
    
    # ESC - Case for which no reshaping is needed (both A and B are scalars)
    
    scalarA=isequal(sizeA0,cat(1,1))
# multiprod.m:361
    scalarB=isequal(sizeB0,cat(1,1))
# multiprod.m:362
    if scalarA and scalarB:
        sizeA=copy(sizeA0)
# multiprod.m:364
        sizeB=copy(sizeB0)
# multiprod.m:365
        sizeisnew=matlabarray(cat(false,false))
# multiprod.m:366
        timesOK=copy(true)
# multiprod.m:367
        return sizeA,sizeB,shiftC,delC,sizeisnew,idA,idB,squashOK,sxtimesOK,timesOK,mtimesOK,sumOK
    
    # Computing and checking adjusted sizes
# The lengths of ADJSIZEA and ADJSIZEB must be >= IDA(END) and IDB(END)
    
    NsA=idA2 - length(sizeA0)
# multiprod.m:373
    
    NsB=idB2 - length(sizeB0)
# multiprod.m:374
    adjsizeA=matlabarray(cat(sizeA0,ones(1,NsA)))
# multiprod.m:375
    adjsizeB=matlabarray(cat(sizeB0,ones(1,NsB)))
# multiprod.m:376
    extsizeA=adjsizeA[cat(arange(1,idA1 - 1),arange(idA2 + 1,end()))]
# multiprod.m:377
    
    extsizeB=adjsizeB[cat(arange(1,idB1 - 1),arange(idB2 + 1,end()))]
# multiprod.m:378
    p=adjsizeA[idA1]
# multiprod.m:379
    q=adjsizeA[idA2]
# multiprod.m:380
    r=adjsizeB[idB1]
# multiprod.m:381
    s=adjsizeB[idB2]
# multiprod.m:382
    scalarsinA=(p == 1 and q == 1)
# multiprod.m:383
    scalarsinB=(r == 1 and s == 1)
# multiprod.m:384
    singleA=all(extsizeA == 1)
# multiprod.m:385
    singleB=all(extsizeB == 1)
# multiprod.m:386
    if q != r and logical_not(scalarsinA) and logical_not(scalarsinB) and logical_not(declared_outer):
        error('MULTIPROD:InnerDimensionsMismatch','Inner matrix dimensions must agree.')
    
    # STEP 1/3 - DIMENSION SHIFTING (FIRST STEP OF AX)
#   Pipeline 1 (using TIMES) never needs left, and may need right shifting.
#   Pipeline 2 (using MTIMES) may need left shifting of A and right of B.
    
    shiftA=0
# multiprod.m:396
    shiftB=0
# multiprod.m:397
    diffBA=idB1 - idA1
# multiprod.m:398
    if scalarA:
        pass
    else:
        if singleA and logical_not(scalarsinB):
            shiftA=- idA1 + 1
# multiprod.m:400
        else:
            if idB1 > idA1:
                shiftA=copy(diffBA)
# multiprod.m:401
    
    if scalarB:
        pass
    else:
        if singleB and logical_not(scalarsinA):
            shiftB=- idB1 + 1
# multiprod.m:404
        else:
            if idA1 > idB1:
                shiftB=- diffBA
# multiprod.m:405
    
    # STEP 2/3 - SELECTION OF PROPER ENGINE AND BLOCK SIZE ADJUSTMENTS
    
    addA=0
# multiprod.m:410
    addB=0
# multiprod.m:410
    delA=0
# multiprod.m:411
    delB=0
# multiprod.m:411
    swapA=0
# multiprod.m:412
    swapB=0
# multiprod.m:412
    idC1=max(idA1,idB1)
# multiprod.m:413
    idC2=idC1 + 1
# multiprod.m:414
    checktimes=copy(false)
# multiprod.m:415
    if (singleA or singleB) and logical_not(scalarsinA) and logical_not(scalarsinB):
        if singleA and singleB:
            mtimesOK=copy(true)
# multiprod.m:420
            shiftC=idC1 - 1
# multiprod.m:421
            idC1=1
# multiprod.m:422
            idC2=2
# multiprod.m:422
        else:
            if singleA:
                squashOK=2
# multiprod.m:424
                idB=cat(idB1,idB1 + 1) + shiftB
# multiprod.m:425
            else:
                squashOK=1
# multiprod.m:427
                idA=cat(idA1,idA1 + 1) + shiftA
# multiprod.m:428
        if NidA == 2 and NidB == 2:
            # OK
            pass
        else:
            if NidA == 2:
                addB=idB1 + 1
# multiprod.m:434
                delC=copy(idC2)
# multiprod.m:434
            else:
                if NidB == 2:
                    addA=copy(idA1)
# multiprod.m:436
                    delC=copy(idC1)
# multiprod.m:436
                else:
                    if declared_outer:
                        addA=idA1 + 1
# multiprod.m:439
                        addB=copy(idB1)
# multiprod.m:439
                    else:
                        addA=copy(idA1)
# multiprod.m:441
                        addB=idB1 + 1
# multiprod.m:441
                        delC=copy(idC2)
# multiprod.m:441
    else:
        sxtimesOK=copy(true)
# multiprod.m:447
        if NidA == 2 and NidB == 2:
            if scalarA or scalarB:
                timesOK=copy(true)
# multiprod.m:452
            else:
                if scalarsinA and scalarsinB:
                    checktimes=copy(true)
# multiprod.m:454
                else:
                    if scalarsinA or scalarsinB or (q == 1 and r == 1):
                        pass
                    else:
                        if p == 1 and s == 1:
                            swapA=copy(idA1)
# multiprod.m:458
                            sumOK=copy(idC1)
# multiprod.m:458
                            checktimes=copy(true)
# multiprod.m:458
                        else:
                            if s == 1:
                                swapB=copy(idB1)
# multiprod.m:460
                                sumOK=copy(idC2)
# multiprod.m:460
                            else:
                                if p == 1:
                                    swapA=copy(idA1)
# multiprod.m:462
                                    sumOK=copy(idC1)
# multiprod.m:462
                                else:
                                    addA=idA2 + 1
# multiprod.m:464
                                    addB=copy(idB1)
# multiprod.m:464
                                    sumOK=copy(idC2)
# multiprod.m:464
                                    delC=copy(idC2)
# multiprod.m:464
        else:
            if NidA == 2:
                if scalarA or scalarB:
                    timesOK=copy(true)
# multiprod.m:470
                else:
                    if scalarsinA and scalarsinB:
                        addB=copy(idB1)
# multiprod.m:472
                        checktimes=copy(true)
# multiprod.m:472
                    else:
                        if scalarsinA:
                            delA=copy(idA1)
# multiprod.m:474
                        else:
                            if scalarsinB:
                                addB=copy(idB1)
# multiprod.m:476
                            else:
                                if p == 1:
                                    delA=copy(idA1)
# multiprod.m:478
                                    sumOK=copy(idC1)
# multiprod.m:478
                                    checktimes=copy(true)
# multiprod.m:478
                                else:
                                    addB=copy(idB1)
# multiprod.m:480
                                    sumOK=copy(idC2)
# multiprod.m:480
                                    delC=copy(idC2)
# multiprod.m:480
            else:
                if NidB == 2:
                    if scalarA or scalarB:
                        timesOK=copy(true)
# multiprod.m:486
                    else:
                        if scalarsinA and scalarsinB:
                            addA=idA1 + 1
# multiprod.m:488
                            checktimes=copy(true)
# multiprod.m:488
                        else:
                            if scalarsinB:
                                delB=copy(idB2)
# multiprod.m:490
                            else:
                                if scalarsinA:
                                    addA=idA1 + 1
# multiprod.m:492
                                else:
                                    if s == 1:
                                        delB=copy(idB2)
# multiprod.m:494
                                        sumOK=copy(idC1)
# multiprod.m:494
                                        checktimes=copy(true)
# multiprod.m:494
                                    else:
                                        addA=idA1 + 1
# multiprod.m:496
                                        sumOK=copy(idC1)
# multiprod.m:496
                                        delC=copy(idC1)
# multiprod.m:496
                else:
                    if scalarA or scalarB:
                        timesOK=copy(true)
# multiprod.m:502
                    else:
                        if declared_outer:
                            addA=idA1 + 1
# multiprod.m:504
                            addB=copy(idB1)
# multiprod.m:504
                        else:
                            if scalarsinA and scalarsinB:
                                checktimes=copy(true)
# multiprod.m:506
                            else:
                                if scalarsinA or scalarsinB:
                                    pass
                                else:
                                    sumOK=copy(idC1)
# multiprod.m:509
                                    checktimes=copy(true)
# multiprod.m:509
    
    # STEP 3/3 - Adjusting the size of A and B. The size of C is adjusted
#            later, because it is not known yet.
    
    sizeA,sizeisnew[1]=adjustsize(sizeA0,shiftA,addA,delA,swapA,nargout=2)
# multiprod.m:517
    sizeB,sizeisnew[2]=adjustsize(sizeB0,shiftB,addB,delB,swapB,nargout=2)
# multiprod.m:518
    if checktimes:
        diff=length(sizeB) - length(sizeA)
# multiprod.m:521
        if isequal(cat(sizeA,ones(1,diff)),cat(sizeB,ones(1,- diff))):
            timesOK=copy(true)
# multiprod.m:523
    
    
@function
def adjustsize(sizeA0=None,shiftA=None,addA=None,delA=None,swapA=None,*args,**kwargs):
    varargin = adjustsize.varargin
    nargin = adjustsize.nargin

    # ADJUSTSIZE  Adjusting size of a block array.
    
    # Dimension shifting (by adding or deleting trailing singleton dim.)
    if shiftA > 0:
        sizeA,newA1=addsing(sizeA0,1,shiftA,nargout=2)
# multiprod.m:532
    else:
        if shiftA < 0:
            sizeA,newA1=delsing(sizeA0,1,- shiftA,nargout=2)
# multiprod.m:533
        else:
            sizeA=copy(sizeA0)
# multiprod.m:534
            newA1=copy(false)
# multiprod.m:534
    
    # Modifying block size (by adding, deleting, or moving singleton dim.)
    if addA:
        sizeA,newA2=addsing(sizeA,addA + shiftA,1,nargout=2)
# multiprod.m:537
    else:
        if delA:
            sizeA,newA2=delsing(sizeA,delA + shiftA,1,nargout=2)
# multiprod.m:538
        else:
            if swapA:
                sizeA,newA2=swapdim(sizeA,swapA + shiftA,nargout=2)
# multiprod.m:539
            else:
                newA2=copy(false)
# multiprod.m:540
    
    sizeisnew=newA1 or newA2
# multiprod.m:542
    
@function
def addsing(size0=None,dim=None,ns=None,*args,**kwargs):
    varargin = addsing.varargin
    nargin = addsing.nargin

    #ADDSING   Adding NS singleton dimensions to the size of an array.
#   Warning: NS is assumed to be a positive integer.
#   Example: If the size of A is ..... SIZE0 = [5 9 3]
#            NEWSIZE = ADDSING(SIZE0, 3, 2) is [5 9 1 1 3]
    
    if dim > length(size0):
        newsize=copy(size0)
# multiprod.m:552
        flag=copy(false)
# multiprod.m:553
    else:
        newsize=matlabarray(cat(size0[1:dim - 1],ones(1,ns),size0[dim:end()]))
# multiprod.m:555
        flag=copy(true)
# multiprod.m:556
    
    
@function
def delsing(size0=None,dim=None,ns=None,*args,**kwargs):
    varargin = delsing.varargin
    nargin = delsing.nargin

    #DELSING   Removing NS singleton dimensions from the size of an array.
#   Warning: Trailing singletons are not removed
#   Example: If the size of A is SIZE0 = [1 1 1 5 9 3]
#            NEWSIZE = DELSING(SIZE, 1, 3) is  [5 9 3]
    
    if dim > length(size0) - ns:
        newsize=copy(size0)
# multiprod.m:567
        flag=copy(false)
# multiprod.m:568
    else:
        newsize=size0[cat(arange(1,dim - 1),arange(dim + ns,end()),dim)]
# multiprod.m:570
        flag=copy(true)
# multiprod.m:571
    
    
@function
def swapdim(size0=None,dim=None,*args,**kwargs):
    varargin = swapdim.varargin
    nargin = swapdim.nargin

    #SWAPDIM   Swapping two adjacent dimensions of an array (DIM and DIM+1).
#   Used only when both A and B are multi-block arrays with 2-D blocks.
#   Example: If the size of A is .......... 5x(6x3)
#            NEWSIZE = SWAPIDS(SIZE0, 2) is 5x(3x6)
    
    newsize=matlabarray(cat(size0,1))
# multiprod.m:581
    
    newsize=newsize[cat(arange(1,dim - 1),dim + 1,dim,arange(dim + 2,end()))]
# multiprod.m:582
    flag=copy(true)
# multiprod.m:583