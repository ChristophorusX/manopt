# Autogenerated with SMOP 
from smop.core import *
# multiscale.m

    
@function
def multiscale(scale=None,A=None,*args,**kwargs):
    varargin = multiscale.varargin
    nargin = multiscale.nargin

    # Multiplies the 2D slices in a 3D matrix by individual scalars.
    
    # function A = multiscale(scale, A)
    
    # Given a vector scale of length N and a 3-dimensional matrix A of size
# n-by-m-by-N, returns a matrix A of same size such that
# A(:, :, k) := scale(k) * A(:, :, k);
    
    # See also: multiprod multitransp multitrace
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Dec. 30, 2012.
# Contributors: 
# Change log:
    
    assert_(ndims(A) <= 3,cat('multiscale is only well defined for matrix arrays of 3 ','or less dimensions.'))
    n,m,N=size(A,nargout=3)
# multiscale.m:21
    assert_(numel(scale) == N,cat('scale must be a vector whose length equals the third ','dimension of A, that is, the number of 2D matrix slices ','in the 3D matrix A.'))
    scale=ravel(scale)
# multiscale.m:27
    A=reshape(bsxfun(times,reshape(A,dot(n,m),N),scale.T),n,m,N)
# multiscale.m:28
    return A
    
if __name__ == '__main__':
    pass
    