# Autogenerated with SMOP 
from smop.core import *
# grassmann/grassmanngeneralizedfactory.m

    
@function
def grassmanngeneralizedfactory(n=None,p=None,B=None,*args,**kwargs):
    varargin = grassmanngeneralizedfactory.varargin
    nargin = grassmanngeneralizedfactory.nargin

    # Returns a manifold struct of "scaled" vector subspaces.
    
    # function M = grassmanngeneralizedfactory(n, p)
# function M = grassmanngeneralizedfactory(n, p, B)
    
    # Generalized Grassmann manifold: each point on this manifold is a
# collection of "scaled" vector subspaces of dimension p embedded in R^n.
# The scaling is due to the symmetric positive definite matrix B.
    
    # When B is identity, the manifold is the standard Grassmann manifold.
    
    # The metric is obtained by viewing the generalized Grassmannian
# a Riemannian quotient manifold of the generalized Stiefel manifold, 
# which is the manifold of "scaled" orthonormal matrices. Specifically, 
# the scaled Stiefel manifold is the set {X : X'*B*X = I}. 
# The generalized Grassmann manifold is the Grassmannian of the 
# generalized Stiefel manifold.
    
    # The generalized Stiefel manifold is endowed with a scaled metric
# by viewing it as a Riemannian submanifold of the Euclidean space, which
# is again endowed with the scaled inner product.
    
    # Some notions (not all) are from Section 4.5 of the paper
# "The geometry of algorithms with orthogonality constraints",
# A. Edelman, T. A. Arias, S. T. Smith, SIMAX, 1998.
    
    # Paper link: http://arxiv.org/abs/physics/9806030.
    
    # 
# Note: some computations such as restricted_svd, distance, logarithm, and 
# exponential are new and we believe them to be correct.
# Also, we hope that the computations are numerically stable.
# In case some things do not work out as expected or there is some trouble,
# please contact us at http://www.manopt.org.
    
    # Note: egrad2rgrad and ehess2rhess involve solving linear systems in B. If
# this is a bottleneck for a specific application, then a way forward is to
# create a modified version of this file which preprocesses B to speed this
# up (typically, by computing a Cholesky factorization of it, then calling
# an appropriate solver).
    
    # See also: stiefelgeneralizedfactory  stiefelfactory  grassmannfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Bamdev Mishra, June 30, 2015.
# Contributors:
    
    # Change log:
#
    
    assert_(n >= p,cat('The dimension n of the ambient space must be larger ','than the dimension p of the subspaces.'))
    if logical_not(exist('B','var')) or isempty(B):
        B=speye(n)
# grassmann/grassmanngeneralizedfactory.m:58
    
    
    M.name = copy(lambda : sprintf('Generalized Grassmann manifold Gr(%d, %d)',n,p))
# grassmann/grassmanngeneralizedfactory.m:61
    M.dim = copy(lambda : dot(p,(n - p)))
# grassmann/grassmanngeneralizedfactory.m:63
    M.inner = copy(lambda X=None,eta=None,zeta=None: trace(dot(eta.T,(dot(B,zeta)))))
# grassmann/grassmanngeneralizedfactory.m:65
    
    
    M.norm = copy(lambda X=None,eta=None: sqrt(M.inner(X,eta,eta)))
# grassmann/grassmanngeneralizedfactory.m:67
    M.dist = copy(distance)
# grassmann/grassmanngeneralizedfactory.m:69
    
@function
def distance(X=None,Y=None,*args,**kwargs):
    varargin = distance.varargin
    nargin = distance.nargin

    XtBY=dot(X.T,(dot(B,Y)))
# grassmann/grassmanngeneralizedfactory.m:71
    
    cos_princ_angle=svd(XtBY)
# grassmann/grassmanngeneralizedfactory.m:72
    
    # Two next instructions not necessary: the imaginary parts that
        # would appear if the cosines are not between -1 and 1, when
        # passed to the acos function, would be very small, and would
        # thus vanish when the norm is taken.
        # cos_princ_angle = min(cos_princ_angle,  1);
        # cos_princ_angle = max(cos_princ_angle, -1);
    square_d=norm(acos(cos_princ_angle)) ** 2
# grassmann/grassmanngeneralizedfactory.m:79
    d=sqrt(square_d)
# grassmann/grassmanngeneralizedfactory.m:81
    return d
    
if __name__ == '__main__':
    pass
    
    
    M.typicaldist = copy(lambda : sqrt(p))
# grassmann/grassmanngeneralizedfactory.m:84
    
    # horizontal space at X.
    M.proj = copy(projection)
# grassmann/grassmanngeneralizedfactory.m:89
    
@function
def projection(X=None,U=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    BX=dot(B,X)
# grassmann/grassmanngeneralizedfactory.m:91
    
    # U = U - X*symm(BX'*U);
        # Projection onto the horizontal space
        # Up = U - X*skew(BX'*U);
    
    Up=U - dot(X,(dot(BX.T,U)))
# grassmann/grassmanngeneralizedfactory.m:98
    return Up
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(M.proj)
# grassmann/grassmanngeneralizedfactory.m:101
    M.egrad2rgrad = copy(egrad2rgrad)
# grassmann/grassmanngeneralizedfactory.m:103
    
@function
def egrad2rgrad(X=None,egrad=None,*args,**kwargs):
    varargin = egrad2rgrad.varargin
    nargin = egrad2rgrad.nargin

    
    # First, scale egrad according to the scaled metric in the
        # Euclidean space.
    egrad_scaled=numpy.linalg.solve(B,egrad)
# grassmann/grassmanngeneralizedfactory.m:108
    
    # No need to project onto the horizontal space as
        # by the Riemannian submersion theory, this quantity automatically
        # belongs to the horizontal space.
    
    
    # rgrad = egrad_scaled - X*symm((B*X)'*egrad_scaled);
    
    # Verify that symm(BX'*egrad_scaled) = symm(X'*egrad).
    
    rgrad=egrad_scaled - dot(X,symm(dot(X.T,egrad)))
# grassmann/grassmanngeneralizedfactory.m:120
    return rgrad
    
if __name__ == '__main__':
    pass
    
    
    
    M.ehess2rhess = copy(ehess2rhess)
# grassmann/grassmanngeneralizedfactory.m:124
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,H=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    egraddot=copy(ehess)
# grassmann/grassmanngeneralizedfactory.m:126
    Xdot=copy(H)
# grassmann/grassmanngeneralizedfactory.m:127
    
    egrad_scaleddot=numpy.linalg.solve(B,egraddot)
# grassmann/grassmanngeneralizedfactory.m:130
    rgraddot=egrad_scaleddot - dot(Xdot,symm(dot(X.T,egrad))) - dot(X,symm(dot(Xdot.T,egrad))) - dot(X,symm(dot(X.T,egraddot)))
# grassmann/grassmanngeneralizedfactory.m:131
    
    rhess=M.proj(X,rgraddot)
# grassmann/grassmanngeneralizedfactory.m:136
    return rhess
    
if __name__ == '__main__':
    pass
    
    
    
    M.retr = copy(retraction)
# grassmann/grassmanngeneralizedfactory.m:140
    
@function
def retraction(X=None,U=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# grassmann/grassmanngeneralizedfactory.m:143
    
    Y=guf(X + dot(t,U))
# grassmann/grassmanngeneralizedfactory.m:145
    
    return Y
    
if __name__ == '__main__':
    pass
    
    
    
    M.exp = copy(exponential)
# grassmann/grassmanngeneralizedfactory.m:149
    
@function
def exponential(X=None,U=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin == 3:
        tU=dot(t,U)
# grassmann/grassmanngeneralizedfactory.m:152
    else:
        tU=copy(U)
# grassmann/grassmanngeneralizedfactory.m:154
    
    
    # restricted_svd is defined later in the file.
    u,s,v=restricted_svd(tU,nargout=3)
# grassmann/grassmanngeneralizedfactory.m:158
    
    cos_s=diag(cos(diag(s)))
# grassmann/grassmanngeneralizedfactory.m:159
    sin_s=diag(sin(diag(s)))
# grassmann/grassmanngeneralizedfactory.m:160
    Y=dot(dot(dot(X,v),cos_s),v.T) + dot(dot(u,sin_s),v.T)
# grassmann/grassmanngeneralizedfactory.m:161
    
    
    # From numerical experiments, it seems necessary to
        # re-orthonormalize.
    Y=guf(Y)
# grassmann/grassmanngeneralizedfactory.m:165
    
    return Y
    
if __name__ == '__main__':
    pass
    
    
    
    
    # Test code for the logarithm:
    # gGr = grassmanngeneralizedfactory(5, 2, diag(rand(5,1)));
    # x = gGr.rand()
    # y = gGr.rand()
    # u = gGr.log(x, y)
    # gGr.dist(x, y) # These two numbers should
    # gGr.norm(x, u) # be the same.
    # z = gGr.exp(x, u) # z needs not be the same matrix as y, but it should
    # v = gGr.log(x, z) # be the same point as y on Grassmann: dist almost 0.
    # gGr.dist(z, y)
    M.log = copy(logarithm)
# grassmann/grassmanngeneralizedfactory.m:180
    
@function
def logarithm(X=None,Y=None,*args,**kwargs):
    varargin = logarithm.varargin
    nargin = logarithm.nargin

    YtBX=dot(Y.T,(dot(B,X)))
# grassmann/grassmanngeneralizedfactory.m:182
    
    At=(Y.T - dot(YtBX,X.T))
# grassmann/grassmanngeneralizedfactory.m:183
    Bt=numpy.linalg.solve(YtBX,At)
# grassmann/grassmanngeneralizedfactory.m:184
    u,s,v=restricted_svd(Bt.T,nargout=3)
# grassmann/grassmanngeneralizedfactory.m:185
    
    
    u=u[:,1:p]
# grassmann/grassmanngeneralizedfactory.m:187
    s=diag(s)
# grassmann/grassmanngeneralizedfactory.m:188
    s=s[1:p]
# grassmann/grassmanngeneralizedfactory.m:189
    v=v[:,1:p]
# grassmann/grassmanngeneralizedfactory.m:190
    U=dot(dot(u,diag(atan(s))),v.T)
# grassmann/grassmanngeneralizedfactory.m:191
    
    return U
    
if __name__ == '__main__':
    pass
    
    
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(ravel(X))))
# grassmann/grassmanngeneralizedfactory.m:195
    M.rand = copy(random)
# grassmann/grassmanngeneralizedfactory.m:197
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    X=guf(randn(n,p))
# grassmann/grassmanngeneralizedfactory.m:199
    
    return X
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# grassmann/grassmanngeneralizedfactory.m:202
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    U=projection(X,randn(n,p))
# grassmann/grassmanngeneralizedfactory.m:204
    U=U / norm(ravel(U))
# grassmann/grassmanngeneralizedfactory.m:205
    return U
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# grassmann/grassmanngeneralizedfactory.m:208
    M.zerovec = copy(lambda X=None: zeros(n,p))
# grassmann/grassmanngeneralizedfactory.m:210
    
    M.transp = copy(lambda X1=None,X2=None,d=None: projection(X2,d))
# grassmann/grassmanngeneralizedfactory.m:213
    M.vec = copy(lambda X=None,u_mat=None: ravel(u_mat))
# grassmann/grassmanngeneralizedfactory.m:215
    M.mat = copy(lambda X=None,u_vec=None: reshape(u_vec,cat(n,p)))
# grassmann/grassmanngeneralizedfactory.m:216
    M.vecmatareisometries = copy(lambda : false)
# grassmann/grassmanngeneralizedfactory.m:217
    
    symm=lambda D=None: (D + D.T) / 2
# grassmann/grassmanngeneralizedfactory.m:220
    
@function
def guf(Y=None,*args,**kwargs):
    varargin = guf.varargin
    nargin = guf.nargin

    # Generalized polar decomposition of an n-by-p matrix Y.
        # X'*B*X is identity.
    
    # Method 1
    u,__,v=svd(Y,0,nargout=3)
# grassmann/grassmanngeneralizedfactory.m:227
    
    # expensive, way is to do X = u*(sqrtm(u'*(B*u))\(v')).
    q,ssquare=eig(dot(u.T,(dot(B,u))),nargout=2)
# grassmann/grassmanngeneralizedfactory.m:231
    qsinv=q / sparse(diag(sqrt(diag(ssquare))))
# grassmann/grassmanngeneralizedfactory.m:232
    X=dot(u,(dot((dot(qsinv,q.T)),v.T)))
# grassmann/grassmanngeneralizedfactory.m:233
    
    
    
    # Another computation using restricted_svd
        # [u, ~, v] = restricted_svd(Y);
        # X = u*v'; # X'*B*X is identity.
    
    return X
    
if __name__ == '__main__':
    pass
    
    
    
@function
def restricted_svd(Y=None,*args,**kwargs):
    varargin = restricted_svd.varargin
    nargin = restricted_svd.nargin

    # We compute a thin svd-like decomposition of an n-by-p matrix Y 
        # into matrices u, s, and v such that u is an n-by-p matrix
        # with u'*B*u being identity, s is a p-by-p diagonal matrix 
        # with positive entries, and v is a p-by-p orthogonal matrix.
        # Y = u*s*v'.
    
    v,ssquare=eig(symm[dot(Y.T,(dot(B,Y)))],nargout=2)
# grassmann/grassmanngeneralizedfactory.m:249
    
    ssquarevec=diag(ssquare)
# grassmann/grassmanngeneralizedfactory.m:250
    s=sparse(diag(abs(sqrt(ssquarevec))))
# grassmann/grassmanngeneralizedfactory.m:252
    u=dot(Y,(v / s))
# grassmann/grassmanngeneralizedfactory.m:253
    
    return u,s,v
    
if __name__ == '__main__':
    pass
    
    
    return u,s,v
    
if __name__ == '__main__':
    pass
    