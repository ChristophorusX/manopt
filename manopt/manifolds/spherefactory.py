# Autogenerated with SMOP 
from smop.core import *
# sphere/spherefactory.m

    
@function
def spherefactory(n=None,m=None,*args,**kwargs):
    varargin = spherefactory.varargin
    nargin = spherefactory.nargin

    # Returns a manifold struct to optimize over unit-norm vectors or matrices.
    
    # function M = spherefactory(n)
# function M = spherefactory(n, m)
    
    # Manifold of n-by-m real matrices of unit Frobenius norm.
# By default, m = 1, which corresponds to the unit sphere in R^n. The
# metric is such that the sphere is a Riemannian submanifold of the space
# of nxm matrices with the usual trace inner product, i.e., the usual
# metric.
# 
# See also: obliquefactory spherecomplexfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Dec. 30, 2012.
# Contributors: 
# Change log:
    
    #   Oct. 8, 2016 (NB)
#       Code for exponential was simplified to only treat the zero vector
#       as a particular case.
    
    #   Oct. 22, 2016 (NB)
#       Distance function dist now significantly more accurate for points
#       within 1e-7 and less from each other.
    
    
    if logical_not(exist('m','var')):
        m=1
# sphere/spherefactory.m:30
    
    if m == 1:
        M.name = copy(lambda : sprintf('Sphere S^%d',n - 1))
# sphere/spherefactory.m:34
    else:
        M.name = copy(lambda : sprintf('Unit F-norm %dx%d matrices',n,m))
# sphere/spherefactory.m:36
    
    
    M.dim = copy(lambda : dot(n,m) - 1)
# sphere/spherefactory.m:39
    M.inner = copy(lambda x=None,d1=None,d2=None: dot(ravel(d1).T,ravel(d2)))
# sphere/spherefactory.m:41
    M.norm = copy(lambda x=None,d=None: norm(d,'fro'))
# sphere/spherefactory.m:43
    M.dist = copy(dist)
# sphere/spherefactory.m:45
    
@function
def dist(x=None,y=None,*args,**kwargs):
    varargin = dist.varargin
    nargin = dist.nargin

    
    # This computation cannot be accurate below an output of 2e-8.
        # The reason is: if two unit-norm vectors x and y are very close to
        # one another, their inner product is about 1. The machine
        # precision at 1 is eps(1) = 2e-16. The correct value for
        # acos(1-eps(1)) is about 2e-8. This can be checked with the
        # syms toolbox: syms x; f = acos(1-x); vpa(subs(f, x, eps(1)), 32)
        # Thus, if x and y are actually closer to each other than 2e-8,
        # their inner product will be even closer to 1, but that cannot be
        # represented in IEEE arithmetic. Thus, their inner product will be
        # rounded to either 1 (giving 0 distance) or to 1-eps(1), which
        # gives a distance of 2e-8, or to something even further from 1. No
        # distance between 0 and 2e-8 can thus be computed this way.
    d=real(acos(dot(ravel(x).T,ravel(y))))
# sphere/spherefactory.m:60
    
    # possible that we suffered from round-off, we compute the distance
        # in the embedding space instead. At this scale, this is quite
        # accurate.
    if d < 1e-07:
        d=norm(x - y,'fro')
# sphere/spherefactory.m:67
    
    return d
    
if __name__ == '__main__':
    pass
    
    
    M.typicaldist = copy(lambda : pi)
# sphere/spherefactory.m:71
    M.proj = copy(lambda x=None,d=None: d - dot(x,(dot(ravel(x).T,ravel(d)))))
# sphere/spherefactory.m:73
    M.tangent = copy(M.proj)
# sphere/spherefactory.m:75
    
    # Riemannian gradient amounts to an orthogonal projection.
    M.egrad2rgrad = copy(M.proj)
# sphere/spherefactory.m:79
    M.ehess2rhess = copy(ehess2rhess)
# sphere/spherefactory.m:81
    
@function
def ehess2rhess(x=None,egrad=None,ehess=None,u=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    rhess=M.proj(x,ehess) - dot((dot(ravel(x).T,ravel(egrad))),u)
# sphere/spherefactory.m:83
    return rhess
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# sphere/spherefactory.m:86
    M.retr = copy(retraction)
# sphere/spherefactory.m:88
    M.log = copy(logarithm)
# sphere/spherefactory.m:90
    
@function
def logarithm(x1=None,x2=None,*args,**kwargs):
    varargin = logarithm.varargin
    nargin = logarithm.nargin

    v=M.proj(x1,x2 - x1)
# sphere/spherefactory.m:92
    di=M.dist(x1,x2)
# sphere/spherefactory.m:93
    
    if di > 1e-06:
        nv=norm(v,'fro')
# sphere/spherefactory.m:96
        v=dot(v,(di / nv))
# sphere/spherefactory.m:97
    
    return v
    
if __name__ == '__main__':
    pass
    
    
    M.hash = copy(lambda x=None: cat('z',hashmd5(ravel(x))))
# sphere/spherefactory.m:101
    M.rand = copy(lambda : random(n,m))
# sphere/spherefactory.m:103
    M.randvec = copy(lambda x=None: randomvec(n,m,x))
# sphere/spherefactory.m:105
    M.lincomb = copy(matrixlincomb)
# sphere/spherefactory.m:107
    M.zerovec = copy(lambda x=None: zeros(n,m))
# sphere/spherefactory.m:109
    M.transp = copy(lambda x1=None,x2=None,d=None: M.proj(x2,d))
# sphere/spherefactory.m:111
    M.pairmean = copy(pairmean)
# sphere/spherefactory.m:113
    
@function
def pairmean(x1=None,x2=None,*args,**kwargs):
    varargin = pairmean.varargin
    nargin = pairmean.nargin

    y=x1 + x2
# sphere/spherefactory.m:115
    y=y / norm(y,'fro')
# sphere/spherefactory.m:116
    return y
    
if __name__ == '__main__':
    pass
    
    M.vec = copy(lambda x=None,u_mat=None: ravel(u_mat))
# sphere/spherefactory.m:119
    M.mat = copy(lambda x=None,u_vec=None: reshape(u_vec,cat(n,m)))
# sphere/spherefactory.m:120
    M.vecmatareisometries = copy(lambda : true)
# sphere/spherefactory.m:121
    return y
    
if __name__ == '__main__':
    pass
    
    # Exponential on the sphere
    
@function
def exponential(x=None,d=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin == 2:
        # t = 1
        td=copy(d)
# sphere/spherefactory.m:130
    else:
        td=dot(t,d)
# sphere/spherefactory.m:132
    
    
    nrm_td=norm(td,'fro')
# sphere/spherefactory.m:135
    
    # small a, but further investigations suggest this computation is
    # well-behaved numerically.
    if nrm_td > 0:
        y=dot(x,cos(nrm_td)) + dot(td,(sin(nrm_td) / nrm_td))
# sphere/spherefactory.m:141
    else:
        y=copy(x)
# sphere/spherefactory.m:143
    
    return y
    
if __name__ == '__main__':
    pass
    
    # Retraction on the sphere
    
@function
def retraction(x=None,d=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin == 2:
        # t = 1;
        td=copy(d)
# sphere/spherefactory.m:153
    else:
        td=dot(t,d)
# sphere/spherefactory.m:155
    
    
    y=x + td
# sphere/spherefactory.m:158
    y=y / norm(y,'fro')
# sphere/spherefactory.m:159
    return y
    
if __name__ == '__main__':
    pass
    
    # Uniform random sampling on the sphere.
    
@function
def random(n=None,m=None,*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    x=randn(n,m)
# sphere/spherefactory.m:166
    x=x / norm(x,'fro')
# sphere/spherefactory.m:167
    return x
    
if __name__ == '__main__':
    pass
    
    # Random normalized tangent vector at x.
    
@function
def randomvec(n=None,m=None,x=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    d=randn(n,m)
# sphere/spherefactory.m:174
    d=d - dot(x,(dot(ravel(x).T,ravel(d))))
# sphere/spherefactory.m:175
    d=d / norm(d,'fro')
# sphere/spherefactory.m:176
    return d
    
if __name__ == '__main__':
    pass
    