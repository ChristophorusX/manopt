# Autogenerated with SMOP 
from smop.core import *
# fixedrank/fixedrankfactory_2factors.m

    
@function
def fixedrankfactory_2factors(m=None,n=None,k=None,*args,**kwargs):
    varargin = fixedrankfactory_2factors.varargin
    nargin = fixedrankfactory_2factors.nargin

    # Manifold of m-by-n matrices of rank k with balanced quotient geometry.
    
    # function M = fixedrankfactory_2factors(m, n, k)
    
    # The first-order geometry follows the balanced quotient geometry described 
# in the paper, 
# "Linear regression under fixed-rank constraints: a Riemannian approach",
# G. Meyer, S. Bonnabel and R. Sepulchre, ICML 2011.
    
    # Paper link: http://www.icml-2011.org/papers/350_icmlpaper.pdf.
    
    # The second-order geometry follows from the paper
# "Fixed-rank matrix factorizations and Riemannian low-rank optimization",
# B. Mishra, R. Meyer, S. Bonnabel and R. Sepulchre,
# Computational Statistics, 29(3 - 4), pp. 591 - 621, 2014.
    
    # A point X on the manifold is represented as a structure with two
# fields: L and R. The matrices L (mxk) and R (nxk) are full column-rank
# matrices such that X = L*R'.
    
    # Tangent vectors are represented as a structure with two fields: L, R.
# 
# For first-order geometry, please cite the Manopt paper as well as the research paper:
#     @InProceedings{meyer2011linear,
#       Title        = {Linear regression under fixed-rank constraints: a {R}iemannian approach},
#       Author       = {Meyer, G. and Bonnabel, S. and Sepulchre, R.},
#       Booktitle    = {{28th International Conference on Machine Learning}},
#       Year         = {2011},
#       Organization = {{ICML}}
#     }
    
    # For second-order geometry, please cite the Manopt paper as well as the research paper:
#     @Article{mishra2014fixedrank,
#       Title   = {Fixed-rank matrix factorizations and {Riemannian} low-rank optimization},
#       Author  = {Mishra, B. and Meyer, G. and Bonnabel, S. and Sepulchre, R.},
#       Journal = {Computational Statistics},
#       Year    = {2014},
#       Number  = {3-4},
#       Pages   = {591--621},
#       Volume  = {29},
#       Doi     = {10.1007/s00180-013-0464-z}
#     }
    
    
    # See also fixedrankembeddedfactory fixedrankfactory_3factors fixedrankfactory_2factors_preconditioned
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Bamdev Mishra, Dec. 30, 2012.
# Contributors:
# Change log:
    
    #   July 10, 2013 (NB):
#       Added vec, mat, tangent, tangent2ambient.
    
    #	July 03, 2015 (BM):
#      Cosmetic changes including avoiding storing the inverse of a
#       k-by-k matrix.
    
    
    M.name = copy(lambda : sprintf('LR\' quotient manifold of %dx%d matrices of rank %d',m,n,k))
# fixedrank/fixedrankfactory_2factors.m:61
    M.dim = copy(lambda : dot((m + n - k),k))
# fixedrank/fixedrankfactory_2factors.m:63
    
    # (and pretty much everywhere else).
    
@function
def prepare(X=None,*args,**kwargs):
    varargin = prepare.varargin
    nargin = prepare.nargin

    if logical_not(all(isfield(X,cellarray(['LtL','RtR'])))):
        L=X.L
# fixedrank/fixedrankfactory_2factors.m:69
        R=X.R
# fixedrank/fixedrankfactory_2factors.m:70
        X.LtL = copy(dot(L.T,L))
# fixedrank/fixedrankfactory_2factors.m:71
        X.RtR = copy(dot(R.T,R))
# fixedrank/fixedrankfactory_2factors.m:72
    
    return X
    
if __name__ == '__main__':
    pass
    
    
    # Choice of the metric is motivated by the symmetry present in the
    # space. The metric is the natural Grassmannian metric on L and R.
    M.inner = copy(iproduct)
# fixedrank/fixedrankfactory_2factors.m:78
    
@function
def iproduct(X=None,eta=None,zeta=None,*args,**kwargs):
    varargin = iproduct.varargin
    nargin = iproduct.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_2factors.m:80
    ip=trace(numpy.linalg.solve(X.LtL,(dot(eta.L.T,zeta.L)))) + trace(numpy.linalg.solve(X.RtR,(dot(eta.R.T,zeta.R))))
# fixedrank/fixedrankfactory_2factors.m:81
    return ip
    
if __name__ == '__main__':
    pass
    
    
    M.norm = copy(lambda X=None,eta=None: sqrt(M.inner(X,eta,eta)))
# fixedrank/fixedrankfactory_2factors.m:84
    M.dist = copy(lambda x=None,y=None: error('fixedrankfactory_2factors.dist not implemented yet.'))
# fixedrank/fixedrankfactory_2factors.m:86
    M.typicaldist = copy(lambda : dot(10,k))
# fixedrank/fixedrankfactory_2factors.m:88
    symm=lambda M=None: dot(0.5,(M + M.T))
# fixedrank/fixedrankfactory_2factors.m:90
    M.egrad2rgrad = copy(egrad2rgrad)
# fixedrank/fixedrankfactory_2factors.m:92
    
@function
def egrad2rgrad(X=None,egrad=None,*args,**kwargs):
    varargin = egrad2rgrad.varargin
    nargin = egrad2rgrad.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_2factors.m:94
    rgrad.L = copy(dot(egrad.L,X.LtL))
# fixedrank/fixedrankfactory_2factors.m:95
    rgrad.R = copy(dot(egrad.R,X.RtR))
# fixedrank/fixedrankfactory_2factors.m:96
    return rgrad
    
if __name__ == '__main__':
    pass
    
    
    M.ehess2rhess = copy(ehess2rhess)
# fixedrank/fixedrankfactory_2factors.m:99
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,eta=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_2factors.m:101
    
    rgrad=egrad2rgrad(X,egrad)
# fixedrank/fixedrankfactory_2factors.m:104
    
    Hess.L = copy(dot(ehess.L,X.LtL) + dot(dot(2,egrad.L),symm[dot(eta.L.T,X.L)]))
# fixedrank/fixedrankfactory_2factors.m:107
    Hess.R = copy(dot(ehess.R,X.RtR) + dot(dot(2,egrad.R),symm[dot(eta.R.T,X.R)]))
# fixedrank/fixedrankfactory_2factors.m:108
    
    Hess.L = copy(Hess.L - dot(rgrad.L,(numpy.linalg.solve(X.LtL,(symm[dot(X.L.T,eta.L)])))) - dot(eta.L,(numpy.linalg.solve(X.LtL,(symm[dot(X.L.T,rgrad.L)])))) + dot(X.L,(numpy.linalg.solve(X.LtL,(symm[dot(eta.L.T,rgrad.L)])))))
# fixedrank/fixedrankfactory_2factors.m:111
    Hess.R = copy(Hess.R - dot(rgrad.R,(numpy.linalg.solve(X.RtR,(symm[dot(X.R.T,eta.R)])))) - dot(eta.R,(numpy.linalg.solve(X.RtR,(symm[dot(X.R.T,rgrad.R)])))) + dot(X.R,(numpy.linalg.solve(X.RtR,(symm[dot(eta.R.T,rgrad.R)])))))
# fixedrank/fixedrankfactory_2factors.m:112
    
    Hess=M.proj(X,Hess)
# fixedrank/fixedrankfactory_2factors.m:115
    return Hess
    
if __name__ == '__main__':
    pass
    
    
    M.proj = copy(projection)
# fixedrank/fixedrankfactory_2factors.m:118
    
    
@function
def projection(X=None,eta=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_2factors.m:121
    SS=dot((X.LtL),(X.RtR))
# fixedrank/fixedrankfactory_2factors.m:123
    AS=dot((X.LtL),(dot(X.R.T,eta.R))) - dot((dot(eta.L.T,X.L)),(X.RtR))
# fixedrank/fixedrankfactory_2factors.m:124
    Omega=lyap(SS,SS,- AS)
# fixedrank/fixedrankfactory_2factors.m:125
    etaproj.L = copy(eta.L + dot(X.L,Omega.T))
# fixedrank/fixedrankfactory_2factors.m:126
    etaproj.R = copy(eta.R - dot(X.R,Omega))
# fixedrank/fixedrankfactory_2factors.m:127
    return etaproj
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(M.proj)
# fixedrank/fixedrankfactory_2factors.m:130
    M.tangent2ambient = copy(lambda X=None,eta=None: eta)
# fixedrank/fixedrankfactory_2factors.m:131
    M.retr = copy(retraction)
# fixedrank/fixedrankfactory_2factors.m:133
    
@function
def retraction(X=None,eta=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# fixedrank/fixedrankfactory_2factors.m:136
    
    
    Y.L = copy(X.L + dot(t,eta.L))
# fixedrank/fixedrankfactory_2factors.m:139
    Y.R = copy(X.R + dot(t,eta.R))
# fixedrank/fixedrankfactory_2factors.m:140
    
    # We need to ensure that L and R do not have very relative
        # skewed norms.
    
    scaling=norm(X.L,'fro') / norm(X.R,'fro')
# fixedrank/fixedrankfactory_2factors.m:146
    scaling=sqrt(scaling)
# fixedrank/fixedrankfactory_2factors.m:147
    Y.L = copy(Y.L / scaling)
# fixedrank/fixedrankfactory_2factors.m:148
    Y.R = copy(dot(Y.R,scaling))
# fixedrank/fixedrankfactory_2factors.m:149
    
    Y=prepare(Y)
# fixedrank/fixedrankfactory_2factors.m:152
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# fixedrank/fixedrankfactory_2factors.m:155
    
@function
def exponential(X=None,eta=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin < 3:
        t=1.0
# fixedrank/fixedrankfactory_2factors.m:158
    
    
    Y=retraction(X,eta,t)
# fixedrank/fixedrankfactory_2factors.m:161
    warning('manopt:fixedrankfactory_2factors:exp',cat('Exponential for fixed rank ','manifold not implemented yet. Used retraction instead.'))
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(cat([ravel(X.L)],[ravel(X.R)]))))
# fixedrank/fixedrankfactory_2factors.m:167
    M.rand = copy(random)
# fixedrank/fixedrankfactory_2factors.m:169
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    # A random point on the total space.
    X.L = copy(randn(m,k))
# fixedrank/fixedrankfactory_2factors.m:172
    X.R = copy(randn(n,k))
# fixedrank/fixedrankfactory_2factors.m:173
    X=prepare(X)
# fixedrank/fixedrankfactory_2factors.m:174
    return X
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# fixedrank/fixedrankfactory_2factors.m:177
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    # A random vector in the horizontal space.
    eta.L = copy(randn(m,k))
# fixedrank/fixedrankfactory_2factors.m:180
    eta.R = copy(randn(n,k))
# fixedrank/fixedrankfactory_2factors.m:181
    eta=projection(X,eta)
# fixedrank/fixedrankfactory_2factors.m:182
    nrm=M.norm(X,eta)
# fixedrank/fixedrankfactory_2factors.m:183
    eta.L = copy(eta.L / nrm)
# fixedrank/fixedrankfactory_2factors.m:184
    eta.R = copy(eta.R / nrm)
# fixedrank/fixedrankfactory_2factors.m:185
    return eta
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(lincomb)
# fixedrank/fixedrankfactory_2factors.m:188
    M.zerovec = copy(lambda X=None: struct('L',zeros(m,k),'R',zeros(n,k)))
# fixedrank/fixedrankfactory_2factors.m:190
    M.transp = copy(lambda x1=None,x2=None,d=None: projection(x2,d))
# fixedrank/fixedrankfactory_2factors.m:192
    
    M.vec = copy(lambda X=None,U=None: cat([ravel(U.L)],[ravel(U.R)]))
# fixedrank/fixedrankfactory_2factors.m:195
    M.mat = copy(lambda X=None,u=None: struct('L',reshape(u[1:(dot(m,k))],m,k),'R',reshape(u[(dot(m,k) + 1):end()],n,k)))
# fixedrank/fixedrankfactory_2factors.m:196
    M.vecmatareisometries = copy(lambda : false)
# fixedrank/fixedrankfactory_2factors.m:198
    return eta
    
if __name__ == '__main__':
    pass
    
    # Linear combination of tangent vectors.
    
@function
def lincomb(x=None,a1=None,d1=None,a2=None,d2=None,*args,**kwargs):
    varargin = lincomb.varargin
    nargin = lincomb.nargin

    
    if nargin == 3:
        d.L = copy(dot(a1,d1.L))
# fixedrank/fixedrankfactory_2factors.m:206
        d.R = copy(dot(a1,d1.R))
# fixedrank/fixedrankfactory_2factors.m:207
    else:
        if nargin == 5:
            d.L = copy(dot(a1,d1.L) + dot(a2,d2.L))
# fixedrank/fixedrankfactory_2factors.m:209
            d.R = copy(dot(a1,d1.R) + dot(a2,d2.R))
# fixedrank/fixedrankfactory_2factors.m:210
        else:
            error('Bad use of fixedrankfactory_2factors.lincomb.')
    
    
    return d
    
if __name__ == '__main__':
    pass
    