# Autogenerated with SMOP 
from smop.core import *
# sphere/spheresymmetricfactory.m

    
@function
def spheresymmetricfactory(n=None,*args,**kwargs):
    varargin = spheresymmetricfactory.varargin
    nargin = spheresymmetricfactory.nargin

    # Returns a manifold struct to optimize over unit-norm symmetric matrices.
    
    # function M = spheresymmetricfactory(n)
    
    # Manifold of n-by-n real symmetric matrices of unit Frobenius norm.
# The metric is such that the sphere is a Riemannian submanifold of the
# space of nxn symmetric matrices with the usual trace inner product, i.e.,
# the usual metric <A, B> = trace(A'*B).
# 
# See also: spherefactory obliquefactory spherecomplexfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, April 17, 2015.
# Contributors: 
# Change log:
    
    #   Oct. 8, 2016 (NB)
#       Code for exponential was simplified to only treat the zero vector
#       as a particular case.
    
    #   Oct. 22, 2016 (NB)
#       Distance function dist now significantly more accurate for points
#       within 1e-7 and less from each other.
    
    M.name = copy(lambda : sprintf('Sphere of symmetric matrices of size %d',n))
# sphere/spheresymmetricfactory.m:27
    M.dim = copy(lambda : dot(n,(n + 1)) / 2 - 1)
# sphere/spheresymmetricfactory.m:29
    M.inner = copy(lambda x=None,d1=None,d2=None: dot(ravel(d1).T,ravel(d2)))
# sphere/spheresymmetricfactory.m:31
    M.norm = copy(lambda x=None,d=None: norm(d,'fro'))
# sphere/spheresymmetricfactory.m:33
    M.dist = copy(dist)
# sphere/spheresymmetricfactory.m:35
    
@function
def dist(x=None,y=None,*args,**kwargs):
    varargin = dist.varargin
    nargin = dist.nargin

    d=real(acos(dot(ravel(x).T,ravel(y))))
# sphere/spheresymmetricfactory.m:37
    
    # close together. In that case, norm is a much better proxy.
    if d < 1e-06:
        d=norm(x - y,'fro')
# sphere/spheresymmetricfactory.m:41
    
    return d
    
if __name__ == '__main__':
    pass
    
    
    M.typicaldist = copy(lambda : pi)
# sphere/spheresymmetricfactory.m:45
    M.proj = copy(proj)
# sphere/spheresymmetricfactory.m:47
    
@function
def proj(x=None,d=None,*args,**kwargs):
    varargin = proj.varargin
    nargin = proj.nargin

    d=(d + d.T) / 2
# sphere/spheresymmetricfactory.m:49
    xdot=d - dot(x,(dot(ravel(x).T,ravel(d))))
# sphere/spheresymmetricfactory.m:50
    return xdot
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(proj)
# sphere/spheresymmetricfactory.m:53
    
    # Riemannian gradient amounts to an orthogonal projection.
    M.egrad2rgrad = copy(proj)
# sphere/spheresymmetricfactory.m:57
    M.ehess2rhess = copy(ehess2rhess)
# sphere/spheresymmetricfactory.m:59
    
@function
def ehess2rhess(x=None,egrad=None,ehess=None,u=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    # these are not explicitly required, given the use.
        # egrad = (egrad + egrad.')/2;
        # ehess = (ehess + ehess.')/2;
    rhess=proj(x,ehess) - dot((dot(ravel(x).T,ravel(egrad))),u)
# sphere/spheresymmetricfactory.m:64
    return rhess
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# sphere/spheresymmetricfactory.m:67
    M.retr = copy(retraction)
# sphere/spheresymmetricfactory.m:69
    M.log = copy(logarithm)
# sphere/spheresymmetricfactory.m:71
    
@function
def logarithm(x1=None,x2=None,*args,**kwargs):
    varargin = logarithm.varargin
    nargin = logarithm.nargin

    v=proj(x1,x2 - x1)
# sphere/spheresymmetricfactory.m:73
    di=M.dist(x1,x2)
# sphere/spheresymmetricfactory.m:74
    
    if di > 1e-06:
        nv=norm(v,'fro')
# sphere/spheresymmetricfactory.m:77
        v=dot(v,(di / nv))
# sphere/spheresymmetricfactory.m:78
    
    return v
    
if __name__ == '__main__':
    pass
    
    
    M.hash = copy(lambda x=None: cat('z',hashmd5(ravel(x))))
# sphere/spheresymmetricfactory.m:82
    M.rand = copy(lambda : random(n))
# sphere/spheresymmetricfactory.m:84
    M.randvec = copy(lambda x=None: randomvec(n,x))
# sphere/spheresymmetricfactory.m:86
    M.lincomb = copy(matrixlincomb)
# sphere/spheresymmetricfactory.m:88
    M.zerovec = copy(lambda x=None: zeros(n))
# sphere/spheresymmetricfactory.m:90
    M.transp = copy(lambda x1=None,x2=None,d=None: proj(x2,d))
# sphere/spheresymmetricfactory.m:92
    M.pairmean = copy(pairmean)
# sphere/spheresymmetricfactory.m:94
    
@function
def pairmean(x1=None,x2=None,*args,**kwargs):
    varargin = pairmean.varargin
    nargin = pairmean.nargin

    y=x1 + x2
# sphere/spheresymmetricfactory.m:96
    y=y / norm(y,'fro')
# sphere/spheresymmetricfactory.m:97
    return y
    
if __name__ == '__main__':
    pass
    
    # TODO : check isometry and fix.
    M.vec = copy(lambda x=None,u_mat=None: ravel(u_mat))
# sphere/spheresymmetricfactory.m:101
    M.mat = copy(lambda x=None,u_vec=None: reshape(u_vec,cat(n,m)))
# sphere/spheresymmetricfactory.m:102
    M.vecmatareisometries = copy(lambda : false)
# sphere/spheresymmetricfactory.m:103
    return y
    
if __name__ == '__main__':
    pass
    
    # Exponential on the sphere
    
@function
def exponential(x=None,d=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin == 2:
        # t = 1;
        td=copy(d)
# sphere/spheresymmetricfactory.m:112
    else:
        td=dot(t,d)
# sphere/spheresymmetricfactory.m:114
    
    
    nrm_td=norm(td,'fro')
# sphere/spheresymmetricfactory.m:117
    if nrm_td > 0:
        y=dot(x,cos(nrm_td)) + dot(td,(sin(nrm_td) / nrm_td))
# sphere/spheresymmetricfactory.m:120
    else:
        y=copy(x)
# sphere/spheresymmetricfactory.m:122
    
    return y
    
if __name__ == '__main__':
    pass
    
    # Retraction on the sphere
    
@function
def retraction(x=None,d=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin == 2:
        t=1
# sphere/spheresymmetricfactory.m:131
    
    
    y=x + dot(t,d)
# sphere/spheresymmetricfactory.m:134
    y=y / norm(y,'fro')
# sphere/spheresymmetricfactory.m:135
    return y
    
if __name__ == '__main__':
    pass
    
    # Uniform random sampling on the sphere.
    
@function
def random(n=None,*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    x=randn(n)
# sphere/spheresymmetricfactory.m:142
    x=(x + x.T) / 2
# sphere/spheresymmetricfactory.m:143
    x=x / norm(x,'fro')
# sphere/spheresymmetricfactory.m:144
    return x
    
if __name__ == '__main__':
    pass
    
    # Random normalized tangent vector at x.
    
@function
def randomvec(n=None,x=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    d=randn(n)
# sphere/spheresymmetricfactory.m:151
    d=(d + d.T) / 2
# sphere/spheresymmetricfactory.m:152
    d=d - dot(x,(dot(ravel(x).T,ravel(d))))
# sphere/spheresymmetricfactory.m:153
    d=d / norm(d,'fro')
# sphere/spheresymmetricfactory.m:154
    return d
    
if __name__ == '__main__':
    pass
    