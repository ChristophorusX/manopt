# Autogenerated with SMOP 
from smop.core import *
# euclidean/skewsymmetricfactory.m

    
@function
def skewsymmetricfactory(n=None,k=None,*args,**kwargs):
    varargin = skewsymmetricfactory.varargin
    nargin = skewsymmetricfactory.nargin

    # Returns a manifold struct to optimize over k skew-symmetric matrices of size n
    
    # function M = skewsymmetricfactory(n)
# function M = skewsymmetricfactory(n, k)
    
    # Returns M, a structure describing the Euclidean space of n-by-n
# skew-symmetric matrices equipped with the standard Frobenius distance and
# associated trace inner product, as a manifold for Manopt.
    
    # By default, k = 1. If k > 1, points and vectors are stored in 3D matrices
# X of size nxnxk such that each slice X(:, :, i), for i = 1:k, is
# skew-symmetric.
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, June 28, 2016.
# Contributors: 
# Change log:
    
    if logical_not(exist('k','var')) or isempty(k):
        k=1
# euclidean/skewsymmetricfactory.m:21
    
    M.name = copy(lambda : sprintf('(Skew-symmetric matrices of size %d)^%d',n,k))
# euclidean/skewsymmetricfactory.m:24
    M.dim = copy(lambda : dot(dot(k,n),(n - 1)) / 2)
# euclidean/skewsymmetricfactory.m:26
    M.inner = copy(lambda x=None,d1=None,d2=None: dot(ravel(d1).T,ravel(d2)))
# euclidean/skewsymmetricfactory.m:28
    M.norm = copy(lambda x=None,d=None: norm(ravel(d),'fro'))
# euclidean/skewsymmetricfactory.m:30
    M.dist = copy(lambda x=None,y=None: norm(ravel(x) - ravel(y),'fro'))
# euclidean/skewsymmetricfactory.m:32
    M.typicaldist = copy(lambda : dot(sqrt(k),n))
# euclidean/skewsymmetricfactory.m:34
    M.proj = copy(lambda x=None,d=None: multiskew(d))
# euclidean/skewsymmetricfactory.m:36
    M.egrad2rgrad = copy(M.proj)
# euclidean/skewsymmetricfactory.m:38
    M.ehess2rhess = copy(lambda x=None,eg=None,eh=None,d=None: M.proj(x,eh))
# euclidean/skewsymmetricfactory.m:40
    M.tangent = copy(lambda x=None,d=None: d)
# euclidean/skewsymmetricfactory.m:42
    M.exp = copy(exp)
# euclidean/skewsymmetricfactory.m:44
    
@function
def exp(x=None,d=None,t=None,*args,**kwargs):
    varargin = exp.varargin
    nargin = exp.nargin

    if nargin == 3:
        y=x + dot(t,d)
# euclidean/skewsymmetricfactory.m:47
    else:
        y=x + d
# euclidean/skewsymmetricfactory.m:49
    
    return y
    
if __name__ == '__main__':
    pass
    
    
    M.retr = copy(M.exp)
# euclidean/skewsymmetricfactory.m:53
    M.log = copy(lambda x=None,y=None: y - x)
# euclidean/skewsymmetricfactory.m:55
    M.hash = copy(lambda x=None: cat('z',hashmd5(ravel(x))))
# euclidean/skewsymmetricfactory.m:57
    M.rand = copy(lambda : multiskew(randn(n,n,k)))
# euclidean/skewsymmetricfactory.m:59
    M.randvec = copy(randvec)
# euclidean/skewsymmetricfactory.m:61
    
@function
def randvec(x=None,*args,**kwargs):
    varargin = randvec.varargin
    nargin = randvec.nargin

    u=multiskew(randn(n,n,k))
# euclidean/skewsymmetricfactory.m:63
    u=u / norm(ravel(u),'fro')
# euclidean/skewsymmetricfactory.m:64
    return u
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# euclidean/skewsymmetricfactory.m:67
    M.zerovec = copy(lambda x=None: zeros(n,n,k))
# euclidean/skewsymmetricfactory.m:69
    M.transp = copy(lambda x1=None,x2=None,d=None: d)
# euclidean/skewsymmetricfactory.m:71
    M.pairmean = copy(lambda x1=None,x2=None: dot(0.5,(x1 + x2)))
# euclidean/skewsymmetricfactory.m:73
    
    single_upper_triangle=find(triu(ones(n),1))
# euclidean/skewsymmetricfactory.m:77
    all_upper_triangle=bsxfun(plus,single_upper_triangle,dot(n ** 2,(arange(0,(k - 1)))))
# euclidean/skewsymmetricfactory.m:78
    all_upper_triangle=ravel(all_upper_triangle)
# euclidean/skewsymmetricfactory.m:79
    
    # scale by sqrt(2) to ensure isometry, that is: given two tangent
    # vectors U and V at a point X, M.inner(X, U, V) is equal to u'*v,
    # where u = M.vec(X, U) and likewise for v. This construction has the
    # advantage of providing a vectorized representation of matrices that
    # has the same length as the intrinsic dimension of the space they live
    # in.
    M.vec = copy(lambda x=None,u_mat=None: dot(sqrt(2),u_mat[all_upper_triangle]))
# euclidean/skewsymmetricfactory.m:88
    M.mat = copy(matricize)
# euclidean/skewsymmetricfactory.m:89
    
@function
def matricize(X=None,u_vec=None,*args,**kwargs):
    varargin = matricize.varargin
    nargin = matricize.nargin

    u_mat=zeros(n,n,k)
# euclidean/skewsymmetricfactory.m:91
    u_mat[all_upper_triangle]=u_vec[(dot(k,n) + 1):end()] / sqrt(2)
# euclidean/skewsymmetricfactory.m:92
    u_mat=u_mat - multitransp(u_mat)
# euclidean/skewsymmetricfactory.m:93
    return u_mat
    
if __name__ == '__main__':
    pass
    
    M.vecmatareisometries = copy(lambda : true)
# euclidean/skewsymmetricfactory.m:95
    return u_mat
    
if __name__ == '__main__':
    pass
    