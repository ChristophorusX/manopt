# Autogenerated with SMOP 
from smop.core import *
# rotations/rotationsfactory.m

    
@function
def rotationsfactory(n=None,k=None,*args,**kwargs):
    varargin = rotationsfactory.varargin
    nargin = rotationsfactory.nargin

    # Returns a manifold structure to optimize over rotation matrices.
# 
# function M = rotationsfactory(n)
# function M = rotationsfactory(n, k)
    
    # Special orthogonal group (the manifold of rotations): deals with matrices
# R of size n x n x k (or n x n if k = 1, which is the default) such that
# each n x n matrix is orthogonal, with determinant 1, i.e., X'*X = eye(n)
# if k = 1, or X(:, :, i)' * X(:, :, i) = eye(n) for i = 1 : k if k > 1.
    
    # This is a description of SO(n)^k with the induced metric from the
# embedding space (R^nxn)^k, i.e., this manifold is a Riemannian
# submanifold of (R^nxn)^k endowed with the usual trace inner product.
    
    # Tangent vectors are represented in the Lie algebra, i.e., as skew
# symmetric matrices. Use the function M.tangent2ambient(X, H) to switch
# from the Lie algebra representation to the embedding space
# representation. This is often necessary when defining
# problem.ehess(X, H).
    
    # By default, the retraction is only a first-order approximation of the
# exponential. To force the use of a second-order approximation, call
# M.retr = M.retr2 after creating M. This switches from a QR-based
# computation to an SVD-based computation.
    
    # By default, k = 1.
    
    # See also: stiefelfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Dec. 30, 2012.
# Contributors: 
# Change log:
#   Jan. 31, 2013 (NB)
#       Added egrad2rgrad and ehess2rhess
#   Oct. 21, 2016 (NB)
#       Added M.retr2: a second-order retraction based on SVD.
    
    
    if logical_not(exist('k','var')) or isempty(k):
        k=1
# rotations/rotationsfactory.m:42
    
    
    if k == 1:
        M.name = copy(lambda : sprintf('Rotations manifold SO(%d)',n))
# rotations/rotationsfactory.m:46
    else:
        if k > 1:
            M.name = copy(lambda : sprintf('Product rotations manifold SO(%d)^%d',n,k))
# rotations/rotationsfactory.m:48
        else:
            error('k must be an integer no less than 1.')
    
    
    M.dim = copy(lambda : dot(k,nchoosek(n,2)))
# rotations/rotationsfactory.m:53
    M.inner = copy(lambda x=None,d1=None,d2=None: dot(ravel(d1).T,ravel(d2)))
# rotations/rotationsfactory.m:55
    M.norm = copy(lambda x=None,d=None: norm(ravel(d)))
# rotations/rotationsfactory.m:57
    M.typicaldist = copy(lambda : dot(pi,sqrt(dot(n,k))))
# rotations/rotationsfactory.m:59
    M.proj = copy(lambda X=None,H=None: multiskew(multiprod(multitransp(X),H)))
# rotations/rotationsfactory.m:61
    M.tangent = copy(lambda X=None,H=None: multiskew(H))
# rotations/rotationsfactory.m:63
    M.tangent2ambient = copy(lambda X=None,U=None: multiprod(X,U))
# rotations/rotationsfactory.m:65
    M.egrad2rgrad = copy(M.proj)
# rotations/rotationsfactory.m:67
    M.ehess2rhess = copy(ehess2rhess)
# rotations/rotationsfactory.m:69
    
@function
def ehess2rhess(X=None,Egrad=None,Ehess=None,H=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    # Reminder : H contains skew-symmeric matrices. The actual
        # direction that the point X is moved along is X*H.
    Xt=multitransp(X)
# rotations/rotationsfactory.m:73
    XtEgrad=multiprod(Xt,Egrad)
# rotations/rotationsfactory.m:74
    symXtEgrad=multisym(XtEgrad)
# rotations/rotationsfactory.m:75
    XtEhess=multiprod(Xt,Ehess)
# rotations/rotationsfactory.m:76
    Rhess=multiskew(XtEhess - multiprod(H,symXtEgrad))
# rotations/rotationsfactory.m:77
    return Rhess
    
if __name__ == '__main__':
    pass
    
    
    M.retr = copy(retraction)
# rotations/rotationsfactory.m:80
    
@function
def retraction(X=None,U=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin == 3:
        tU=dot(t,U)
# rotations/rotationsfactory.m:83
    else:
        tU=copy(U)
# rotations/rotationsfactory.m:85
    
    Y=X + multiprod(X,tU)
# rotations/rotationsfactory.m:87
    for i in arange(1,k).reshape(-1):
        # This QR-based retraction is only a first-order approximation
            # of the exponential map, not a second-order one.
        Q,R=qr(Y[:,:,i],nargout=2)
# rotations/rotationsfactory.m:91
        # of some columns, which should never happen in modern Matlab
            # versions but may be an issue with older versions.
        Y[:,:,i]=dot(Q,diag(sign(sign(diag(R)) + 0.5)))
# rotations/rotationsfactory.m:95
        # determinant +1. Simply look at the eigenvalues of a skew
            # symmetric matrix, than at those of identity plus that matrix,
            # and compute their product for the determinant: it's stricly
            # positive in all cases.
    
    return Y
    
if __name__ == '__main__':
    pass
    
    
    # A second order retraction is implemented here. To force its use,
    # after creating the factory M, execute M.retr = M.retr2.
    M.retr2 = copy(retraction2)
# rotations/rotationsfactory.m:106
    
@function
def retraction2(X=None,U=None,t=None,*args,**kwargs):
    varargin = retraction2.varargin
    nargin = retraction2.nargin

    if nargin == 3:
        tU=dot(t,U)
# rotations/rotationsfactory.m:109
    else:
        tU=copy(U)
# rotations/rotationsfactory.m:111
    
    Y=X + multiprod(X,tU)
# rotations/rotationsfactory.m:113
    for i in arange(1,k).reshape(-1):
        Uk,__,Vk=svd(Y[:,:,k],nargout=3)
# rotations/rotationsfactory.m:115
        Y[:,:,k]=dot(Uk,Vk.T)
# rotations/rotationsfactory.m:116
    
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# rotations/rotationsfactory.m:120
    
@function
def exponential(X=None,U=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin == 3:
        exptU=dot(t,U)
# rotations/rotationsfactory.m:123
    else:
        exptU=copy(U)
# rotations/rotationsfactory.m:125
    
    for i in arange(1,k).reshape(-1):
        exptU[:,:,i]=expm(exptU[:,:,i])
# rotations/rotationsfactory.m:128
    
    Y=multiprod(X,exptU)
# rotations/rotationsfactory.m:130
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.log = copy(logarithm)
# rotations/rotationsfactory.m:133
    
@function
def logarithm(X=None,Y=None,*args,**kwargs):
    varargin = logarithm.varargin
    nargin = logarithm.nargin

    U=multiprod(multitransp(X),Y)
# rotations/rotationsfactory.m:135
    for i in arange(1,k).reshape(-1):
        # The result of logm should be real in theory, but it is
            # numerically useful to force it.
        U[:,:,i]=real(logm(U[:,:,i]))
# rotations/rotationsfactory.m:139
    
    # Ensure the tangent vector is in the Lie algebra.
    U=multiskew(U)
# rotations/rotationsfactory.m:142
    return U
    
if __name__ == '__main__':
    pass
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(ravel(X))))
# rotations/rotationsfactory.m:145
    M.rand = copy(lambda : randrot(n,k))
# rotations/rotationsfactory.m:147
    M.randvec = copy(randomvec)
# rotations/rotationsfactory.m:149
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    U=randskew(n,k)
# rotations/rotationsfactory.m:151
    nrmU=sqrt(dot(ravel(U).T,ravel(U)))
# rotations/rotationsfactory.m:152
    U=U / nrmU
# rotations/rotationsfactory.m:153
    return U
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# rotations/rotationsfactory.m:156
    M.zerovec = copy(lambda x=None: zeros(n,n,k))
# rotations/rotationsfactory.m:158
    M.transp = copy(lambda x1=None,x2=None,d=None: d)
# rotations/rotationsfactory.m:160
    M.pairmean = copy(pairmean)
# rotations/rotationsfactory.m:162
    
@function
def pairmean(X1=None,X2=None,*args,**kwargs):
    varargin = pairmean.varargin
    nargin = pairmean.nargin

    V=M.log(X1,X2)
# rotations/rotationsfactory.m:164
    Y=M.exp(X1,dot(0.5,V))
# rotations/rotationsfactory.m:165
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.dist = copy(lambda x=None,y=None: M.norm(x,M.log(x,y)))
# rotations/rotationsfactory.m:168
    M.vec = copy(lambda x=None,u_mat=None: ravel(u_mat))
# rotations/rotationsfactory.m:170
    M.mat = copy(lambda x=None,u_vec=None: reshape(u_vec,cat(n,n,k)))
# rotations/rotationsfactory.m:171
    M.vecmatareisometries = copy(lambda : true)
# rotations/rotationsfactory.m:172
    return Y
    
if __name__ == '__main__':
    pass
    