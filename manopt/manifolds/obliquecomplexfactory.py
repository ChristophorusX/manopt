# Autogenerated with SMOP 
from smop.core import *
# oblique/obliquecomplexfactory.m

    
@function
def obliquecomplexfactory(n=None,m=None,transposed=None,*args,**kwargs):
    varargin = obliquecomplexfactory.varargin
    nargin = obliquecomplexfactory.nargin

    # Returns a manifold struct defining complex matrices w/ unit-norm columns.
    
    # function M = obliquecomplexfactory(n, m)
# function M = obliquecomplexfactory(n, m, transposed)
    
    # Oblique manifold: deals with complex matrices of size n x m such that
# each column has unit 2-norm, i.e., is a point on the unit sphere in C^n.
# The geometry is a product geometry of m unit spheres in C^n. For the
# metric, C^n is treated as R^(2n), so that the real part and imaginary
# parts are treated separately as 2n real coordinates. As such, the complex
# oblique manifold is a Riemannian submanifold of (R^2)^(n x m), with the
# usual metric <u, v> = real(u'*v).
# 
# If transposed is set to true (it is false by default), then the matrices
# are transposed: a point Y on the manifold is a matrix of size m x n and
# each row has unit 2-norm. It is the same geometry, just a different
# representation.
    
    # In transposed form, a point Y is such that Y*Y' is a Hermitian, positive
# semidefinite matrix of size m and of rank at most n, such that all the
# diagonal entries are equal to 1.
    
    # Note: obliquecomplexfactory(1, n, true) is equivalent to (but potentially
# slower than) complexcirclefactory(n).
    
    # See also: spherecomplexfactory complexcirclefactory obliquefactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Sep. 3, 2014.
# Contributors: 
# Change log:
    
    #   Oct. 21, 2016 (NB)
#       Formatted for inclusion in Manopt release.
    
    
    if logical_not(exist('transposed','var')) or isempty(transposed):
        transposed=copy(false)
# oblique/obliquecomplexfactory.m:39
    
    
    if transposed:
        trnsp=lambda X=None: X.T
# oblique/obliquecomplexfactory.m:43
    else:
        trnsp=lambda X=None: X
# oblique/obliquecomplexfactory.m:45
    
    M.name = copy(lambda : sprintf('Complex oblique manifold COB(%d, %d)',n,m))
# oblique/obliquecomplexfactory.m:48
    M.dim = copy(lambda : dot((dot(2,n) - 1),m))
# oblique/obliquecomplexfactory.m:50
    M.inner = copy(lambda x=None,d1=None,d2=None: real(dot(ravel(d1).T,ravel(d2))))
# oblique/obliquecomplexfactory.m:52
    M.norm = copy(lambda x=None,d=None: norm(ravel(d)))
# oblique/obliquecomplexfactory.m:54
    M.dist = copy(lambda x=None,y=None: norm(real(acos(sum(real(multiply(conj(trnsp[x]),trnsp[y])),1)))))
# oblique/obliquecomplexfactory.m:56
    M.typicaldist = copy(lambda : dot(pi,sqrt(m)))
# oblique/obliquecomplexfactory.m:58
    M.proj = copy(lambda X=None,U=None: trnsp[projection(trnsp[X],trnsp[U])])
# oblique/obliquecomplexfactory.m:60
    M.tangent = copy(M.proj)
# oblique/obliquecomplexfactory.m:62
    
    # Riemannian gradient amounts to an orthogonal projection.
    M.egrad2rgrad = copy(M.proj)
# oblique/obliquecomplexfactory.m:66
    M.ehess2rhess = copy(ehess2rhess)
# oblique/obliquecomplexfactory.m:68
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,U=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    X=trnsp[X]
# oblique/obliquecomplexfactory.m:70
    egrad=trnsp[egrad]
# oblique/obliquecomplexfactory.m:71
    ehess=trnsp[ehess]
# oblique/obliquecomplexfactory.m:72
    U=trnsp[U]
# oblique/obliquecomplexfactory.m:73
    PXehess=projection(X,ehess)
# oblique/obliquecomplexfactory.m:75
    inners=sum(real(multiply(conj(X),egrad)),1)
# oblique/obliquecomplexfactory.m:76
    rhess=PXehess - bsxfun(times,U,inners)
# oblique/obliquecomplexfactory.m:77
    rhess=trnsp[rhess]
# oblique/obliquecomplexfactory.m:79
    return rhess
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# oblique/obliquecomplexfactory.m:82
    
    
@function
def exponential(x=None,d=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    x=trnsp[x]
# oblique/obliquecomplexfactory.m:85
    d=trnsp[d]
# oblique/obliquecomplexfactory.m:86
    if nargin == 2:
        # t = 1;
        td=copy(d)
# oblique/obliquecomplexfactory.m:90
    else:
        td=dot(t,d)
# oblique/obliquecomplexfactory.m:92
    
    nrm_td=sqrt(sum(real(td) ** 2 + imag(td) ** 2,1))
# oblique/obliquecomplexfactory.m:95
    y=bsxfun(times,x,cos(nrm_td)) + bsxfun(times,td,sin(nrm_td) / nrm_td)
# oblique/obliquecomplexfactory.m:97
    
    exclude=(nrm_td == 0)
# oblique/obliquecomplexfactory.m:101
    y[:,exclude]=x[:,exclude]
# oblique/obliquecomplexfactory.m:102
    y=trnsp[y]
# oblique/obliquecomplexfactory.m:104
    return y
    
if __name__ == '__main__':
    pass
    
    M.log = copy(logarithm)
# oblique/obliquecomplexfactory.m:107
    
@function
def logarithm(x1=None,x2=None,*args,**kwargs):
    varargin = logarithm.varargin
    nargin = logarithm.nargin

    x1=trnsp[x1]
# oblique/obliquecomplexfactory.m:109
    x2=trnsp[x2]
# oblique/obliquecomplexfactory.m:110
    v=projection(x1,x2 - x1)
# oblique/obliquecomplexfactory.m:112
    dists=real(acos(sum(real(multiply(conj(x1),x2)),1)))
# oblique/obliquecomplexfactory.m:113
    norms=sqrt(sum(real(v) ** 2 + imag(v) ** 2,1))
# oblique/obliquecomplexfactory.m:114
    factors=dists / norms
# oblique/obliquecomplexfactory.m:115
    
    # because they are both almost zero, the division above can return
        # NaN's. To avoid that, we force those ratios to 1.
    factors[dists <= 1e-06]=1
# oblique/obliquecomplexfactory.m:119
    v=bsxfun(times,v,factors)
# oblique/obliquecomplexfactory.m:120
    v=trnsp[v]
# oblique/obliquecomplexfactory.m:122
    return v
    
if __name__ == '__main__':
    pass
    
    M.retr = copy(retraction)
# oblique/obliquecomplexfactory.m:125
    
    
@function
def retraction(x=None,d=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    x=trnsp[x]
# oblique/obliquecomplexfactory.m:128
    d=trnsp[d]
# oblique/obliquecomplexfactory.m:129
    if nargin < 3:
        td=copy(d)
# oblique/obliquecomplexfactory.m:132
    else:
        td=dot(t,d)
# oblique/obliquecomplexfactory.m:134
    
    y=normalize_columns(x + td)
# oblique/obliquecomplexfactory.m:137
    y=trnsp[y]
# oblique/obliquecomplexfactory.m:139
    return y
    
if __name__ == '__main__':
    pass
    
    M.hash = copy(lambda x=None: cat('z',hashmd5(cat([real(ravel(x))],[imag(ravel(x))]))))
# oblique/obliquecomplexfactory.m:142
    M.rand = copy(lambda : trnsp[random(n,m)])
# oblique/obliquecomplexfactory.m:144
    M.randvec = copy(lambda x=None: trnsp[randomvec(n,m,trnsp[x])])
# oblique/obliquecomplexfactory.m:146
    M.lincomb = copy(matrixlincomb)
# oblique/obliquecomplexfactory.m:148
    M.zerovec = copy(lambda x=None: trnsp[zeros(n,m)])
# oblique/obliquecomplexfactory.m:150
    M.transp = copy(lambda x1=None,x2=None,d=None: M.proj(x2,d))
# oblique/obliquecomplexfactory.m:152
    M.pairmean = copy(pairmean)
# oblique/obliquecomplexfactory.m:154
    
@function
def pairmean(x1=None,x2=None,*args,**kwargs):
    varargin = pairmean.varargin
    nargin = pairmean.nargin

    y=trnsp[x1 + x2]
# oblique/obliquecomplexfactory.m:156
    y=normalize_columns(y)
# oblique/obliquecomplexfactory.m:157
    y=trnsp[y]
# oblique/obliquecomplexfactory.m:158
    return y
    
if __name__ == '__main__':
    pass
    
    # vec returns a vector representation of an input tangent vector which
    # is represented as a matrix. mat returns the original matrix
    # representation of the input vector representation of a tangent
    # vector. vec and mat are thus inverse of each other. They are
    # furthermore isometries between a subspace of R^2nm and the tangent
    # space at x.
    vect=lambda X=None: ravel(X)
# oblique/obliquecomplexfactory.m:167
    M.vec = copy(lambda x=None,u_mat=None: cat([vect[real(trnsp[u_mat])]],[vect[imag(trnsp[u_mat])]]))
# oblique/obliquecomplexfactory.m:168
    M.mat = copy(lambda x=None,u_vec=None: trnsp[reshape(u_vec[1:(dot(n,m))],cat(n,m))] + dot(1j,trnsp[reshape(u_vec[(dot(n,m) + 1):end()],cat(n,m))]))
# oblique/obliquecomplexfactory.m:170
    M.vecmatareisometries = copy(lambda : true)
# oblique/obliquecomplexfactory.m:172
    return y
    
if __name__ == '__main__':
    pass
    
    # Given a matrix X, returns the same matrix but with each column scaled so
# that they have unit 2-norm.
    
@function
def normalize_columns(X=None,*args,**kwargs):
    varargin = normalize_columns.varargin
    nargin = normalize_columns.nargin

    norms=sqrt(sum(real(X) ** 2 + imag(X) ** 2,1))
# oblique/obliquecomplexfactory.m:179
    X=bsxfun(times,X,1.0 / norms)
# oblique/obliquecomplexfactory.m:180
    return X
    
if __name__ == '__main__':
    pass
    
    # Orthogonal projection of the ambient vector H onto the tangent space at X
    
@function
def projection(X=None,H=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    # Compute the inner product between each vector H(:, i) with its root
    # point X(:, i), that is, real(X(:, i)' * H(:, i)).
    # Returns a row vector.
    inners=real(sum(multiply(conj(X),H),1))
# oblique/obliquecomplexfactory.m:189
    
    # the root points X(:, i).
    PXH=H - bsxfun(times,X,inners)
# oblique/obliquecomplexfactory.m:193
    return PXH
    
if __name__ == '__main__':
    pass
    
    # Uniform random sampling on the sphere.
    
@function
def random(n=None,m=None,*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    x=normalize_columns(randn(n,m) + dot(1j,randn(n,m)))
# oblique/obliquecomplexfactory.m:200
    return x
    
if __name__ == '__main__':
    pass
    
    # Random normalized tangent vector at x.
    
@function
def randomvec(n=None,m=None,x=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    d=randn(n,m) + dot(1j,randn(n,m))
# oblique/obliquecomplexfactory.m:207
    d=projection(x,d)
# oblique/obliquecomplexfactory.m:208
    d=d / norm(ravel(d))
# oblique/obliquecomplexfactory.m:209
    return d
    
if __name__ == '__main__':
    pass
    