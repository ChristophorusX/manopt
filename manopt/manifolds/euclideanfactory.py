# Autogenerated with SMOP 
from smop.core import *
# euclidean/euclideanfactory.m

    
@function
def euclideanfactory(m=None,n=None,*args,**kwargs):
    varargin = euclideanfactory.varargin
    nargin = euclideanfactory.nargin

    # Returns a manifold struct to optimize over m-by-n matrices.
    
    # function M = euclideanfactory(m, n)
    
    # Returns M, a structure describing the Euclidean space of m-by-n matrices,
# equipped with the standard Frobenius distance and associated trace inner
# product, as a manifold for Manopt.
    
    # m and n in general can be vectors to handle multidimensional arrays.
# If either of m or n is a vector, they are concatenated as [m, n].
    
    # Using this simple linear manifold, Manopt can be used to solve standard
# unconstrained optimization problems, for example in replacement of
# Matlab's fminunc.
    
    # See also: euclideancomplexfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Dec. 30, 2012.
# Contributors: Bamdev Mishra, May 4, 2015.
# Change log:
    
    #   July 5, 2013 (NB):
#       Added egred2rgrad, ehess2rhess, mat, vec, tangent.
#   May 4, 2015 (BM):
#       Added functionality to handle multidimensional arrays.
    
    # The size can be defined using both m and n, or simply with m.
    # If m is a scalar, then n is implicitly 1.
    # This mimicks the use of built-in Matlab functions such as zeros(...).
    if logical_not(exist('n','var')) or isempty(n):
        if numel(m) == 1:
            n=1
# euclidean/euclideanfactory.m:35
        else:
            n=matlabarray([])
# euclidean/euclideanfactory.m:37
    
    
    dimensions_vec=matlabarray(cat(ravel(m).T,ravel(n).T))
# euclidean/euclideanfactory.m:41
    
    
    
    M.name = copy(lambda : sprintf('Euclidean space R^(%s)',num2str(dimensions_vec)))
# euclidean/euclideanfactory.m:44
    
    
    M.dim = copy(lambda : prod(dimensions_vec))
# euclidean/euclideanfactory.m:46
    
    
    M.inner = copy(lambda x=None,d1=None,d2=None: dot(ravel(d1).T,ravel(d2)))
# euclidean/euclideanfactory.m:48
    
    
    M.norm = copy(lambda x=None,d=None: norm(ravel(d),'fro'))
# euclidean/euclideanfactory.m:50
    
    
    M.dist = copy(lambda x=None,y=None: norm(ravel(x) - ravel(y),'fro'))
# euclidean/euclideanfactory.m:52
    
    
    M.typicaldist = copy(lambda : sqrt(prod(dimensions_vec)))
# euclidean/euclideanfactory.m:54
    
    
    M.proj = copy(lambda x=None,d=None: d)
# euclidean/euclideanfactory.m:56
    
    
    M.egrad2rgrad = copy(lambda x=None,g=None: g)
# euclidean/euclideanfactory.m:58
    
    
    M.ehess2rhess = copy(lambda x=None,eg=None,eh=None,d=None: eh)
# euclidean/euclideanfactory.m:60
    
    
    M.tangent = copy(M.proj)
# euclidean/euclideanfactory.m:62
    M.exp = copy(exp)
# euclidean/euclideanfactory.m:64
    
@function
def exp(x=None,d=None,t=None,*args,**kwargs):
    varargin = exp.varargin
    nargin = exp.nargin

    if nargin == 3:
        y=x + dot(t,d)
# euclidean/euclideanfactory.m:67
    else:
        y=x + d
# euclidean/euclideanfactory.m:69
    
    return y
    
if __name__ == '__main__':
    pass
    
    
    M.retr = copy(M.exp)
# euclidean/euclideanfactory.m:73
    M.log = copy(lambda x=None,y=None: y - x)
# euclidean/euclideanfactory.m:75
    
    M.hash = copy(lambda x=None: cat('z',hashmd5(ravel(x))))
# euclidean/euclideanfactory.m:77
    
    
    M.rand = copy(lambda : randn(dimensions_vec))
# euclidean/euclideanfactory.m:79
    
    
    M.randvec = copy(randvec)
# euclidean/euclideanfactory.m:81
    
@function
def randvec(x=None,*args,**kwargs):
    varargin = randvec.varargin
    nargin = randvec.nargin

    u=randn(dimensions_vec)
# euclidean/euclideanfactory.m:83
    
    u=u / norm(ravel(u),'fro')
# euclidean/euclideanfactory.m:84
    
    return u
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# euclidean/euclideanfactory.m:87
    M.zerovec = copy(lambda x=None: zeros(dimensions_vec))
# euclidean/euclideanfactory.m:89
    
    
    M.transp = copy(lambda x1=None,x2=None,d=None: d)
# euclidean/euclideanfactory.m:91
    M.pairmean = copy(lambda x1=None,x2=None: dot(0.5,(x1 + x2)))
# euclidean/euclideanfactory.m:93
    
    
    M.vec = copy(lambda x=None,u_mat=None: ravel(u_mat))
# euclidean/euclideanfactory.m:95
    
    M.mat = copy(lambda x=None,u_vec=None: reshape(u_vec,dimensions_vec))
# euclidean/euclideanfactory.m:96
    
    M.vecmatareisometries = copy(lambda : true)
# euclidean/euclideanfactory.m:97
    return u
    
if __name__ == '__main__':
    pass
    