# Autogenerated with SMOP 
from smop.core import *
# euclidean/symmetricfactory.m

    
@function
def symmetricfactory(n=None,k=None,*args,**kwargs):
    varargin = symmetricfactory.varargin
    nargin = symmetricfactory.nargin

    # Returns a manifold struct to optimize over k symmetric matrices of size n
    
    # function M = symmetricfactory(n)
# function M = symmetricfactory(n, k)
    
    # Returns M, a structure describing the Euclidean space of n-by-n symmetric
# matrices equipped with the standard Frobenius distance and associated
# trace inner product, as a manifold for Manopt.
# 
# By default, k = 1. If k > 1, points and vectors are stored in 3D matrices
# X of size nxnxk such that each slice X(:, :, i), for i = 1:k, is
# symmetric.
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Jan. 22, 2014.
# Contributors: 
# Change log:
    
    if logical_not(exist('k','var')) or isempty(k):
        k=1
# euclidean/symmetricfactory.m:21
    
    M.name = copy(lambda : sprintf('(Symmetric matrices of size %d)^%d',n,k))
# euclidean/symmetricfactory.m:24
    M.dim = copy(lambda : dot(dot(k,n),(n + 1)) / 2)
# euclidean/symmetricfactory.m:26
    M.inner = copy(lambda x=None,d1=None,d2=None: dot(ravel(d1).T,ravel(d2)))
# euclidean/symmetricfactory.m:28
    M.norm = copy(lambda x=None,d=None: norm(ravel(d),'fro'))
# euclidean/symmetricfactory.m:30
    M.dist = copy(lambda x=None,y=None: norm(ravel(x) - ravel(y),'fro'))
# euclidean/symmetricfactory.m:32
    M.typicaldist = copy(lambda : dot(sqrt(k),n))
# euclidean/symmetricfactory.m:34
    M.proj = copy(lambda x=None,d=None: multisym(d))
# euclidean/symmetricfactory.m:36
    M.egrad2rgrad = copy(M.proj)
# euclidean/symmetricfactory.m:38
    M.ehess2rhess = copy(lambda x=None,eg=None,eh=None,d=None: M.proj(x,eh))
# euclidean/symmetricfactory.m:40
    M.tangent = copy(lambda x=None,d=None: d)
# euclidean/symmetricfactory.m:42
    M.exp = copy(exp)
# euclidean/symmetricfactory.m:44
    
@function
def exp(x=None,d=None,t=None,*args,**kwargs):
    varargin = exp.varargin
    nargin = exp.nargin

    if nargin == 3:
        y=x + dot(t,d)
# euclidean/symmetricfactory.m:47
    else:
        y=x + d
# euclidean/symmetricfactory.m:49
    
    return y
    
if __name__ == '__main__':
    pass
    
    
    M.retr = copy(M.exp)
# euclidean/symmetricfactory.m:53
    M.log = copy(lambda x=None,y=None: y - x)
# euclidean/symmetricfactory.m:55
    M.hash = copy(lambda x=None: cat('z',hashmd5(ravel(x))))
# euclidean/symmetricfactory.m:57
    M.rand = copy(lambda : multisym(randn(n,n,k)))
# euclidean/symmetricfactory.m:59
    M.randvec = copy(randvec)
# euclidean/symmetricfactory.m:61
    
@function
def randvec(x=None,*args,**kwargs):
    varargin = randvec.varargin
    nargin = randvec.nargin

    u=multisym(randn(n,n,k))
# euclidean/symmetricfactory.m:63
    u=u / norm(ravel(u),'fro')
# euclidean/symmetricfactory.m:64
    return u
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# euclidean/symmetricfactory.m:67
    M.zerovec = copy(lambda x=None: zeros(n,n,k))
# euclidean/symmetricfactory.m:69
    M.transp = copy(lambda x1=None,x2=None,d=None: d)
# euclidean/symmetricfactory.m:71
    M.pairmean = copy(lambda x1=None,x2=None: dot(0.5,(x1 + x2)))
# euclidean/symmetricfactory.m:73
    
    single_diag_entries=(arange(1,n ** 2,(n + 1))).T
# euclidean/symmetricfactory.m:77
    all_diag_entries=bsxfun(plus,single_diag_entries,dot(n ** 2,(arange(0,(k - 1)))))
# euclidean/symmetricfactory.m:78
    all_diag_entries=ravel(all_diag_entries)
# euclidean/symmetricfactory.m:79
    
    single_upper_triangle=find(triu(ones(n),1))
# euclidean/symmetricfactory.m:82
    all_upper_triangle=bsxfun(plus,single_upper_triangle,dot(n ** 2,(arange(0,(k - 1)))))
# euclidean/symmetricfactory.m:83
    all_upper_triangle=ravel(all_upper_triangle)
# euclidean/symmetricfactory.m:84
    
    # upper-triangular entries, the latter being scaled by sqrt(2) to
    # ensure isometry, that is: given two tangent vectors U and V at a
    # point X, M.inner(X, U, V) is equal to u'*v, where u = M.vec(X, U) and
    # likewise for v. This construction has the advantage of providing a
    # vectorized representation of matrices that has the same length as the
    # intrinsic dimension of the space they live in.
    M.vec = copy(lambda x=None,u_mat=None: cat([u_mat[all_diag_entries]],[dot(sqrt(2),u_mat[all_upper_triangle])]))
# euclidean/symmetricfactory.m:93
    M.mat = copy(matricize)
# euclidean/symmetricfactory.m:95
    
@function
def matricize(X=None,u_vec=None,*args,**kwargs):
    varargin = matricize.varargin
    nargin = matricize.nargin

    u_mat=zeros(n,n,k)
# euclidean/symmetricfactory.m:97
    u_mat[all_upper_triangle]=u_vec[(dot(k,n) + 1):end()] / sqrt(2)
# euclidean/symmetricfactory.m:98
    u_mat=u_mat + multitransp(u_mat)
# euclidean/symmetricfactory.m:99
    u_mat[all_diag_entries]=u_vec[1:(dot(k,n))]
# euclidean/symmetricfactory.m:100
    return u_mat
    
if __name__ == '__main__':
    pass
    
    M.vecmatareisometries = copy(lambda : true)
# euclidean/symmetricfactory.m:102
    return u_mat
    
if __name__ == '__main__':
    pass
    
    # Former, easier versions for vec / mat. They had the disadvantage of
# giving vector representations of length k*n^2, instead of k*n*(n+1).
# M.vec = @(x, u_mat) u_mat(:);
# M.mat = @(x, u_vec) reshape(u_vec, [m, n]);
# M.vecmatareisometries = @() true;