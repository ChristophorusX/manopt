# Autogenerated with SMOP 
from smop.core import *
# stiefel/stiefelfactory.m

    
@function
def stiefelfactory(n=None,p=None,k=None,*args,**kwargs):
    varargin = stiefelfactory.varargin
    nargin = stiefelfactory.nargin

    # Returns a manifold structure to optimize over orthonormal matrices.
    
    # function M = stiefelfactory(n, p)
# function M = stiefelfactory(n, p, k)
    
    # The Stiefel manifold is the set of orthonormal nxp matrices. If k
# is larger than 1, this is the Cartesian product of the Stiefel manifold
# taken k times. The metric is such that the manifold is a Riemannian
# submanifold of R^nxp equipped with the usual trace inner product, that
# is, it is the usual metric.
    
    # Points are represented as matrices X of size n x p x k (or n x p if k=1,
# which is the default) such that each n x p matrix is orthonormal,
# i.e., X'*X = eye(p) if k = 1, or X(:, :, i)' * X(:, :, i) = eye(p) for
# i = 1 : k if k > 1. Tangent vectors are represented as matrices the same
# size as points.
    
    # By default, k = 1.
    
    # See also: grassmannfactory rotationsfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Dec. 30, 2012.
# Contributors: 
# Change log: 
#  July  5, 2013 (NB) : Added ehess2rhess.
#  Jan. 27, 2014 (BM) : Bug in ehess2rhess corrected.
#  June 24, 2014 (NB) : Added true exponential map and changed the randvec
#                       function so that it now returns a globally
#                       normalized vector, not a vector where each
#                       component is normalized (this only matters if k>1).
    
    
    if logical_not(exist('k','var')) or isempty(k):
        k=1
# stiefel/stiefelfactory.m:36
    
    
    if k == 1:
        M.name = copy(lambda : sprintf('Stiefel manifold St(%d, %d)',n,p))
# stiefel/stiefelfactory.m:40
    else:
        if k > 1:
            M.name = copy(lambda : sprintf('Product Stiefel manifold St(%d, %d)^%d',n,p,k))
# stiefel/stiefelfactory.m:42
        else:
            error('k must be an integer no less than 1.')
    
    
    M.dim = copy(lambda : dot(k,(dot(n,p) - dot(dot(0.5,p),(p + 1)))))
# stiefel/stiefelfactory.m:47
    M.inner = copy(lambda x=None,d1=None,d2=None: dot(ravel(d1).T,ravel(d2)))
# stiefel/stiefelfactory.m:49
    M.norm = copy(lambda x=None,d=None: norm(ravel(d)))
# stiefel/stiefelfactory.m:51
    M.dist = copy(lambda x=None,y=None: error('stiefel.dist not implemented yet.'))
# stiefel/stiefelfactory.m:53
    M.typicaldist = copy(lambda : sqrt(dot(p,k)))
# stiefel/stiefelfactory.m:55
    M.proj = copy(projection)
# stiefel/stiefelfactory.m:57
    
@function
def projection(X=None,U=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    
    XtU=multiprod(multitransp(X),U)
# stiefel/stiefelfactory.m:60
    symXtU=multisym(XtU)
# stiefel/stiefelfactory.m:61
    Up=U - multiprod(X,symXtU)
# stiefel/stiefelfactory.m:62
    # The code above is equivalent to, but much faster than, the code below.
#         
#     Up = zeros(size(U));
#     function A = sym(A), A = .5*(A+A'); end
#     for i = 1 : k
#         Xi = X(:, :, i);
#         Ui = U(:, :, i);
#         Up(:, :, i) = Ui - Xi*sym(Xi'*Ui);
#     end
    
    return Up
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(M.proj)
# stiefel/stiefelfactory.m:76
    
    # Riemannian gradient amounts to an orthogonal projection.
    M.egrad2rgrad = copy(M.proj)
# stiefel/stiefelfactory.m:80
    M.ehess2rhess = copy(ehess2rhess)
# stiefel/stiefelfactory.m:82
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,H=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    XtG=multiprod(multitransp(X),egrad)
# stiefel/stiefelfactory.m:84
    symXtG=multisym(XtG)
# stiefel/stiefelfactory.m:85
    HsymXtG=multiprod(H,symXtG)
# stiefel/stiefelfactory.m:86
    rhess=projection(X,ehess - HsymXtG)
# stiefel/stiefelfactory.m:87
    return rhess
    
if __name__ == '__main__':
    pass
    
    
    M.retr = copy(retraction)
# stiefel/stiefelfactory.m:90
    
@function
def retraction(X=None,U=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# stiefel/stiefelfactory.m:93
    
    Y=X + dot(t,U)
# stiefel/stiefelfactory.m:95
    for i in arange(1,k).reshape(-1):
        Q,R=qr(Y[:,:,i],0,nargout=2)
# stiefel/stiefelfactory.m:97
        # of some columns, which should never happen in modern Matlab
            # versions but may be an issue with older versions.
        Y[:,:,i]=dot(Q,diag(sign(sign(diag(R)) + 0.5)))
# stiefel/stiefelfactory.m:101
    
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# stiefel/stiefelfactory.m:105
    
@function
def exponential(X=None,U=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin == 2:
        t=1
# stiefel/stiefelfactory.m:108
    
    tU=dot(t,U)
# stiefel/stiefelfactory.m:110
    Y=zeros(size(X))
# stiefel/stiefelfactory.m:111
    for i in arange(1,k).reshape(-1):
        # From a formula by Ross Lippert, Example 5.4.2 in AMS08.
        Xi=X[:,:,i]
# stiefel/stiefelfactory.m:114
        Ui=tU[:,:,i]
# stiefel/stiefelfactory.m:115
        Y[:,:,i]=dot(dot(cat(Xi,Ui),expm(cat([dot(Xi.T,Ui),dot(- Ui.T,Ui)],[eye(p),dot(Xi.T,Ui)]))),cat([expm(dot(- Xi.T,Ui))],[zeros(p)]))
# stiefel/stiefelfactory.m:116
    
    
    return Y
    
if __name__ == '__main__':
    pass
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(ravel(X))))
# stiefel/stiefelfactory.m:123
    M.rand = copy(random)
# stiefel/stiefelfactory.m:125
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    X=zeros(n,p,k)
# stiefel/stiefelfactory.m:127
    for i in arange(1,k).reshape(-1):
        Q,unused=qr(randn(n,p),0,nargout=2)
# stiefel/stiefelfactory.m:129
        X[:,:,i]=Q
# stiefel/stiefelfactory.m:130
    
    return X
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# stiefel/stiefelfactory.m:134
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    U=projection(X,randn(n,p,k))
# stiefel/stiefelfactory.m:136
    U=U / norm(ravel(U))
# stiefel/stiefelfactory.m:137
    return U
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# stiefel/stiefelfactory.m:140
    M.zerovec = copy(lambda x=None: zeros(n,p,k))
# stiefel/stiefelfactory.m:142
    M.transp = copy(lambda x1=None,x2=None,d=None: projection(x2,d))
# stiefel/stiefelfactory.m:144
    M.vec = copy(lambda x=None,u_mat=None: ravel(u_mat))
# stiefel/stiefelfactory.m:146
    M.mat = copy(lambda x=None,u_vec=None: reshape(u_vec,cat(n,p,k)))
# stiefel/stiefelfactory.m:147
    M.vecmatareisometries = copy(lambda : true)
# stiefel/stiefelfactory.m:148
    return U
    
if __name__ == '__main__':
    pass
    