# Autogenerated with SMOP 
from smop.core import *
# fixedrank/fixedrankfactory_2factors_subspace_projection.m

    
@function
def fixedrankfactory_2factors_subspace_projection(m=None,n=None,k=None,*args,**kwargs):
    varargin = fixedrankfactory_2factors_subspace_projection.varargin
    nargin = fixedrankfactory_2factors_subspace_projection.nargin

    # Manifold of m-by-n matrices of rank k with two factor quotient geometry.
    
    # function M = fixedrankfactory_2factors_subspace_projection(m, n, k)
    
    # A point X on the manifold is represented as a structure with two
# fields: L and R. The matrix L (mxk) is orthonormal,
# while the matrix R (nxk) is a full column-rank
# matrix such that X = L*R'.
    
    # Tangent vectors are represented as a structure with two fields: L, R.
    
    # Note: L is orthonormal, i.e., columns are orthogonal to each other.
# Such a geometry might be of interest where the left factor has a
# subspace interpretation. A motivation is in Sections 3.3 and 6.4 of the
# paper below.
    
    # Please cite the Manopt paper as well as the research paper:
#     @Article{mishra2014fixedrank,
#       Title   = {Fixed-rank matrix factorizations and {Riemannian} low-rank optimization},
#       Author  = {Mishra, B. and Meyer, G. and Bonnabel, S. and Sepulchre, R.},
#       Journal = {Computational Statistics},
#       Year    = {2014},
#       Number  = {3-4},
#       Pages   = {591--621},
#       Volume  = {29},
#       Doi     = {10.1007/s00180-013-0464-z}
#     }
    
    # See also: fixedrankfactory_2factors fixedrankembeddedfactory fixedrankfactory_2factors_preconditioned
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Bamdev Mishra, Dec. 30, 2012.
# Contributors:
# Change log:
    
    M.name = copy(lambda : sprintf('LR\' quotient manifold of %dx%d matrices of rank %d',m,n,k))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:39
    M.dim = copy(lambda : dot((m + n - k),k))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:41
    
    # pretty much everywhere else).
    
@function
def prepare(X=None,*args,**kwargs):
    varargin = prepare.varargin
    nargin = prepare.nargin

    if logical_not(all(isfield(X,cellarray(['RtR'])) == 1)):
        X.RtR = copy(dot(X.R.T,X.R))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:47
    
    return X
    
if __name__ == '__main__':
    pass
    
    
    # The choice of the metric is motivated by symmetry and scale
    # invariance in the total space.
    M.inner = copy(iproduct)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:53
    
@function
def iproduct(X=None,eta=None,zeta=None,*args,**kwargs):
    varargin = iproduct.varargin
    nargin = iproduct.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:55
    ip=dot(ravel(eta.L).T,ravel(zeta.L)) + trace(numpy.linalg.solve(X.RtR,(dot(eta.R.T,zeta.R))))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:57
    return ip
    
if __name__ == '__main__':
    pass
    
    
    M.norm = copy(lambda X=None,eta=None: sqrt(M.inner(X,eta,eta)))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:60
    M.dist = copy(lambda x=None,y=None: error('fixedrankfactory_2factors_subspace_projection.dist not implemented yet.'))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:62
    M.typicaldist = copy(lambda : dot(10,k))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:64
    skew=lambda X=None: dot(0.5,(X - X.T))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:66
    symm=lambda X=None: dot(0.5,(X + X.T))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:67
    stiefel_proj=lambda L=None,H=None: H - dot(L,symm[dot(L.T,H)])
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:68
    M.egrad2rgrad = copy(egrad2rgrad)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:70
    
@function
def egrad2rgrad(X=None,egrad=None,*args,**kwargs):
    varargin = egrad2rgrad.varargin
    nargin = egrad2rgrad.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:72
    rgrad.L = copy(stiefel_proj[X.L,egrad.L])
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:74
    rgrad.R = copy(dot(egrad.R,X.RtR))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:75
    return rgrad
    
if __name__ == '__main__':
    pass
    
    
    
    M.ehess2rhess = copy(ehess2rhess)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:79
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,eta=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:81
    
    rgrad=egrad2rgrad(X,egrad)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:84
    
    Hess.L = copy(ehess.L - dot(eta.L,symm[dot(X.L.T,egrad.L)]))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:87
    Hess.L = copy(stiefel_proj[X.L,Hess.L])
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:88
    Hess.R = copy(dot(ehess.R,X.RtR) + dot(dot(2,egrad.R),symm[dot(eta.R.T,X.R)]))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:90
    
    Hess.R = copy(Hess.R - dot(rgrad.R,(numpy.linalg.solve(X.RtR,(symm[dot(X.R.T,eta.R)])))) - dot(eta.R,(numpy.linalg.solve(X.RtR,(symm[dot(X.R.T,rgrad.R)])))) + dot(X.R,(numpy.linalg.solve(X.RtR,(symm[dot(eta.R.T,rgrad.R)])))))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:93
    
    Hess=M.proj(X,Hess)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:96
    return Hess
    
if __name__ == '__main__':
    pass
    
    
    
    M.proj = copy(projection)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:100
    
@function
def projection(X=None,eta=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:102
    eta.L = copy(stiefel_proj[X.L,eta.L])
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:104
    
    SS=X.RtR
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:105
    AS1=dot(dot(dot(2,X.RtR),skew[dot(X.L.T,eta.L)]),X.RtR)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:106
    AS2=dot(2,skew[dot(X.RtR,(dot(X.R.T,eta.R)))])
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:107
    AS=skew[AS1 + AS2]
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:108
    Omega=nested_sylvester(SS,AS)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:110
    etaproj.L = copy(eta.L - dot(X.L,Omega))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:111
    etaproj.R = copy(eta.R - dot(X.R,Omega))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:112
    return etaproj
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(M.proj)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:115
    M.tangent2ambient = copy(lambda X=None,eta=None: eta)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:116
    M.retr = copy(retraction)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:118
    
@function
def retraction(X=None,eta=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:121
    
    Y.L = copy(uf(X.L + dot(t,eta.L)))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:123
    Y.R = copy(X.R + dot(t,eta.R))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:124
    
    Y=prepare(Y)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:127
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:130
    
@function
def exponential(X=None,eta=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin < 3:
        t=1.0
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:133
    
    
    R=retraction(X,eta,t)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:136
    warning('manopt:fixedrankfactory_2factors_subspace_projection:exp',cat('Exponential for fixed rank ','manifold not implemented yet. Lsed retraction instead.'))
    return R
    
if __name__ == '__main__':
    pass
    
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(cat([ravel(X.L)],[ravel(X.R)]))))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:142
    M.rand = copy(random)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:144
    
    # its random generator.
    stiefelm=stiefelfactory(m,k)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:147
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    X.L = copy(stiefelm.rand())
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:149
    X.R = copy(randn(n,k))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:150
    return X
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:153
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    eta.L = copy(randn(m,k))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:155
    eta.R = copy(randn(n,k))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:156
    eta=projection(X,eta)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:157
    nrm=M.norm(X,eta)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:158
    eta.L = copy(eta.L / nrm)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:159
    eta.R = copy(eta.R / nrm)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:160
    return eta
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(lincomb)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:163
    M.zerovec = copy(lambda X=None: struct('L',zeros(m,k),'R',zeros(n,k)))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:165
    M.transp = copy(lambda x1=None,x2=None,d=None: projection(x2,d))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:168
    
    M.vec = copy(lambda X=None,U=None: cat([ravel(U.L)],[ravel(U.R)]))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:171
    M.mat = copy(lambda X=None,u=None: struct('L',reshape(u[1:(dot(m,k))],m,k),'R',reshape(u[(dot(m,k) + 1):end()],n,k)))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:172
    M.vecmatareisometries = copy(lambda : false)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:174
    return eta
    
if __name__ == '__main__':
    pass
    
    # Linear combination of tangent vectors.
    
@function
def lincomb(x=None,a1=None,d1=None,a2=None,d2=None,*args,**kwargs):
    varargin = lincomb.varargin
    nargin = lincomb.nargin

    
    if nargin == 3:
        d.L = copy(dot(a1,d1.L))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:183
        d.R = copy(dot(a1,d1.R))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:184
    else:
        if nargin == 5:
            d.L = copy(dot(a1,d1.L) + dot(a2,d2.L))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:186
            d.R = copy(dot(a1,d1.R) + dot(a2,d2.R))
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:187
        else:
            error('Bad use of fixedrankfactory_2factors_subspace_projection.lincomb.')
    
    
    return d
    
if __name__ == '__main__':
    pass
    
    
@function
def uf(A=None,*args,**kwargs):
    varargin = uf.varargin
    nargin = uf.nargin

    L,unused,R=svd(A,0,nargout=3)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:195
    
    A=dot(L,R.T)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:196
    return A
    
if __name__ == '__main__':
    pass
    
    
@function
def nested_sylvester(sym_mat=None,asym_mat=None,*args,**kwargs):
    varargin = nested_sylvester.varargin
    nargin = nested_sylvester.nargin

    # omega=nested_sylvester(sym_mat,asym_mat)
    # This function solves the system of nested Sylvester equations:
    
    #     X*sym_mat + sym_mat*X = asym_mat
    #     Omega*sym_mat+sym_mat*Omega = X
    # Mishra, Meyer, Bonnabel and Sepulchre, 'Fixed-rank matrix factorizations and Riemannian low-rank optimization'
    
    # Uses built-in lyap function, but does not exploit the fact that it's
    # twice the same sym_mat matrix that comes into play.
    
    X=lyap(sym_mat,- asym_mat)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:210
    omega=lyap(sym_mat,- X)
# fixedrank/fixedrankfactory_2factors_subspace_projection.m:211
    return omega
    
if __name__ == '__main__':
    pass
    