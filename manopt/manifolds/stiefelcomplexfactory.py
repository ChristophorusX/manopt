# Autogenerated with SMOP 
from smop.core import *
# stiefel/stiefelcomplexfactory.m

    
@function
def stiefelcomplexfactory(n=None,p=None,k=None,*args,**kwargs):
    varargin = stiefelcomplexfactory.varargin
    nargin = stiefelcomplexfactory.nargin

    # Returns a manifold struct. to optimize over complex orthonormal matrices.
    
    # function M = stiefelcomplexfactory(n, p)
# function M = stiefelcomplexfactory(n, p, k)
    
    # The complex Stiefel manifold is the set of complex orthonormal nxp
# matrices. If k is larger than 1, this is the Cartesian product of the
# complex Stiefel manifold taken k times. The metric is such that the
# manifold is a Riemannian submanifold of C^nxp equipped with the usual
# real-trace inner product, that is, it is the usual metric for the complex
# plane identified with R^2.
    
    # Points are represented as matrices X of size n x p x k (or n x p if k=1,
# which is the default) such that each complex n x p matrix is orthonormal,
# i.e., X'*X = eye(p) if k = 1, or X(:, :, i)' * X(:, :, i) = eye(p) for
# i = 1 : k if k > 1. Tangent vectors are represented as matrices the same
# size as points.
    
    # By default, k = 1.
    
    
    # Please cite the Manopt paper as well as either of these research papers
# pertaining to this specific geometry:
# @InProceedings{sato2013complex,
#   Title        = {A complex singular value decomposition algorithm based on the {R}iemannian {N}ewton method},
#   Author       = {Sato, H. and Iwai, T.},
#   Booktitle    = {Decision and Control ({CDC}), 2013 {IEEE} 52nd Annual Conference on},
#   Year         = {2013},
#   Organization = {IEEE},
#   Pages        = {2972--2978}
# }
# @InProceedings{sato2014Riemannian,
#   Title        = {{R}iemannian conjugate gradient method for complex singular value decomposition problem},
#   Author       = {Sato, H.},
#   Booktitle    = {Decision and Control ({CDC}), 2014 {IEEE} 53rd Annual Conference on},
#   Year         = {2014},
#   Organization = {IEEE},
#   Pages        = {5849--5854}
# }
    
    
    # See also: stiefelfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Hiroyuki Sato, April 27, 2015.
# Contributors: 
# Change log:
    
    if logical_not(exist('k','var')) or isempty(k):
        k=1
# stiefel/stiefelcomplexfactory.m:51
    
    
    if k == 1:
        M.name = copy(lambda : sprintf('Complex Stiefel manifold St(%d, %d)',n,p))
# stiefel/stiefelcomplexfactory.m:55
    else:
        if k > 1:
            M.name = copy(lambda : sprintf('Product complex Stiefel manifold St(%d, %d)^%d',n,p,k))
# stiefel/stiefelcomplexfactory.m:57
        else:
            error('k must be an integer no less than 1.')
    
    
    M.dim = copy(lambda : dot(k,(dot(dot(2,n),p) - p ** 2)))
# stiefel/stiefelcomplexfactory.m:62
    
    
    M.inner = copy(lambda x=None,d1=None,d2=None: real(dot(ravel(d1).T,ravel(d2))))
# stiefel/stiefelcomplexfactory.m:64
    
    
    M.norm = copy(lambda x=None,d=None: norm(ravel(d)))
# stiefel/stiefelcomplexfactory.m:66
    M.dist = copy(lambda x=None,y=None: error('stiefel.dist not implemented yet.'))
# stiefel/stiefelcomplexfactory.m:68
    M.typicaldist = copy(lambda : sqrt(dot(p,k)))
# stiefel/stiefelcomplexfactory.m:70
    M.proj = copy(projection)
# stiefel/stiefelcomplexfactory.m:72
    
@function
def projection(X=None,U=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    
    XHU=multiprod(multihconj(X),U)
# stiefel/stiefelcomplexfactory.m:75
    
    herXHU=multiherm(XHU)
# stiefel/stiefelcomplexfactory.m:76
    
    Up=U - multiprod(X,herXHU)
# stiefel/stiefelcomplexfactory.m:77
    
    
    return Up
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(M.proj)
# stiefel/stiefelcomplexfactory.m:81
    
    # Riemannian gradient amounts to an orthogonal projection.
    M.egrad2rgrad = copy(M.proj)
# stiefel/stiefelcomplexfactory.m:85
    M.ehess2rhess = copy(ehess2rhess)
# stiefel/stiefelcomplexfactory.m:87
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,H=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    XHG=multiprod(multihconj(X),egrad)
# stiefel/stiefelcomplexfactory.m:89
    
    herXHG=multiherm(XHG)
# stiefel/stiefelcomplexfactory.m:90
    
    HherXHG=multiprod(H,herXHG)
# stiefel/stiefelcomplexfactory.m:91
    
    rhess=projection(X,ehess - HherXHG)
# stiefel/stiefelcomplexfactory.m:92
    
    return rhess
    
if __name__ == '__main__':
    pass
    
    
    M.retr = copy(retraction)
# stiefel/stiefelcomplexfactory.m:95
    
@function
def retraction(X=None,U=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# stiefel/stiefelcomplexfactory.m:98
    
    Y=X + dot(t,U)
# stiefel/stiefelcomplexfactory.m:100
    for i in arange(1,k).reshape(-1):
        Q,R=qr(Y[:,:,i],0,nargout=2)
# stiefel/stiefelcomplexfactory.m:102
        # of some columns, which should never happen in modern Matlab
            # versions but may be an issue with older versions.
        Y[:,:,i]=dot(Q,diag(sign(sign(diag(R)) + 0.5)))
# stiefel/stiefelcomplexfactory.m:106
    
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# stiefel/stiefelcomplexfactory.m:110
    
@function
def exponential(X=None,U=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin == 2:
        t=1
# stiefel/stiefelcomplexfactory.m:113
    
    tU=dot(t,U)
# stiefel/stiefelcomplexfactory.m:115
    Y=zeros(size(X))
# stiefel/stiefelcomplexfactory.m:116
    for i in arange(1,k).reshape(-1):
        # From a formula by Ross Lippert, Example 5.4.2 in AMS08.
        Xi=X[:,:,i]
# stiefel/stiefelcomplexfactory.m:119
        Ui=tU[:,:,i]
# stiefel/stiefelcomplexfactory.m:120
        Y[:,:,i]=dot(dot(cat(Xi,Ui),expm(cat([dot(Xi.T,Ui),dot(- Ui.T,Ui)],[eye(p),dot(Xi.T,Ui)]))),cat([expm(dot(- Xi.T,Ui))],[zeros(p)]))
# stiefel/stiefelcomplexfactory.m:121
    
    
    return Y
    
if __name__ == '__main__':
    pass
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(cat([real(ravel(X))],[imag(ravel(X))]))))
# stiefel/stiefelcomplexfactory.m:128
    
    
    M.rand = copy(random)
# stiefel/stiefelcomplexfactory.m:130
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    X=zeros(n,p,k)
# stiefel/stiefelcomplexfactory.m:132
    for i in arange(1,k).reshape(-1):
        Q,unused=qr(randn(n,p) + dot(1j,randn(n,p)),0,nargout=2)
# stiefel/stiefelcomplexfactory.m:134
        X[:,:,i]=Q
# stiefel/stiefelcomplexfactory.m:135
    
    return X
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# stiefel/stiefelcomplexfactory.m:139
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    U=projection(X,randn(n,p,k) + dot(1j,randn(n,p,k)))
# stiefel/stiefelcomplexfactory.m:141
    
    U=U / norm(ravel(U))
# stiefel/stiefelcomplexfactory.m:142
    return U
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# stiefel/stiefelcomplexfactory.m:145
    M.zerovec = copy(lambda x=None: zeros(n,p,k))
# stiefel/stiefelcomplexfactory.m:147
    M.transp = copy(lambda x1=None,x2=None,d=None: projection(x2,d))
# stiefel/stiefelcomplexfactory.m:149
    M.vec = copy(lambda x=None,u_mat=None: cat([real(ravel(u_mat))],[imag(ravel(u_mat))]))
# stiefel/stiefelcomplexfactory.m:151
    M.mat = copy(lambda x=None,u_vec=None: reshape(u_vec[1:(dot(dot(n,p),k))] + dot(1j,u_vec[(dot(dot(n,p),k) + 1):end()]),cat(n,p,k)))
# stiefel/stiefelcomplexfactory.m:152
    M.vecmatareisometries = copy(lambda : true)
# stiefel/stiefelcomplexfactory.m:153
    
    return U
    
if __name__ == '__main__':
    pass
    