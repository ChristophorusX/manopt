# Autogenerated with SMOP 
from smop.core import *
# symfixedrank/spectrahedronfactory.m

    
@function
def spectrahedronfactory(n=None,k=None,*args,**kwargs):
    varargin = spectrahedronfactory.varargin
    nargin = spectrahedronfactory.nargin

    # Manifold of n-by-n symmetric positive semidefinite matrices of rank k
# with trace (sum of diagonal elements) equal to 1.
    
    # function M = spectrahedronfactory(n, k)
    
    # A point X on the manifold is parameterized as YY^T where Y is a matrix of
# size nxk. As such, X is symmetric, positive semidefinite. We restrict to
# full-rank Y's, such that X has rank exactly k. The point X is numerically
# represented by Y (this is more efficient than working with X, which may
# be big). Tangent vectors are represented as matrices of the same size as
# Y, call them Ydot, so that Xdot = Y Ydot' + Ydot Y and trace(Xdot) == 0.
# The metric is the canonical Euclidean metric on Y.
# 
# The trace constraint on X (trace(X) == 1) translates to a unit Frobenius
# norm constraint on Y: trace(X) = norm(Y, 'fro')^2 == 1. The set of such
# Y's forms the unit sphere in R^(nxk): see spherefactory. But because for
# any orthogonal Q of size k, it holds that (YQ)(YQ)' = YY', we "group" all
# matrices of the form YQ in an equivalence class. The set of equivalence
# classes is a Riemannian quotient manifold, implemented here.
    
    
    # Note that this geometry formally breaks down at rank-deficient Y's.
# As an alternative, you may use the sphere manifold (it has larger
# dimension (by 1), but does not break down at rank drop.)
    
    # The geometry is taken from the 2010 paper:
# M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,
# "Low-Rank Optimization on the Cone of Positive Semidefinite Matrices".
# Paper link: http://www.di.ens.fr/~fbach/journee2010_sdp.pdf
# 
# 
# Please cite the Manopt paper as well as the research paper:
#     @Article{journee2010low,
#       Title   = {Low-rank optimization on the cone of positive semidefinite matrices},
#       Author  = {Journ{\'e}e, M. and Bach, F. and Absil, P.-A. and Sepulchre, R.},
#       Journal = {SIAM Journal on Optimization},
#       Year    = {2010},
#       Number  = {5},
#       Pages   = {2327--2351},
#       Volume  = {20},
#       Doi     = {10.1137/080731359}
#     }
#
    
    # See also: spherefactory elliptopefactory symfixedrankYYfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Bamdev Mishra, July 11, 2013.
# Contributors: Nicolas Boumal
# Change log:
    
    #   April 2, 2015 (NB):
#       Replaced trace(A'*B) by A(:)'*B(:) (equivalent but faster).
#       Updated documentation.
    
    
    
    M.name = copy(lambda : sprintf('YY\' quotient manifold of %dx%d psd matrices of rank %d with trace 1',n,k))
# symfixedrank/spectrahedronfactory.m:59
    M.dim = copy(lambda : dot(n,k) - 1 - dot(k,(k - 1)) / 2)
# symfixedrank/spectrahedronfactory.m:61
    
    M.inner = copy(lambda Y=None,eta=None,zeta=None: dot(ravel(eta).T,ravel(zeta)))
# symfixedrank/spectrahedronfactory.m:64
    M.norm = copy(lambda Y=None,eta=None: sqrt(M.inner(Y,eta,eta)))
# symfixedrank/spectrahedronfactory.m:66
    M.dist = copy(lambda Y=None,Z=None: error('spectrahedronfactory.dist not implemented yet.'))
# symfixedrank/spectrahedronfactory.m:68
    M.typicaldist = copy(lambda : dot(10,k))
# symfixedrank/spectrahedronfactory.m:70
    M.proj = copy(projection)
# symfixedrank/spectrahedronfactory.m:72
    
@function
def projection(Y=None,eta=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    # Projection onto the tangent space, i.e., on the tangent space of
        # ||Y|| = 1
    
    eta=eta - dot((dot(ravel(eta).T,ravel(Y))),Y)
# symfixedrank/spectrahedronfactory.m:77
    
    YtY=dot(Y.T,Y)
# symfixedrank/spectrahedronfactory.m:80
    SS=copy(YtY)
# symfixedrank/spectrahedronfactory.m:81
    AS=dot(Y.T,eta) - dot(eta.T,Y)
# symfixedrank/spectrahedronfactory.m:82
    Omega=lyap(SS,- AS)
# symfixedrank/spectrahedronfactory.m:83
    etaproj=eta - dot(Y,Omega)
# symfixedrank/spectrahedronfactory.m:84
    return etaproj
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(M.proj)
# symfixedrank/spectrahedronfactory.m:87
    M.tangent2ambient = copy(lambda Y=None,eta=None: eta)
# symfixedrank/spectrahedronfactory.m:88
    M.retr = copy(retraction)
# symfixedrank/spectrahedronfactory.m:90
    
@function
def retraction(Y=None,eta=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# symfixedrank/spectrahedronfactory.m:93
    
    Ynew=Y + dot(t,eta)
# symfixedrank/spectrahedronfactory.m:95
    Ynew=Ynew / norm(Ynew,'fro')
# symfixedrank/spectrahedronfactory.m:96
    return Ynew
    
if __name__ == '__main__':
    pass
    
    
    
    M.egrad2rgrad = copy(lambda Y=None,eta=None: eta - dot((dot(ravel(eta).T,ravel(Y))),Y))
# symfixedrank/spectrahedronfactory.m:100
    M.ehess2rhess = copy(ehess2rhess)
# symfixedrank/spectrahedronfactory.m:102
    
@function
def ehess2rhess(Y=None,egrad=None,ehess=None,eta=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    
    # Directional derivative of the Riemannian gradient
    Hess=ehess - dot((dot(ravel(egrad).T,ravel(Y))),eta) - dot(((dot(ravel(ehess).T,ravel(Y))) + (dot(ravel(eta).T,ravel(egrad)))),Y)
# symfixedrank/spectrahedronfactory.m:106
    Hess=Hess - dot((dot(ravel(Hess).T,ravel(Y))),Y)
# symfixedrank/spectrahedronfactory.m:107
    
    Hess=M.proj(Y,Hess)
# symfixedrank/spectrahedronfactory.m:110
    return Hess
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# symfixedrank/spectrahedronfactory.m:114
    
@function
def exponential(Y=None,eta=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin < 3:
        t=1.0
# symfixedrank/spectrahedronfactory.m:117
    
    
    Ynew=retraction(Y,eta,t)
# symfixedrank/spectrahedronfactory.m:120
    warning('manopt:spectrahedronfactory:exp',cat('Exponential for fixed rank spectrahedron ','manifold not implenented yet. Used retraction instead.'))
    return Ynew
    
if __name__ == '__main__':
    pass
    
    
    # Notice that the hash of two equivalent points will be different...
    M.hash = copy(lambda Y=None: cat('z',hashmd5(ravel(Y))))
# symfixedrank/spectrahedronfactory.m:127
    M.rand = copy(random)
# symfixedrank/spectrahedronfactory.m:129
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    Y=randn(n,k)
# symfixedrank/spectrahedronfactory.m:132
    Y=Y / norm(Y,'fro')
# symfixedrank/spectrahedronfactory.m:133
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# symfixedrank/spectrahedronfactory.m:136
    
@function
def randomvec(Y=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    eta=randn(n,k)
# symfixedrank/spectrahedronfactory.m:138
    eta=projection(Y,eta)
# symfixedrank/spectrahedronfactory.m:139
    nrm=M.norm(Y,eta)
# symfixedrank/spectrahedronfactory.m:140
    eta=eta / nrm
# symfixedrank/spectrahedronfactory.m:141
    return eta
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# symfixedrank/spectrahedronfactory.m:144
    M.zerovec = copy(lambda Y=None: zeros(n,k))
# symfixedrank/spectrahedronfactory.m:146
    M.transp = copy(lambda Y1=None,Y2=None,d=None: projection(Y2,d))
# symfixedrank/spectrahedronfactory.m:148
    M.vec = copy(lambda Y=None,u_mat=None: ravel(u_mat))
# symfixedrank/spectrahedronfactory.m:150
    M.mat = copy(lambda Y=None,u_vec=None: reshape(u_vec,cat(n,k)))
# symfixedrank/spectrahedronfactory.m:151
    M.vecmatareisometries = copy(lambda : true)
# symfixedrank/spectrahedronfactory.m:152
    return eta
    
if __name__ == '__main__':
    pass
    