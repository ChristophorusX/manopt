# Autogenerated with SMOP 
from smop.core import *
# symfixedrank/sympositivedefinitefactory.m

    
@function
def sympositivedefinitefactory(n=None,*args,**kwargs):
    varargin = sympositivedefinitefactory.varargin
    nargin = sympositivedefinitefactory.nargin

    # Manifold of n-by-n symmetric positive definite matrices with
# the bi-invariant geometry.
    
    # function M = sympositivedefinitefactory(n)
    
    # A point X on the manifold is represented as a symmetric positive definite
# matrix X (nxn). Tangent vectors are symmetric matrices of the same size
# (but not necessarily definite).
    
    # The Riemannian metric is the bi-invariant metric, described notably in
# Chapter 6 of the 2007 book "Positive definite matrices"
# by Rajendra Bhatia, Princeton University Press.
    
    
    # The retraction / exponential map involves expm (the matrix exponential).
# If too large a vector is retracted / exponentiated (e.g., a solver tries
# to make too big a step), this may result in NaN's in the returned point,
# which most likely would lead to NaN's in the cost / gradient / ... and
# will result in failure of the optimization. For trustregions, this can be
# controlled by setting options.Delta0 and options.Delta_bar, to prevent
# too large steps.
    
    
    # Note also that many of the functions involve solving linear systems in X
# (a point on the manifold), taking matrix exponentals and logarithms, etc.
# It could therefore be beneficial to do some precomputation on X (an
# eigenvalue decomposition for example) and store both X and the
# preprocessing in a structure. This would require modifying the present
# factory to work with such structures to represent both points and tangent
# vectors. We omit this in favor of simplicity, but it may be good to keep
# this in mind if efficiency becomes an issue in your application.
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Bamdev Mishra, August 29, 2013.
# Contributors: Nicolas Boumal
# Change log:
    
    #   March 5, 2014 (NB)
#       There were a number of mistakes in the code owing to the tacit
#       assumption that if X and eta are symmetric, then X\eta is
#       symmetric too, which is not the case. See discussion on the Manopt
#       forum started on Jan. 19, 2014. Functions norm, dist, exp and log
#       were modified accordingly. Furthermore, they only require matrix
#       inversion (as well as matrix log or matrix exp), not matrix square
#       roots or their inverse.
# 
#   July 28, 2014 (NB)
#       The dim() function returned n*(n-1)/2 instead of n*(n+1)/2.
#       Implemented proper parallel transport from Sra and Hosseini (not
#       used by default).
#       Also added symmetrization in exp and log (to be sure).
# 
#   April 3, 2015 (NB):
#       Replaced trace(A*B) by a faster equivalent that does not compute
#       the whole product A*B, for inner product, norm and distance.
    
    symm=lambda X=None: dot(0.5,(X + X.T))
# symfixedrank/sympositivedefinitefactory.m:58
    M.name = copy(lambda : sprintf('Symmetric positive definite geometry of %dx%d matrices',n,n))
# symfixedrank/sympositivedefinitefactory.m:60
    M.dim = copy(lambda : dot(n,(n + 1)) / 2)
# symfixedrank/sympositivedefinitefactory.m:62
    
    vec=lambda A=None: ravel(A)
# symfixedrank/sympositivedefinitefactory.m:65
    trinner=lambda A=None,B=None: dot(vec[A.T].T,vec[B])
# symfixedrank/sympositivedefinitefactory.m:66
    
    trnorm=lambda A=None: sqrt(trinner[A,A])
# symfixedrank/sympositivedefinitefactory.m:67
    
    
    # Choice of the metric on the orthonormal space is motivated by the
    # symmetry present in the space. The metric on the positive definite
    # cone is its natural bi-invariant metric.
	# The result is equal to: trace( (X\eta) * (X\zeta) )
    M.inner = copy(lambda X=None,eta=None,zeta=None: trinner[numpy.linalg.solve(X,eta),numpy.linalg.solve(X,zeta)])
# symfixedrank/sympositivedefinitefactory.m:73
    
    # The result is equal to: sqrt(trace((X\eta)^2))
    # There should be no need to take the real part, but rounding errors
    # may cause a small imaginary part to appear, so we discard it.
    M.norm = copy(lambda X=None,eta=None: real(trnorm[numpy.linalg.solve(X,eta)]))
# symfixedrank/sympositivedefinitefactory.m:79
    
    # Same remark about taking the real part.
    M.dist = copy(lambda X=None,Y=None: real(trnorm[real(logm(numpy.linalg.solve(X,Y)))]))
# symfixedrank/sympositivedefinitefactory.m:83
    M.typicaldist = copy(lambda : sqrt(dot(n,(n + 1)) / 2))
# symfixedrank/sympositivedefinitefactory.m:86
    M.egrad2rgrad = copy(egrad2rgrad)
# symfixedrank/sympositivedefinitefactory.m:89
    
@function
def egrad2rgrad(X=None,eta=None,*args,**kwargs):
    varargin = egrad2rgrad.varargin
    nargin = egrad2rgrad.nargin

    eta=dot(dot(X,symm[eta]),X)
# symfixedrank/sympositivedefinitefactory.m:91
    return eta
    
if __name__ == '__main__':
    pass
    
    
    
    M.ehess2rhess = copy(ehess2rhess)
# symfixedrank/sympositivedefinitefactory.m:95
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,eta=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    # Directional derivatives of the Riemannian gradient
    Hess=dot(dot(X,symm[ehess]),X) + dot(2,symm[dot(dot(eta,symm[egrad]),X)])
# symfixedrank/sympositivedefinitefactory.m:98
    
    Hess=Hess - symm[dot(dot(eta,symm[egrad]),X)]
# symfixedrank/sympositivedefinitefactory.m:101
    return Hess
    
if __name__ == '__main__':
    pass
    
    
    
    M.proj = copy(lambda X=None,eta=None: symm[eta])
# symfixedrank/sympositivedefinitefactory.m:105
    M.tangent = copy(M.proj)
# symfixedrank/sympositivedefinitefactory.m:107
    M.tangent2ambient = copy(lambda X=None,eta=None: eta)
# symfixedrank/sympositivedefinitefactory.m:108
    M.retr = copy(exponential)
# symfixedrank/sympositivedefinitefactory.m:110
    M.exp = copy(exponential)
# symfixedrank/sympositivedefinitefactory.m:112
    
@function
def exponential(X=None,eta=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin < 3:
        t=1.0
# symfixedrank/sympositivedefinitefactory.m:115
    
    # The symm() and real() calls are mathematically not necessary but
        # are numerically necessary.
    Y=symm[dot(X,real(expm(numpy.linalg.solve(X,(dot(t,eta))))))]
# symfixedrank/sympositivedefinitefactory.m:119
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.log = copy(logarithm)
# symfixedrank/sympositivedefinitefactory.m:122
    
@function
def logarithm(X=None,Y=None,*args,**kwargs):
    varargin = logarithm.varargin
    nargin = logarithm.nargin

    # Same remark regarding the calls to symm() and real().
    H=symm[dot(X,real(logm(numpy.linalg.solve(X,Y))))]
# symfixedrank/sympositivedefinitefactory.m:125
    return H
    
if __name__ == '__main__':
    pass
    
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(ravel(X))))
# symfixedrank/sympositivedefinitefactory.m:128
    
    # certain distribution. The particular choice of a distribution is of
    # course arbitrary, and specific applications might require different
    # ones.
    M.rand = copy(random)
# symfixedrank/sympositivedefinitefactory.m:134
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    D=diag(1 + rand(n,1))
# symfixedrank/sympositivedefinitefactory.m:136
    Q,R=qr(randn(n),nargout=2)
# symfixedrank/sympositivedefinitefactory.m:137
    
    X=dot(dot(Q,D),Q.T)
# symfixedrank/sympositivedefinitefactory.m:138
    return X
    
if __name__ == '__main__':
    pass
    
    
    # Generate a uniformly random unit-norm tangent vector at X.
    M.randvec = copy(randomvec)
# symfixedrank/sympositivedefinitefactory.m:142
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    eta=symm[randn(n)]
# symfixedrank/sympositivedefinitefactory.m:144
    nrm=M.norm(X,eta)
# symfixedrank/sympositivedefinitefactory.m:145
    eta=eta / nrm
# symfixedrank/sympositivedefinitefactory.m:146
    return eta
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# symfixedrank/sympositivedefinitefactory.m:149
    M.zerovec = copy(lambda X=None: zeros(n))
# symfixedrank/sympositivedefinitefactory.m:151
    
    # are the set of symmetric matrices, so that the identity is a sort of
    # vector transport. It may perform poorly if the origin and target (X1
    # and X2) are far apart though. This should not be the case for typical
    # optimization algorithms, which perform small steps.
    M.transp = copy(lambda X1=None,X2=None,eta=None: eta)
# symfixedrank/sympositivedefinitefactory.m:158
    
    # work by Sra and Hosseini: "Conic geometric optimisation on the
    # manifold of positive definite matrices", to appear in SIAM J. Optim.
    # in 2015; also available here: http://arxiv.org/abs/1312.1039
    # This will not be used by default. To force the use of this transport,
    # execute "M.transp = M.paralleltransp;" on your M returned by the
    # present factory.
    M.paralleltransp = copy(parallel_transport)
# symfixedrank/sympositivedefinitefactory.m:167
    
@function
def parallel_transport(X=None,Y=None,eta=None,*args,**kwargs):
    varargin = parallel_transport.varargin
    nargin = parallel_transport.nargin

    E=sqrtm((Y / X))
# symfixedrank/sympositivedefinitefactory.m:169
    zeta=dot(dot(E,eta),E.T)
# symfixedrank/sympositivedefinitefactory.m:170
    return zeta
    
if __name__ == '__main__':
    pass
    
    
    # vec and mat are not isometries, because of the unusual inner metric.
    M.vec = copy(lambda X=None,U=None: ravel(U))
# symfixedrank/sympositivedefinitefactory.m:174
    M.mat = copy(lambda X=None,u=None: reshape(u,n,n))
# symfixedrank/sympositivedefinitefactory.m:175
    M.vecmatareisometries = copy(lambda : false)
# symfixedrank/sympositivedefinitefactory.m:176
    return zeta
    
if __name__ == '__main__':
    pass
    