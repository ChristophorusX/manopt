# Autogenerated with SMOP 
from smop.core import *
# stiefel/stiefelstackedfactory.m

    
@function
def stiefelstackedfactory(m=None,d=None,k=None,*args,**kwargs):
    varargin = stiefelstackedfactory.varargin
    nargin = stiefelstackedfactory.nargin

    # Stiefel(k, d)^m, represented as matrices of size m*d-by-k.
    
    # function M = stiefelstackedfactory(m, d, k)
    
    # Points on this manifold are matrices Y of size n x k, with n = m*d.
# Y is thought of as m matrices of size d x k each, stacked on top of each
# other. Call them Y1, ..., Ym. Each Yi is an orthonormal matrix, that is,
# its d rows are unit norm and are orthogonal to each other. Thus, this
# geometry is a product of Stiefel manifolds.
# 
# To easily transform matrices Y to 3D arrays Y3 of size d x k x m such
# that each slice Y3(:, :, i) corresponds to one of the matrices Yi, use
# the functions
# 
#    Y3 = M.to3D(Y)   and   Y = M.to2D(Y3).
    
    # The ambient space R^(nxk) is endowed with the usual inner product
# <A, B> = trace(A'*B). This inner product is restricted to the tangent
# spaces of the present manifold, thus making it a Riemannian submanifold
# of the Euclidean space R^(nxk). Tangent vectors are represented as
# matrices of the same size as Y, and can likewise be converted to 3D
# arrays and back using to3D() and to2D().
    
    # In dealing with this geometry, especially when dealing with the 3D array
# representations of points and tangent vectors, the tools multiprod,
# multitransp, multitrace, multiscale etc. available in Manopt are often
# useful.
    
    # See also: stiefelfactory obliquefactory multiprod multitransp
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, May 4, 2015.
# Contributors: 
# Change log:
    
    assert_(k >= d,'k must be at least as large as d.')
    n=dot(m,d)
# stiefel/stiefelstackedfactory.m:39
    M.name = copy(lambda : sprintf('Manifold of %d orthonormal matrices of size %dx%d, stacked',m,d,k))
# stiefel/stiefelstackedfactory.m:41
    M.dim = copy(lambda : dot(m,(dot(k,d) - dot(dot(0.5,d),(d + 1)))))
# stiefel/stiefelstackedfactory.m:43
    M.size = copy(lambda : cat(m,d,k))
# stiefel/stiefelstackedfactory.m:45
    M.inner = copy(lambda x=None,d1=None,d2=None: dot(ravel(d1).T,ravel(d2)))
# stiefel/stiefelstackedfactory.m:47
    M.norm = copy(lambda x=None,d=None: norm(ravel(d)))
# stiefel/stiefelstackedfactory.m:49
    M.dist = copy(lambda x=None,y=None: error('stiefelstackedfactory.dist not implemented yet.'))
# stiefel/stiefelstackedfactory.m:51
    M.typicaldist = copy(lambda : sqrt(M.dim()))
# stiefel/stiefelstackedfactory.m:53
    
    M.to2D = copy(to2D)
# stiefel/stiefelstackedfactory.m:56
    
@function
def to2D(A3=None,*args,**kwargs):
    varargin = to2D.varargin
    nargin = to2D.nargin

    A2=reshape(multitransp(A3),cat(k,dot(m,d))).T
# stiefel/stiefelstackedfactory.m:58
    return A2
    
if __name__ == '__main__':
    pass
    
    # Convert an nxk matrix to a dxkxm matrix
    M.to3D = copy(to3D)
# stiefel/stiefelstackedfactory.m:62
    
@function
def to3D(A2=None,*args,**kwargs):
    varargin = to3D.varargin
    nargin = to3D.nargin

    A3=multitransp(reshape(A2.T,cat(k,d,m)))
# stiefel/stiefelstackedfactory.m:64
    return A3
    
if __name__ == '__main__':
    pass
    
    # Given 2 3D matrices A and B of size dxkxm, returns a 3D matrix C of
    # size dxdxm such that each slice C(:, :, i) is the symmetric part of
    # the product A(:, :, i) * B(:, :, i)'. The name is short for
    # "symmetric-block-diagonal", because if A and B were transformed to
    # their 2D equivalents via to2D, then the output would contain the
    # symmetric parts of the diagonal blocks of A*B'.
    M.symbdiag = copy(symbdiag)
# stiefel/stiefelstackedfactory.m:73
    
@function
def symbdiag(A=None,B=None,*args,**kwargs):
    varargin = symbdiag.varargin
    nargin = symbdiag.nargin

    C=multisym(multiprod(A,multitransp(B)))
# stiefel/stiefelstackedfactory.m:75
    return C
    
if __name__ == '__main__':
    pass
    
    
    # Orthogonal projection from the ambient space R^(nxk) to the tangent
    # space at X.
    M.proj = copy(projection)
# stiefel/stiefelstackedfactory.m:80
    
@function
def projection(Y=None,Z=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    Y3=to3D(Y)
# stiefel/stiefelstackedfactory.m:82
    Z3=to3D(Z)
# stiefel/stiefelstackedfactory.m:83
    Lambda=symbdiag(Y3,Z3)
# stiefel/stiefelstackedfactory.m:84
    Zt3=Z3 - multiprod(Lambda,Y3)
# stiefel/stiefelstackedfactory.m:85
    Zt=to2D(Zt3)
# stiefel/stiefelstackedfactory.m:86
    return Zt
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(M.proj)
# stiefel/stiefelstackedfactory.m:89
    M.egrad2rgrad = copy(M.proj)
# stiefel/stiefelstackedfactory.m:91
    M.ehess2rhess = copy(ehess2rhess)
# stiefel/stiefelstackedfactory.m:93
    
@function
def ehess2rhess(Y=None,egrad=None,ehess=None,Ydot=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    Y3=to3D(Y)
# stiefel/stiefelstackedfactory.m:95
    Ydot3=to3D(Ydot)
# stiefel/stiefelstackedfactory.m:96
    egrad3=to3D(egrad)
# stiefel/stiefelstackedfactory.m:97
    C=symbdiag(Y3,egrad3)
# stiefel/stiefelstackedfactory.m:98
    CYdot=to2D(multiprod(C,Ydot3))
# stiefel/stiefelstackedfactory.m:99
    rhess=projection(Y,ehess - CYdot)
# stiefel/stiefelstackedfactory.m:100
    return rhess
    
if __name__ == '__main__':
    pass
    
    
    M.retr = copy(retraction)
# stiefel/stiefelstackedfactory.m:103
    
@function
def retraction(Y=None,U=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# stiefel/stiefelstackedfactory.m:106
    
    Y=Y + dot(t,U)
# stiefel/stiefelstackedfactory.m:108
    Y3=to3D(Y)
# stiefel/stiefelstackedfactory.m:109
    for i in arange(1,m).reshape(-1):
        # Orthonormalize the rows of Y3(:, :, i):
        u,s,v=svd(Y3[:,:,i],'econ',nargout=3)
# stiefel/stiefelstackedfactory.m:112
        Y3[:,:,i]=dot(u,v.T)
# stiefel/stiefelstackedfactory.m:113
        # The instruction with the signs of R assures we are not
            # flipping signs of some columns.
            # [Q, R] = qr(Y3(:, :, i)', 0);
            # Y3(:, :, i) = (Q * diag(sign(sign(diag(R))+.5)))';
    
    Y=to2D(Y3)
# stiefel/stiefelstackedfactory.m:120
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# stiefel/stiefelstackedfactory.m:123
    
@function
def exponential(Y=None,U=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin == 2:
        t=1
# stiefel/stiefelstackedfactory.m:126
    
    tU3=multitransp(to3D(dot(t,U)))
# stiefel/stiefelstackedfactory.m:128
    Y3=multitransp(to3D(Y))
# stiefel/stiefelstackedfactory.m:129
    
    for i in arange(1,m).reshape(-1):
        X=Y3[:,:,i]
# stiefel/stiefelstackedfactory.m:132
        Z=tU3[:,:,i]
# stiefel/stiefelstackedfactory.m:133
        Y3[:,:,i]=dot(dot(cat(X,Z),expm(cat([dot(X.T,Z),dot(- Z.T,Z)],[eye(d),dot(X.T,Z)]))),cat([expm(dot(- X.T,Z))],[zeros(d)]))
# stiefel/stiefelstackedfactory.m:134
        u,s,v=svd(Y3[:,:,i],'econ',nargout=3)
# stiefel/stiefelstackedfactory.m:138
        Y3[:,:,i]=dot(u,v.T)
# stiefel/stiefelstackedfactory.m:139
    
    Y=to2D(multitransp(Y3))
# stiefel/stiefelstackedfactory.m:141
    return Y
    
if __name__ == '__main__':
    pass
    
    M.hash = copy(lambda Y=None: cat('z',hashmd5(ravel(Y))))
# stiefel/stiefelstackedfactory.m:144
    M.rand = copy(random)
# stiefel/stiefelstackedfactory.m:146
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    Y3=zeros(d,k,m)
# stiefel/stiefelstackedfactory.m:148
    for i in arange(1,m).reshape(-1):
        Q,unused=qr(randn(k,d),0,nargout=2)
# stiefel/stiefelstackedfactory.m:150
        Y3[:,:,i]=Q.T
# stiefel/stiefelstackedfactory.m:151
    
    Y=to2D(Y3)
# stiefel/stiefelstackedfactory.m:153
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# stiefel/stiefelstackedfactory.m:156
    
@function
def randomvec(Y=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    U=projection(Y,randn(n,k))
# stiefel/stiefelstackedfactory.m:158
    U=U / M.norm(Y,U)
# stiefel/stiefelstackedfactory.m:159
    return U
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# stiefel/stiefelstackedfactory.m:162
    M.zerovec = copy(lambda x=None: zeros(n,k))
# stiefel/stiefelstackedfactory.m:164
    M.transp = copy(lambda x1=None,x2=None,u=None: projection(x2,u))
# stiefel/stiefelstackedfactory.m:166
    M.vec = copy(lambda x=None,u_mat=None: ravel(u_mat))
# stiefel/stiefelstackedfactory.m:168
    M.mat = copy(lambda x=None,u_vec=None: reshape(u_vec,cat(n,k)))
# stiefel/stiefelstackedfactory.m:169
    M.vecmatareisometries = copy(lambda : true)
# stiefel/stiefelstackedfactory.m:170
    return U
    
if __name__ == '__main__':
    pass
    