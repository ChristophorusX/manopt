# Autogenerated with SMOP 
from smop.core import *
# fixedrank/fixedrankembeddedfactory.m

    
@function
def fixedrankembeddedfactory(m=None,n=None,k=None,*args,**kwargs):
    varargin = fixedrankembeddedfactory.varargin
    nargin = fixedrankembeddedfactory.nargin

    # Manifold struct to optimize fixed-rank matrices w/ an embedded geometry.
    
    # function M = fixedrankembeddedfactory(m, n, k)
    
    # Manifold of m-by-n real matrices of fixed rank k. This follows the
# embedded geometry described in Bart Vandereycken's 2013 paper:
# "Low-rank matrix completion by Riemannian optimization".
# 
# Paper link: http://arxiv.org/pdf/1209.3834.pdf
    
    # A point X on the manifold is represented as a structure with three
# fields: U, S and V. The matrices U (mxk) and V (nxk) are orthonormal,
# while the matrix S (kxk) is any /diagonal/, full rank matrix.
# Following the SVD formalism, X = U*S*V'. Note that the diagonal entries
# of S are not constrained to be nonnegative.
    
    # Tangent vectors are represented as a structure with three fields: Up, M
# and Vp. The matrices Up (mxk) and Vp (mxk) obey Up'*U = 0 and Vp'*V = 0.
# The matrix M (kxk) is arbitrary. Such a structure corresponds to the
# following tangent vector in the ambient space of mxn matrices:
#   Z = U*M*V' + Up*V' + U*Vp'
# where (U, S, V) is the current point and (Up, M, Vp) is the tangent
# vector at that point.
    
    # Vectors in the ambient space are best represented as mxn matrices. If
# these are low-rank, they may also be represented as structures with
# U, S, V fields, such that Z = U*S*V'. Their are no resitrictions on what
# U, S and V are, as long as their product as indicated yields a real, mxn
# matrix.
    
    # The chosen geometry yields a Riemannian submanifold of the embedding
# space R^(mxn) equipped with the usual trace (Frobenius) inner product.
    
    
    # Please cite the Manopt paper as well as the research paper:
#     @Article{vandereycken2013lowrank,
#       Title   = {Low-rank matrix completion by {Riemannian} optimization},
#       Author  = {Vandereycken, B.},
#       Journal = {SIAM Journal on Optimization},
#       Year    = {2013},
#       Number  = {2},
#       Pages   = {1214--1236},
#       Volume  = {23},
#       Doi     = {10.1137/110845768}
#     }
    
    # See also: fixedrankfactory_2factors fixedrankfactory_3factors
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Dec. 30, 2012.
# Contributors: 
# Change log:
    
    #	Feb. 20, 2014 (NB):
#       Added function tangent to work with checkgradient.
    
    #   June 24, 2014 (NB):
#       A couple modifications following
#       Bart Vandereycken's feedback:
#       - The checksum (hash) was replaced for a faster alternative: it's a
#         bit less "safe" in that collisions could arise with higher
#         probability, but they're still very unlikely.
#       - The vector transport was changed.
#       The typical distance was also modified, hopefully giving the
#       trustregions method a better initial guess for the trust region
#       radius, but that should be tested for different cost functions too.
    
    #    July 11, 2014 (NB):
#       Added ehess2rhess and tangent2ambient, supplied by Bart.
    
    #    July 14, 2014 (NB):
#       Added vec, mat and vecmatareisometries so that hessianspectrum now
#       works with this geometry. Implemented the tangent function.
#       Made it clearer in the code and in the documentation in what format
#       ambient vectors may be supplied, and generalized some functions so
#       that they should now work with both accepted formats.
#       It is now clearly stated that for a point X represented as a
#       triplet (U, S, V), the matrix S needs to be diagonal.
    
    M.name = copy(lambda : sprintf('Manifold of %dx%d matrices of rank %d',m,n,k))
# fixedrank/fixedrankembeddedfactory.m:81
    M.dim = copy(lambda : dot((m + n - k),k))
# fixedrank/fixedrankembeddedfactory.m:83
    M.inner = copy(lambda x=None,d1=None,d2=None: dot(ravel(d1.M).T,ravel(d2.M)) + dot(ravel(d1.Up).T,ravel(d2.Up)) + dot(ravel(d1.Vp).T,ravel(d2.Vp)))
# fixedrank/fixedrankembeddedfactory.m:85
    M.norm = copy(lambda x=None,d=None: sqrt(M.inner(x,d,d)))
# fixedrank/fixedrankembeddedfactory.m:88
    M.dist = copy(lambda x=None,y=None: error('fixedrankembeddedfactory.dist not implemented yet.'))
# fixedrank/fixedrankembeddedfactory.m:90
    M.typicaldist = copy(lambda : M.dim())
# fixedrank/fixedrankembeddedfactory.m:92
    
    # such that they satisfy the tangent space constraints up to numerical
    # errors. If Z was indeed a tangent vector at X, this should barely
    # affect Z (it would not at all if we had infinite numerical accuracy).
    M.tangent = copy(tangent)
# fixedrank/fixedrankembeddedfactory.m:98
    
@function
def tangent(X=None,Z=None,*args,**kwargs):
    varargin = tangent.varargin
    nargin = tangent.nargin

    Z.Up = copy(Z.Up - dot(X.U,(dot(X.U.T,Z.Up))))
# fixedrank/fixedrankembeddedfactory.m:100
    Z.Vp = copy(Z.Vp - dot(X.V,(dot(X.V.T,Z.Vp))))
# fixedrank/fixedrankembeddedfactory.m:101
    return Z
    
if __name__ == '__main__':
    pass
    
    # For a given ambient vector Z, applies it to a matrix W. If Z is given
    # as a matrix, this is straightfoward. If Z is given as a structure
    # with fields U, S, V such that Z = U*S*V', the product is executed
    # efficiently.
    
@function
def apply_ambient(Z=None,W=None,*args,**kwargs):
    varargin = apply_ambient.varargin
    nargin = apply_ambient.nargin

    if logical_not(isstruct(Z)):
        ZW=dot(Z,W)
# fixedrank/fixedrankembeddedfactory.m:110
    else:
        ZW=dot(Z.U,(dot(Z.S,(dot(Z.V.T,W)))))
# fixedrank/fixedrankembeddedfactory.m:112
    
    return ZW
    
if __name__ == '__main__':
    pass
    
    # Same as apply_ambient, but applies Z' to W.
    
@function
def apply_ambient_transpose(Z=None,W=None,*args,**kwargs):
    varargin = apply_ambient_transpose.varargin
    nargin = apply_ambient_transpose.nargin

    if logical_not(isstruct(Z)):
        ZtW=dot(Z.T,W)
# fixedrank/fixedrankembeddedfactory.m:119
    else:
        ZtW=dot(Z.V,(dot(Z.S.T,(dot(Z.U.T,W)))))
# fixedrank/fixedrankembeddedfactory.m:121
    
    return ZtW
    
if __name__ == '__main__':
    pass
    
    
    # Orthogonal projection of an ambient vector Z represented as an mxn
    # matrix or as a structure with fields U, S, V to the tangent space at
    # X, in a tangent vector structure format.
    M.proj = copy(projection)
# fixedrank/fixedrankembeddedfactory.m:128
    
@function
def projection(X=None,Z=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    
    ZV=apply_ambient(Z,X.V)
# fixedrank/fixedrankembeddedfactory.m:131
    UtZV=dot(X.U.T,ZV)
# fixedrank/fixedrankembeddedfactory.m:132
    ZtU=apply_ambient_transpose(Z,X.U)
# fixedrank/fixedrankembeddedfactory.m:133
    Zproj.M = copy(UtZV)
# fixedrank/fixedrankembeddedfactory.m:135
    Zproj.Up = copy(ZV - dot(X.U,UtZV))
# fixedrank/fixedrankembeddedfactory.m:136
    Zproj.Vp = copy(ZtU - dot(X.V,UtZV.T))
# fixedrank/fixedrankembeddedfactory.m:137
    return Zproj
    
if __name__ == '__main__':
    pass
    
    M.egrad2rgrad = copy(projection)
# fixedrank/fixedrankembeddedfactory.m:141
    
    # Given the Euclidean gradient at X and the Euclidean Hessian at X
    # along H, where egrad and ehess are vectors in the ambient space and H
    # is a tangent vector at X, returns the Riemannian Hessian at X along
    # H, which is a tangent vector.
    M.ehess2rhess = copy(ehess2rhess)
# fixedrank/fixedrankembeddedfactory.m:148
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,H=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    
    # Euclidean part
    rhess=projection(X,ehess)
# fixedrank/fixedrankembeddedfactory.m:152
    
    T=apply_ambient(egrad,H.Vp) / X.S
# fixedrank/fixedrankembeddedfactory.m:155
    rhess.Up = copy(rhess.Up + (T - dot(X.U,(dot(X.U.T,T)))))
# fixedrank/fixedrankembeddedfactory.m:156
    T=apply_ambient_transpose(egrad,H.Up) / X.S
# fixedrank/fixedrankembeddedfactory.m:157
    rhess.Vp = copy(rhess.Vp + (T - dot(X.V,(dot(X.V.T,T)))))
# fixedrank/fixedrankembeddedfactory.m:158
    return rhess
    
if __name__ == '__main__':
    pass
    
    # Transforms a tangent vector Z represented as a structure (Up, M, Vp)
    # into a structure with fields (U, S, V) that represents that same
    # tangent vector in the ambient space of mxn matrices, as U*S*V'.
    # This matrix is equal to X.U*Z.M*X.V' + Z.Up*X.V' + X.U*Z.Vp'. The
    # latter is an mxn matrix, which could be too large to build
    # explicitly, and this is why we return a low-rank representation
    # instead. Note that there are no guarantees on U, S and V other than
    # that USV' is the desired matrix. In particular, U and V are not (in
    # general) orthonormal and S is not (in general) diagonal.
    # (In this implementation, S is identity, but this might change.)
    M.tangent2ambient = copy(tangent2ambient)
# fixedrank/fixedrankembeddedfactory.m:172
    
@function
def tangent2ambient(X=None,Z=None,*args,**kwargs):
    varargin = tangent2ambient.varargin
    nargin = tangent2ambient.nargin

    Zambient.U = copy(cat(dot(X.U,Z.M) + Z.Up,X.U))
# fixedrank/fixedrankembeddedfactory.m:174
    Zambient.S = copy(eye(dot(2,k)))
# fixedrank/fixedrankembeddedfactory.m:175
    Zambient.V = copy(cat(X.V,Z.Vp))
# fixedrank/fixedrankembeddedfactory.m:176
    return Zambient
    
if __name__ == '__main__':
    pass
    
    
    # This retraction is second order, following general results from
    # Absil, Malick, "Projection-like retractions on matrix manifolds",
    # SIAM J. Optim., 22 (2012), pp. 135-158.
    M.retr = copy(retraction)
# fixedrank/fixedrankembeddedfactory.m:182
    
@function
def retraction(X=None,Z=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# fixedrank/fixedrankembeddedfactory.m:185
    
    # See personal notes June 28, 2012 (NB)
    Qu,Ru=qr(Z.Up,0,nargout=2)
# fixedrank/fixedrankembeddedfactory.m:189
    Qv,Rv=qr(Z.Vp,0,nargout=2)
# fixedrank/fixedrankembeddedfactory.m:190
    
    # advocated svd is more robust, and it doesn't change the
        # asymptotic complexity to call svd then trim rather than call
        # svds. Also, apparently Matlab calls ARPACK in a suboptimal way
        # for svds in this scenario.
        # [Ut St Vt] = svds([X.S+t*Z.M , t*Rv' ; t*Ru , zeros(k)], k);
    Ut,St,Vt=svd(cat([X.S + dot(t,Z.M),dot(t,Rv.T)],[dot(t,Ru),zeros(k)]),nargout=3)
# fixedrank/fixedrankembeddedfactory.m:198
    Y.U = copy(dot(cat(X.U,Qu),Ut[:,1:k]))
# fixedrank/fixedrankembeddedfactory.m:200
    Y.V = copy(dot(cat(X.V,Qv),Vt[:,1:k]))
# fixedrank/fixedrankembeddedfactory.m:201
    Y.S = copy(St[1:k,1:k] + dot(eps,eye(k)))
# fixedrank/fixedrankembeddedfactory.m:202
    
    # [U S V] = svds(X.U*X.S*X.V' + t*(X.U*Z.M*X.V' + Z.Up*X.V' + X.U*Z.Vp'), k);
        # Y.U = U; Y.V = V; Y.S = S;
    
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# fixedrank/fixedrankembeddedfactory.m:210
    
@function
def exponential(X=None,Z=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin < 3:
        t=1.0
# fixedrank/fixedrankembeddedfactory.m:213
    
    Y=retraction(X,Z,t)
# fixedrank/fixedrankembeddedfactory.m:215
    warning('manopt:fixedrankembeddedfactory:exp',cat('Exponential for fixed rank ','manifold not implemented yet. Used retraction instead.'))
    return Y
    
if __name__ == '__main__':
    pass
    
    # Less safe but much faster checksum, June 24, 2014.
    # Older version right below.
    M.hash = copy(lambda X=None: cat('z',hashmd5(cat([sum(ravel(X.U))],[sum(ravel(X.S))],[sum(ravel(X.V))]))))
# fixedrank/fixedrankembeddedfactory.m:223
    
    
    M.rand = copy(random)
# fixedrank/fixedrankembeddedfactory.m:226
    
    # their random generator.
    stiefelm=stiefelfactory(m,k)
# fixedrank/fixedrankembeddedfactory.m:229
    stiefeln=stiefelfactory(n,k)
# fixedrank/fixedrankembeddedfactory.m:230
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    X.U = copy(stiefelm.rand())
# fixedrank/fixedrankembeddedfactory.m:232
    X.V = copy(stiefeln.rand())
# fixedrank/fixedrankembeddedfactory.m:233
    X.S = copy(diag(sort(rand(k,1),1,'descend')))
# fixedrank/fixedrankembeddedfactory.m:234
    return X
    
if __name__ == '__main__':
    pass
    
    
    # Generate a random tangent vector at X.
    # TODO: consider a possible imbalance between the three components Up,
    # Vp and M, when m, n and k are widely different (which is typical).
    M.randvec = copy(randomvec)
# fixedrank/fixedrankembeddedfactory.m:240
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    Z.Up = copy(randn(m,k))
# fixedrank/fixedrankembeddedfactory.m:242
    Z.Vp = copy(randn(n,k))
# fixedrank/fixedrankembeddedfactory.m:243
    Z.M = copy(randn(k))
# fixedrank/fixedrankembeddedfactory.m:244
    Z=tangent(X,Z)
# fixedrank/fixedrankembeddedfactory.m:245
    nrm=M.norm(X,Z)
# fixedrank/fixedrankembeddedfactory.m:246
    Z.Up = copy(Z.Up / nrm)
# fixedrank/fixedrankembeddedfactory.m:247
    Z.Vp = copy(Z.Vp / nrm)
# fixedrank/fixedrankembeddedfactory.m:248
    Z.M = copy(Z.M / nrm)
# fixedrank/fixedrankembeddedfactory.m:249
    return Z
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(lincomb)
# fixedrank/fixedrankembeddedfactory.m:252
    M.zerovec = copy(lambda X=None: struct('Up',zeros(m,k),'M',zeros(k,k),'Vp',zeros(n,k)))
# fixedrank/fixedrankembeddedfactory.m:254
    
    # Reference: Absil, Mahony, Sepulchre 2008 section 8.1.3:
    # For Riemannian submanifolds of a Euclidean space, it is acceptable to
    # transport simply by orthogonal projection of the tangent vector
    # translated in the ambient space.
    M.transp = copy(project_tangent)
# fixedrank/fixedrankembeddedfactory.m:262
    
@function
def project_tangent(X1=None,X2=None,Z1=None,*args,**kwargs):
    varargin = project_tangent.varargin
    nargin = project_tangent.nargin

    Z2=projection(X2,tangent2ambient(X1,Z1))
# fixedrank/fixedrankembeddedfactory.m:264
    return Z2
    
if __name__ == '__main__':
    pass
    
    M.vec = copy(vec)
# fixedrank/fixedrankembeddedfactory.m:268
    
@function
def vec(X=None,Z=None,*args,**kwargs):
    varargin = vec.varargin
    nargin = vec.nargin

    Zamb=tangent2ambient(X,Z)
# fixedrank/fixedrankembeddedfactory.m:270
    Zamb_mat=dot(dot(Zamb.U,Zamb.S),Zamb.V.T)
# fixedrank/fixedrankembeddedfactory.m:271
    Zvec=ravel(Zamb_mat)
# fixedrank/fixedrankembeddedfactory.m:272
    return Zvec
    
if __name__ == '__main__':
    pass
    
    M.mat = copy(lambda X=None,Zvec=None: projection(X,reshape(Zvec,cat(m,n))))
# fixedrank/fixedrankembeddedfactory.m:274
    M.vecmatareisometries = copy(lambda : true)
# fixedrank/fixedrankembeddedfactory.m:275
    return Zvec
    
if __name__ == '__main__':
    pass
    
    # Linear combination of tangent vectors
    
@function
def lincomb(x=None,a1=None,d1=None,a2=None,d2=None,*args,**kwargs):
    varargin = lincomb.varargin
    nargin = lincomb.nargin

    if nargin == 3:
        d.Up = copy(dot(a1,d1.Up))
# fixedrank/fixedrankembeddedfactory.m:283
        d.Vp = copy(dot(a1,d1.Vp))
# fixedrank/fixedrankembeddedfactory.m:284
        d.M = copy(dot(a1,d1.M))
# fixedrank/fixedrankembeddedfactory.m:285
    else:
        if nargin == 5:
            d.Up = copy(dot(a1,d1.Up) + dot(a2,d2.Up))
# fixedrank/fixedrankembeddedfactory.m:287
            d.Vp = copy(dot(a1,d1.Vp) + dot(a2,d2.Vp))
# fixedrank/fixedrankembeddedfactory.m:288
            d.M = copy(dot(a1,d1.M) + dot(a2,d2.M))
# fixedrank/fixedrankembeddedfactory.m:289
        else:
            error('fixedrank.lincomb takes either 3 or 5 inputs.')
    
    return d
    
if __name__ == '__main__':
    pass
    