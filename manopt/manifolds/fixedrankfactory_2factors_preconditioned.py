# Autogenerated with SMOP 
from smop.core import *
# fixedrank/fixedrankfactory_2factors_preconditioned.m

    
@function
def fixedrankfactory_2factors_preconditioned(m=None,n=None,k=None,*args,**kwargs):
    varargin = fixedrankfactory_2factors_preconditioned.varargin
    nargin = fixedrankfactory_2factors_preconditioned.nargin

    # Manifold of m-by-n matrices of rank k with two factor quotient geometry.
    
    # function M = fixedrankfactory_2factors_preconditioned(m, n, k)
    
    # This geometry is tuned to least-squares problems such as low-rank matrix
# completion with ell-2 loss.
    
    # A point X on the manifold is represented as a structure with two
# fields: L and R. The matrices L (m-by-k) and R (n-by-k) are 
# full column-rank matrices such that X = L*R'.
    
    # Tangent vectors are represented as a structure with two fields: L, R.
# 
# Please cite the Manopt paper as well as the research paper:
#     @Techreport{mishra2012optimized,
#       Title   = {A {R}iemannian geometry for low-rank matrix completion},
#       Author  = {Mishra, B. and Adithya Apuroop, K. and Sepulchre, R.},
#       Journal = {Arxiv preprint arXiv:1211.1550},
#       Year    = {2012}
#     }
    
    
    # See also: fixedrankembeddedfactory fixedrankfactory_2factors fixedrankfactory_3factors_preconditioned
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Bamdev Mishra, Dec. 30, 2012.
# Contributors:
# Change log:
    
    #	April 04, 2015 (BM):
#      Cosmetic changes including avoiding storing the inverse of a
#       k-by-k matrix.
    
    
    M.name = copy(lambda : sprintf('LR\'(tuned to least square problems) quotient manifold of %dx%d matrices of rank %d',m,n,k))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:36
    M.dim = copy(lambda : dot((m + n - k),k))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:38
    
    # (and pretty much everywhere else).
    
@function
def prepare(X=None,*args,**kwargs):
    varargin = prepare.varargin
    nargin = prepare.nargin

    if logical_not(all(isfield(X,cellarray(['LtL','RtR'])))):
        L=X.L
# fixedrank/fixedrankfactory_2factors_preconditioned.m:45
        R=X.R
# fixedrank/fixedrankfactory_2factors_preconditioned.m:46
        X.LtL = copy(dot(L.T,L))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:47
        X.RtR = copy(dot(R.T,R))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:48
    
    return X
    
if __name__ == '__main__':
    pass
    
    
    
    # The choice of metric is motivated by symmetry and 
    # tuned to least-squares cost function.
    M.inner = copy(iproduct)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:55
    
@function
def iproduct(X=None,eta=None,zeta=None,*args,**kwargs):
    varargin = iproduct.varargin
    nargin = iproduct.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:57
    ip=trace(dot(X.RtR,(dot(eta.L.T,zeta.L)))) + trace(dot(X.LtL,(dot(eta.R.T,zeta.R))))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:58
    
    return ip
    
if __name__ == '__main__':
    pass
    
    
    M.norm = copy(lambda X=None,eta=None: sqrt(M.inner(X,eta,eta)))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:61
    M.dist = copy(lambda x=None,y=None: error('fixedrankfactory_2factors_preconditioned.dist not implemented yet.'))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:63
    M.typicaldist = copy(lambda : dot(10,k))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:65
    M.egrad2rgrad = copy(egrad2rgrad)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:67
    
@function
def egrad2rgrad(X=None,egrad=None,*args,**kwargs):
    varargin = egrad2rgrad.varargin
    nargin = egrad2rgrad.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:69
    
    rgrad.L = copy(egrad.L / X.RtR)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:72
    rgrad.R = copy(egrad.R / X.LtL)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:73
    return rgrad
    
if __name__ == '__main__':
    pass
    
    
    M.ehess2rhess = copy(ehess2rhess)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:76
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,eta=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:78
    
    rgrad=egrad2rgrad(X,egrad)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:81
    
    Hess.L = copy(ehess.L / X.RtR - dot(dot(2,egrad.L),(numpy.linalg.solve(X.RtR,(symm(dot(eta.R.T,X.R)) / X.RtR)))))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:84
    Hess.R = copy(ehess.R / X.LtL - dot(dot(2,egrad.R),(numpy.linalg.solve(X.LtL,(symm(dot(eta.L.T,X.L)) / X.LtL)))))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:85
    
    Hess.L = copy(Hess.L + dot(rgrad.L,(symm(dot(eta.R.T,X.R)) / X.RtR)) + dot(eta.L,(symm(dot(rgrad.R.T,X.R)) / X.RtR)) - dot(X.L,(symm(dot(eta.R.T,rgrad.R)) / X.RtR)))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:88
    Hess.R = copy(Hess.R + dot(rgrad.R,(symm(dot(eta.L.T,X.L)) / X.LtL)) + dot(eta.R,(symm(dot(rgrad.L.T,X.L)) / X.LtL)) - dot(X.R,(symm(dot(eta.L.T,rgrad.L)) / X.LtL)))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:89
    
    Hess=M.proj(X,Hess)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:92
    return Hess
    
if __name__ == '__main__':
    pass
    
    
    M.proj = copy(projection)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:95
    
@function
def projection(X=None,eta=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:97
    
    Lambda=dot(0.5,((dot(eta.R.T,X.R)) / X.RtR - numpy.linalg.solve(X.LtL,(dot(X.L.T,eta.L)))))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:100
    etaproj.L = copy(eta.L + dot(X.L,Lambda))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:101
    etaproj.R = copy(eta.R - dot(X.R,Lambda.T))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:102
    return etaproj
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(M.proj)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:105
    M.tangent2ambient = copy(lambda X=None,eta=None: eta)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:107
    M.retr = copy(retraction)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:109
    
@function
def retraction(X=None,eta=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# fixedrank/fixedrankfactory_2factors_preconditioned.m:112
    
    Y.L = copy(X.L + dot(t,eta.L))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:114
    Y.R = copy(X.R + dot(t,eta.R))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:115
    
    # We need to ensure that L and R are do not have very relative
        # skewed norms.
    
    scaling=norm(X.L,'fro') / norm(X.R,'fro')
# fixedrank/fixedrankfactory_2factors_preconditioned.m:121
    scaling=sqrt(scaling)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:122
    Y.L = copy(Y.L / scaling)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:123
    Y.R = copy(dot(Y.R,scaling))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:124
    
    Y=prepare(Y)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:127
    return Y
    
if __name__ == '__main__':
    pass
    
    
    
    M.exp = copy(exponential)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:131
    
@function
def exponential(X=None,eta=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin < 3:
        t=1.0
# fixedrank/fixedrankfactory_2factors_preconditioned.m:134
    
    
    Y=retraction(X,eta,t)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:137
    warning('manopt:fixedrankfactory_2factors_preconditioned:exp',cat('Exponential for fixed rank ','manifold not implemented yet. Used retraction instead.'))
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(cat([ravel(X.L)],[ravel(X.R)]))))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:143
    M.rand = copy(random)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:145
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    X.L = copy(randn(m,k))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:148
    X.R = copy(randn(n,k))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:149
    return X
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:152
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    eta.L = copy(randn(m,k))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:154
    eta.R = copy(randn(n,k))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:155
    eta=projection(X,eta)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:156
    nrm=M.norm(X,eta)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:157
    eta.L = copy(eta.L / nrm)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:158
    eta.R = copy(eta.R / nrm)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:159
    return eta
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(lincomb)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:162
    M.zerovec = copy(lambda X=None: struct('L',zeros(m,k),'R',zeros(n,k)))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:164
    M.transp = copy(lambda x1=None,x2=None,d=None: projection(x2,d))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:166
    
    M.vec = copy(lambda X=None,U=None: cat([ravel(U.L)],[ravel(U.R)]))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:169
    M.mat = copy(lambda X=None,u=None: struct('L',reshape(u[1:(dot(m,k))],m,k),'R',reshape(u[(dot(m,k) + 1):end()],n,k)))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:171
    M.vecmatareisometries = copy(lambda : false)
# fixedrank/fixedrankfactory_2factors_preconditioned.m:174
    
    symm=lambda M=None: dot(0.5,(M + M.T))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:177
    return eta
    
if __name__ == '__main__':
    pass
    
    # Linear combination of tangent vectors.
    
@function
def lincomb(x=None,a1=None,d1=None,a2=None,d2=None,*args,**kwargs):
    varargin = lincomb.varargin
    nargin = lincomb.nargin

    
    if nargin == 3:
        d.L = copy(dot(a1,d1.L))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:184
        d.R = copy(dot(a1,d1.R))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:185
    else:
        if nargin == 5:
            d.L = copy(dot(a1,d1.L) + dot(a2,d2.L))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:187
            d.R = copy(dot(a1,d1.R) + dot(a2,d2.R))
# fixedrank/fixedrankfactory_2factors_preconditioned.m:188
        else:
            error('Bad use of fixedrankfactory_2factors_preconditioned.lincomb.')
    
    
    return d
    
if __name__ == '__main__':
    pass
    