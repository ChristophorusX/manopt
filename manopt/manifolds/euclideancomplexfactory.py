# Autogenerated with SMOP 
from smop.core import *
# euclidean/euclideancomplexfactory.m

    
@function
def euclideancomplexfactory(m=None,n=None,*args,**kwargs):
    varargin = euclideancomplexfactory.varargin
    nargin = euclideancomplexfactory.nargin

    # Returns a manifold struct to optimize over complex m-by-n matrices.
    
    # function M = euclideancomplexfactory(m, n)
    
    # Returns M, a structure describing the vector space of complex m-by-n
# matrices, as a manifold for Manopt.
    
    # The complex plane is here viewed as R^2. The inner product between two
# m-by-n matrices A and B is given by: real(trace(A'*B)). This choice
# guides the proper definition of gradient and Hessian for this geometry.
# This is not the classical Euclidean inner product for complex matrices;
# it is a real inner product.
    
    # See also: euclideanfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, April 7, 2015.
# Contributors: 
# Change log:
    
    
    if logical_not(exist('n','var')) or isempty(n):
        n=1
# euclidean/euclideancomplexfactory.m:24
    
    M.name = copy(lambda : sprintf('Vector space C^(%dx%d)',m,n))
# euclidean/euclideancomplexfactory.m:27
    M.dim = copy(lambda : dot(dot(2,m),n))
# euclidean/euclideancomplexfactory.m:29
    M.inner = copy(lambda x=None,d1=None,d2=None: real(dot(ravel(d1).T,ravel(d2))))
# euclidean/euclideancomplexfactory.m:31
    M.norm = copy(lambda x=None,d=None: norm(d,'fro'))
# euclidean/euclideancomplexfactory.m:33
    M.dist = copy(lambda x=None,y=None: norm(x - y,'fro'))
# euclidean/euclideancomplexfactory.m:35
    M.typicaldist = copy(lambda : sqrt(dot(m,n)))
# euclidean/euclideancomplexfactory.m:37
    M.proj = copy(lambda x=None,d=None: d)
# euclidean/euclideancomplexfactory.m:39
    M.egrad2rgrad = copy(lambda x=None,g=None: g)
# euclidean/euclideancomplexfactory.m:41
    M.ehess2rhess = copy(lambda x=None,eg=None,eh=None,d=None: eh)
# euclidean/euclideancomplexfactory.m:43
    M.tangent = copy(M.proj)
# euclidean/euclideancomplexfactory.m:45
    M.exp = copy(exp)
# euclidean/euclideancomplexfactory.m:47
    
@function
def exp(x=None,d=None,t=None,*args,**kwargs):
    varargin = exp.varargin
    nargin = exp.nargin

    if nargin == 3:
        y=x + dot(t,d)
# euclidean/euclideancomplexfactory.m:50
    else:
        y=x + d
# euclidean/euclideancomplexfactory.m:52
    
    return y
    
if __name__ == '__main__':
    pass
    
    
    M.retr = copy(M.exp)
# euclidean/euclideancomplexfactory.m:56
    M.log = copy(lambda x=None,y=None: y - x)
# euclidean/euclideancomplexfactory.m:58
    M.hash = copy(lambda x=None: cat('z',hashmd5(cat([real(ravel(x))],[imag(ravel(x))]))))
# euclidean/euclideancomplexfactory.m:60
    M.rand = copy(lambda : (randn(m,n) + dot(1j,randn(m,n))) / sqrt(2))
# euclidean/euclideancomplexfactory.m:62
    M.randvec = copy(randvec)
# euclidean/euclideancomplexfactory.m:64
    
@function
def randvec(x=None,*args,**kwargs):
    varargin = randvec.varargin
    nargin = randvec.nargin

    u=randn(m,n) + dot(1j,randn(m,n))
# euclidean/euclideancomplexfactory.m:66
    u=u / norm(u,'fro')
# euclidean/euclideancomplexfactory.m:67
    return u
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# euclidean/euclideancomplexfactory.m:70
    M.zerovec = copy(lambda x=None: zeros(m,n))
# euclidean/euclideancomplexfactory.m:72
    M.transp = copy(lambda x1=None,x2=None,d=None: d)
# euclidean/euclideancomplexfactory.m:74
    M.pairmean = copy(lambda x1=None,x2=None: dot(0.5,(x1 + x2)))
# euclidean/euclideancomplexfactory.m:76
    mn=dot(m,n)
# euclidean/euclideancomplexfactory.m:78
    M.vec = copy(lambda x=None,u_mat=None: cat([real(ravel(u_mat))],[imag(ravel(u_mat))]))
# euclidean/euclideancomplexfactory.m:79
    M.mat = copy(lambda x=None,u_vec=None: reshape(u_vec[1:mn],cat(m,n)) + dot(1j,reshape(u_vec[(mn + 1):end()],cat(m,n))))
# euclidean/euclideancomplexfactory.m:80
    M.vecmatareisometries = copy(lambda : true)
# euclidean/euclideancomplexfactory.m:81
    return u
    
if __name__ == '__main__':
    pass
    