# Autogenerated with SMOP 
from smop.core import *
# stiefel/stiefelgeneralizedfactory.m

    
@function
def stiefelgeneralizedfactory(n=None,p=None,B=None,*args,**kwargs):
    varargin = stiefelgeneralizedfactory.varargin
    nargin = stiefelgeneralizedfactory.nargin

    # Returns a manifold structure of "scaled" orthonormal matrices.
    
    # function M = stiefelgeneralizedfactory(n, p)
# function M = stiefelgeneralizedfactory(n, p, B)
    
    # The generalized Stiefel manifold is the set of "scaled" orthonormal 
# nxp matrices X such that X'*B*X is identity. B must be positive definite.
# If B is identity, then this is the standard Stiefel manifold.
    
    # The generalized Stiefel manifold is endowed with a scaled metric
# by making it a Riemannian submanifold of the Euclidean space,
# again endowed with the scaled inner product.
    
    # Some notions (not all) are from Section 4.5 of the paper
# "The geometry of algorithms with orthogonality constraints",
# A. Edelman, T. A. Arias, S. T. Smith, SIMAX, 1998.
    
    # Paper link: http://arxiv.org/abs/physics/9806030.
    
    # Note: egrad2rgrad and ehess2rhess involve solving linear systems in B. If
# this is a bottleneck for a specific application, then a way forward is to
# create a modified version of this file which preprocesses B to speed this
# up (typically, by computing a Cholesky factorization of it, then calling
# an appropriate solver).
    
    # See also: stiefelfactory  grassmannfactory  grassmanngeneralizedfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Bamdev Mishra, June 30, 2015.
# Contributors:
    
    # Change log:
#
    
    
    if logical_not(exist('B','var')) or isempty(B):
        B=speye(n)
# stiefel/stiefelgeneralizedfactory.m:38
    
    
    M.name = copy(lambda : sprintf('Generalized Stiefel manifold St(%d, %d)',n,p))
# stiefel/stiefelgeneralizedfactory.m:41
    M.dim = copy(lambda : (dot(n,p) - dot(dot(0.5,p),(p + 1))))
# stiefel/stiefelgeneralizedfactory.m:43
    M.inner = copy(lambda X=None,eta=None,zeta=None: trace(dot(eta.T,(dot(B,zeta)))))
# stiefel/stiefelgeneralizedfactory.m:45
    
    
    M.norm = copy(lambda X=None,eta=None: sqrt(M.inner(X,eta,eta)))
# stiefel/stiefelgeneralizedfactory.m:47
    M.dist = copy(lambda X=None,Y=None: error('stiefelgeneralizedfactory.dist not implemented yet.'))
# stiefel/stiefelgeneralizedfactory.m:49
    M.typicaldist = copy(lambda : sqrt(p))
# stiefel/stiefelgeneralizedfactory.m:51
    
    # at X.
    M.proj = copy(projection)
# stiefel/stiefelgeneralizedfactory.m:55
    
@function
def projection(X=None,U=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    BX=dot(B,X)
# stiefel/stiefelgeneralizedfactory.m:57
    
    Up=U - dot(X,symm(dot(BX.T,U)))
# stiefel/stiefelgeneralizedfactory.m:60
    return Up
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(M.proj)
# stiefel/stiefelgeneralizedfactory.m:63
    M.egrad2rgrad = copy(egrad2rgrad)
# stiefel/stiefelgeneralizedfactory.m:65
    
@function
def egrad2rgrad(X=None,egrad=None,*args,**kwargs):
    varargin = egrad2rgrad.varargin
    nargin = egrad2rgrad.nargin

    
    # First, scale egrad according the to the scaled metric in the
        # Euclidean space.
    egrad_scaled=numpy.linalg.solve(B,egrad)
# stiefel/stiefelgeneralizedfactory.m:70
    
    # rgrad = egrad_scaled - X*symm((B*X)'*egrad_scaled);
    
    # Verify that symm(BX'*egrad_scaled) = symm(X'*egrad).
    
    rgrad=egrad_scaled - dot(X,symm(dot(X.T,egrad)))
# stiefel/stiefelgeneralizedfactory.m:77
    return rgrad
    
if __name__ == '__main__':
    pass
    
    
    
    
    M.ehess2rhess = copy(ehess2rhess)
# stiefel/stiefelgeneralizedfactory.m:82
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,H=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    egraddot=copy(ehess)
# stiefel/stiefelgeneralizedfactory.m:84
    Xdot=copy(H)
# stiefel/stiefelgeneralizedfactory.m:85
    
    egrad_scaleddot=numpy.linalg.solve(B,egraddot)
# stiefel/stiefelgeneralizedfactory.m:88
    rgraddot=egrad_scaleddot - dot(Xdot,symm(dot(X.T,egrad))) - dot(X,symm(dot(Xdot.T,egrad))) - dot(X,symm(dot(X.T,egraddot)))
# stiefel/stiefelgeneralizedfactory.m:89
    
    rhess=M.proj(X,rgraddot)
# stiefel/stiefelgeneralizedfactory.m:94
    return rhess
    
if __name__ == '__main__':
    pass
    
    
    
    M.retr = copy(retraction)
# stiefel/stiefelgeneralizedfactory.m:98
    
@function
def retraction(X=None,U=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# stiefel/stiefelgeneralizedfactory.m:101
    
    Y=guf(X + dot(t,U))
# stiefel/stiefelgeneralizedfactory.m:103
    
    return Y
    
if __name__ == '__main__':
    pass
    
    
    
    M.exp = copy(exponential)
# stiefel/stiefelgeneralizedfactory.m:107
    
@function
def exponential(X=None,Z=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin < 3:
        t=1.0
# stiefel/stiefelgeneralizedfactory.m:110
    
    Y=retraction(X,Z,t)
# stiefel/stiefelgeneralizedfactory.m:112
    warning('manopt:stiefelgeneralizedfactory:exp',cat('Exponential for generalized Stiefel manifold ','manifold not implemented yet. Used retraction instead.'))
    return Y
    
if __name__ == '__main__':
    pass
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(ravel(X))))
# stiefel/stiefelgeneralizedfactory.m:119
    M.rand = copy(random)
# stiefel/stiefelgeneralizedfactory.m:121
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    X=guf(randn(n,p))
# stiefel/stiefelgeneralizedfactory.m:123
    
    return X
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# stiefel/stiefelgeneralizedfactory.m:126
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    U=projection(X,randn(n,p))
# stiefel/stiefelgeneralizedfactory.m:128
    U=U / norm(ravel(U))
# stiefel/stiefelgeneralizedfactory.m:129
    return U
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# stiefel/stiefelgeneralizedfactory.m:132
    M.zerovec = copy(lambda X=None: zeros(n,p))
# stiefel/stiefelgeneralizedfactory.m:134
    
    M.transp = copy(lambda X1=None,X2=None,d=None: projection(X2,d))
# stiefel/stiefelgeneralizedfactory.m:137
    M.vec = copy(lambda X=None,u_mat=None: ravel(u_mat))
# stiefel/stiefelgeneralizedfactory.m:139
    M.mat = copy(lambda X=None,u_vec=None: reshape(u_vec,cat(n,p)))
# stiefel/stiefelgeneralizedfactory.m:140
    M.vecmatareisometries = copy(lambda : false)
# stiefel/stiefelgeneralizedfactory.m:141
    
    symm=lambda D=None: (D + D.T) / 2
# stiefel/stiefelgeneralizedfactory.m:144
    
@function
def guf(Y=None,*args,**kwargs):
    varargin = guf.varargin
    nargin = guf.nargin

    # Generalized polar decomposition of an n-by-p matrix Y.
        # X'*B*X is identity.
    
    # Method 1
    u,__,v=svd(Y,0,nargout=3)
# stiefel/stiefelgeneralizedfactory.m:151
    
    # expensive way is to do X = u*(sqrtm(u'*(B*u))\(v')).
    q,ssquare=eig(dot(u.T,(dot(B,u))),nargout=2)
# stiefel/stiefelgeneralizedfactory.m:155
    qsinv=q / sparse(diag(sqrt(diag(ssquare))))
# stiefel/stiefelgeneralizedfactory.m:156
    X=dot(u,(dot((dot(qsinv,q.T)),v.T)))
# stiefel/stiefelgeneralizedfactory.m:157
    
    
    
    # Another computation using restricted_svd
        # [u, ~, v] = restricted_svd(Y);
        # X = u*v'; # X'*B*X is identity.
    
    return X
    
if __name__ == '__main__':
    pass
    
    
    
@function
def restricted_svd(Y=None,*args,**kwargs):
    varargin = restricted_svd.varargin
    nargin = restricted_svd.nargin

    # We compute a thin svd-like decomposition of an n-by-p matrix Y 
        # into matrices u, s, and v such that u is an n-by-p matrix
        # with u'*B*u being identity, s is a p-by-p diagonal matrix 
        # with positive entries, and v is a p-by-p orthogonal matrix.
        # Y = u*s*v'.
    v,ssquare=eig(symm[dot(Y.T,(dot(B,Y)))],nargout=2)
# stiefel/stiefelgeneralizedfactory.m:172
    
    ssquarevec=diag(ssquare)
# stiefel/stiefelgeneralizedfactory.m:173
    s=sparse(diag(abs(sqrt(ssquarevec))))
# stiefel/stiefelgeneralizedfactory.m:175
    u=dot(Y,(v / s))
# stiefel/stiefelgeneralizedfactory.m:176
    
    return u,s,v
    
if __name__ == '__main__':
    pass
    
    return u,s,v
    
if __name__ == '__main__':
    pass
    