# Autogenerated with SMOP 
from smop.core import *
# symfixedrank/symfixedrankYYcomplexfactory.m

    
@function
def symfixedrankYYcomplexfactory(n=None,k=None,*args,**kwargs):
    varargin = symfixedrankYYcomplexfactory.varargin
    nargin = symfixedrankYYcomplexfactory.nargin

    # Manifold of n x n complex Hermitian pos. semidefinite matrices of rank k.
    
    # function M = symfixedrankYYcomplexfactory(n, k)
    
    # Manifold of n-by-n complex Hermitian positive semidefinite matrices of 
# fixed rank k. This follows the quotient geometry described 
# in Sarod Yatawatta's 2013 paper:
# "Radio interferometric calibration using a Riemannian manifold", ICASSP.
    
    # Paper link: http://dx.doi.org/10.1109/ICASSP.2013.6638382.
    
    # A point X on the manifold M is parameterized as YY^*, where 
# Y is a complex matrix of size nxk. For any point Y on the manifold M, 
# given any kxk complex unitary matrix U, we say Y*U  is equivalent to Y, 
# i.e., YY^* does not change. Therefore, M is the set of equivalence 
# classes and is a Riemannian quotient manifold C^{nk}/SU(k). 
# The metric is the usual real-trace inner product, that is, 
# it is the usual metric for the complex plane identified with R^2.
    
    # Notice that this manifold is not complete: if optimization leads Y to be
# rank-deficient, the geometry will break down. Hence, this geometry should
# only be used if it is expected that the points of interest will have rank
# exactly k. Reduce k if that is not the case.
    
    # The geometry is based on the following papers (and references therein).
# Please cite the Manopt paper as well as the research papers:
    
    # @INPROCEEDINGS{Yatawatta2013A,
#  author={Yatawatta, S.},
#  booktitle={Acoustics, Speech and Signal Processing (ICASSP), 2013 IEEE International Conference on},
#  title={Radio interferometric calibration using a {R}iemannian manifold},
#  year={2013},
#  month={May},
#  pages={3866--3870},
#  doi={10.1109/ICASSP.2013.6638382},
#  ISSN={1520-6149},
# }
    
    # @article{Yatawatta2013B,
#  author = {Yatawatta, S.}, 
#  title = {On the interpolation of calibration solutions obtained in radio interferometry},
#  volume = {428}, 
#  number = {1}, 
#  pages = {828--833}, 
#  year = {2013}, 
#  doi = {10.1093/mnras/sts069}, 
#  journal = {Monthly Notices of the Royal Astronomical Society} 
# }
    
    # See also: symfixedrankYYfactory sympositivedefinitefactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Sarod Yatawatta, June 29, 2015.
# Contributors: Bamdev Mishra.
# Change log:
    
    #   June 28, 2016 (NB):
#       Metric scaled down by factor 2 to match the metric used in
#       euclideancomplexfactory.
    
    M.name = copy(lambda : sprintf('YY\' quotient manifold of Hermitian %dx%d complex matrices of rank %d.',n,n,k))
# symfixedrank/symfixedrankYYcomplexfactory.m:63
    M.dim = copy(lambda : dot(dot(2,k),n) - dot(k,k))
# symfixedrank/symfixedrankYYcomplexfactory.m:65
    
    
    # Euclidean metric on the total space.
    # BM: equivalent to real(trace(eta'*zeta)), but more efficient.
    M.inner = copy(lambda Y=None,eta=None,zeta=None: real(dot(ravel(eta).T,ravel(zeta))))
# symfixedrank/symfixedrankYYcomplexfactory.m:69
    M.norm = copy(lambda Y=None,eta=None: sqrt(M.inner(Y,eta,eta)))
# symfixedrank/symfixedrankYYcomplexfactory.m:71
    
    # i.e., the Procrustes problem, with svd(Y'*Z).
    M.dist = copy(lambda Y=None,Z=None: distance)
# symfixedrank/symfixedrankYYcomplexfactory.m:75
    
@function
def distance(Y=None,Z=None,*args,**kwargs):
    varargin = distance.varargin
    nargin = distance.nargin

    u,ignore,v=svd(dot(Z.T,Y),nargout=3)
# symfixedrank/symfixedrankYYcomplexfactory.m:77
    
    E=Y - dot(dot(Z,u),v.T)
# symfixedrank/symfixedrankYYcomplexfactory.m:78
    
    distval=real(dot(ravel(E).T,ravel(E)))
# symfixedrank/symfixedrankYYcomplexfactory.m:79
    return distval
    
if __name__ == '__main__':
    pass
    
    
    M.typicaldist = copy(lambda : dot(10,k))
# symfixedrank/symfixedrankYYcomplexfactory.m:82
    
    
    M.proj = copy(projection)
# symfixedrank/symfixedrankYYcomplexfactory.m:84
    
@function
def projection(Y=None,eta=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    # Projection onto the horizontal space
    xx=dot(Y.T,Y)
# symfixedrank/symfixedrankYYcomplexfactory.m:87
    rr=dot(Y.T,eta) - dot(eta.T,Y)
# symfixedrank/symfixedrankYYcomplexfactory.m:88
    Omega=lyap(xx,- rr)
# symfixedrank/symfixedrankYYcomplexfactory.m:89
    etaproj=eta - dot(Y,Omega)
# symfixedrank/symfixedrankYYcomplexfactory.m:90
    return etaproj
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(M.proj)
# symfixedrank/symfixedrankYYcomplexfactory.m:93
    M.tangent2ambient = copy(lambda Y=None,eta=None: eta)
# symfixedrank/symfixedrankYYcomplexfactory.m:94
    M.retr = copy(retraction)
# symfixedrank/symfixedrankYYcomplexfactory.m:96
    
@function
def retraction(Y=None,eta=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# symfixedrank/symfixedrankYYcomplexfactory.m:99
    
    Ynew=Y + dot(t,eta)
# symfixedrank/symfixedrankYYcomplexfactory.m:101
    return Ynew
    
if __name__ == '__main__':
    pass
    
    
    
    M.egrad2rgrad = copy(lambda Y=None,eta=None: eta)
# symfixedrank/symfixedrankYYcomplexfactory.m:105
    M.ehess2rhess = copy(lambda Y=None,egrad=None,ehess=None,U=None: M.proj(Y,ehess))
# symfixedrank/symfixedrankYYcomplexfactory.m:106
    M.exp = copy(exponential)
# symfixedrank/symfixedrankYYcomplexfactory.m:109
    
@function
def exponential(Y=None,eta=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin < 3:
        t=1.0
# symfixedrank/symfixedrankYYcomplexfactory.m:112
    
    
    Ynew=retraction(Y,eta,t)
# symfixedrank/symfixedrankYYcomplexfactory.m:115
    warning('manopt:symfixedrankYYcomplexfactory:exp',cat('Exponential for symmetric fixed-rank complex ','manifold not implemented yet. Used retraction instead.'))
    return Ynew
    
if __name__ == '__main__':
    pass
    
    
    # Notice that the hash of two equivalent points will be different...
    M.hash = copy(lambda Y=None: cat('z',hashmd5(cat([real(ravel(Y))],[imag(ravel(Y))]))))
# symfixedrank/symfixedrankYYcomplexfactory.m:122
    M.rand = copy(random)
# symfixedrank/symfixedrankYYcomplexfactory.m:124
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    Y=randn(n,k) + dot(1j,randn(n,k))
# symfixedrank/symfixedrankYYcomplexfactory.m:126
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# symfixedrank/symfixedrankYYcomplexfactory.m:129
    
@function
def randomvec(Y=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    eta=randn(n,k) + dot(1j,randn(n,k))
# symfixedrank/symfixedrankYYcomplexfactory.m:131
    eta=projection(Y,eta)
# symfixedrank/symfixedrankYYcomplexfactory.m:132
    nrm=M.norm(Y,eta)
# symfixedrank/symfixedrankYYcomplexfactory.m:133
    eta=eta / nrm
# symfixedrank/symfixedrankYYcomplexfactory.m:134
    return eta
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# symfixedrank/symfixedrankYYcomplexfactory.m:137
    M.zerovec = copy(lambda Y=None: zeros(n,k))
# symfixedrank/symfixedrankYYcomplexfactory.m:139
    M.transp = copy(lambda Y1=None,Y2=None,d=None: projection(Y2,d))
# symfixedrank/symfixedrankYYcomplexfactory.m:141
    M.vec = copy(lambda Y=None,u_mat=None: cat([real(ravel(u_mat))],[imag(ravel(u_mat))]))
# symfixedrank/symfixedrankYYcomplexfactory.m:143
    M.mat = copy(lambda Y=None,u_vec=None: reshape(u_vec[1:dot(n,k)],cat(n,k)) + dot(1j,reshape(u_vec[dot(n,k) + 1:end()],cat(n,k))))
# symfixedrank/symfixedrankYYcomplexfactory.m:144
    M.vecmatareisometries = copy(lambda : true)
# symfixedrank/symfixedrankYYcomplexfactory.m:145
    return eta
    
if __name__ == '__main__':
    pass
    