# Autogenerated with SMOP 
from smop.core import *
# essential/essentialfactory.m

    
@function
def essentialfactory(k=None,strSigned=None,*args,**kwargs):
    varargin = essentialfactory.varargin
    nargin = essentialfactory.nargin

    # Manifold structure to optimize over the space of essential matrices.
    
    # function M = essentialfactory(k)
# function M = essentialfactory(k, 'signed')
# function M = essentialfactory(k, 'unsigned')
    
    
    # Quotient representation of the essential manifold: deals with the
# representation of the space of essential matrices M_rE. These are used in
# computer vision to represent the epipolar constraint between projected
# points in two perspective views.
    
    # The space is represented as the quotient (SO(3)^2/SO(2)).
# See the following references for details:
    
    #   R. Tron, K. Daniilidis,
#   "On the quotient representation of the essential manifold"
#   IEEE Conference on Computer Vision and Pattern Recognition, 2014
    
    # For computational purposes, each essential matrix is represented as a
# [3x6] matrix where each [3x3] block is a rotation.
    
    # The metric used is the one induced by the submersion of M_rE in SO(3)^2.
    
    # Tangent vectors are represented in the Lie algebra of SO(3)^2, i.e., as
# [3x6] matrices where each [3x3] block is a skew-symmetric matrix.
# Use the function tangent2ambient(X, H) to switch from the Lie algebra
# representation to the embedding space representation in R^(3x6).
    
    # By default, k = 1, and the geometry is 'signed'.
    
    # Optional arguments:
#   "signed"    selects the signed version of the manifold
#   "unsigned"  selects the unsigned version of the manifold
    
    # See also rotationsfactory
    
    # Please cite the Manopt paper as well as the research paper:
#     @InProceedings{tron2014essential,
#       Title        = {On the quotient representation of the essential manifold},
#       Author       = {Tron, R. and Daniilidis, K.},
#       Booktitle    = {IEEE Conference on Computer Vision and Pattern Recognition},
#       Year         = {2014},
#       Organization = {{IEEE CVPR}}
#     }
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Roberto Tron, Aug. 8, 2014
# Contributors: Bamdev Mishra, May 15, 2015.
    
    
    # RT: General implementation note: to streamline component-wise
# computations, in tangentProjection and exponential,
# we flatten out the arguments into [3 x 3 x 2K] arrays, compute the
# components all together, and then sharp the result again into [3 x 6 x K]
# arrays.
    
    # Optional parameters to switch between the signed and unsigned
    # versions of the manifold.
    if logical_not(exist('strSigned','var')) or isempty(strSigned):
        strSigned='signed'
# essential/essentialfactory.m:64
    
    if 'signed' == (strSigned):
        flagSigned=copy(true)
# essential/essentialfactory.m:68
    else:
        if 'unsigned' == (strSigned):
            flagSigned=copy(false)
# essential/essentialfactory.m:70
        else:
            error('Second argument can be either empty, \'signed\', or \'unsigned\'.')
    
    
    if logical_not(exist('k','var')) or isempty(k):
        k=1
# essential/essentialfactory.m:77
    
    
    if k == 1:
        M.name = copy(lambda : sprintf('Quotient representation of the essential manifold, %s',strSigned))
# essential/essentialfactory.m:81
    else:
        if k > 1 and k == round(k):
            M.name = copy(lambda : sprintf('Product of %d quotient representations of the essential manifold, %s',k,strSigned))
# essential/essentialfactory.m:83
        else:
            error('k must be an integer no less than 1.')
    
    
    M.dim = copy(lambda : dot(k,5))
# essential/essentialfactory.m:88
    M.inner = copy(lambda x=None,d1=None,d2=None: dot(ravel(d1).T,ravel(d2)))
# essential/essentialfactory.m:90
    M.norm = copy(lambda x=None,d=None: norm(ravel(d)))
# essential/essentialfactory.m:92
    M.typicaldist = copy(lambda : dot(pi,sqrt(dot(2,k))))
# essential/essentialfactory.m:94
    M.proj = copy(tangentProjection)
# essential/essentialfactory.m:96
    
@function
def tangentProjection(X=None,H=None,*args,**kwargs):
    varargin = tangentProjection.varargin
    nargin = tangentProjection.nargin

    # Project H on the tangent space of SO(3)^2
    HProj=essential_sharp(multiskew(multiprod(multitransp(essential_flat(X)),essential_flat(H))))
# essential/essentialfactory.m:99
    
    p=vertproj(X,HProj)
# essential/essentialfactory.m:102
    HProjHoriz=HProj - multiprod(p / 2,cat(essential_hat3(permute(X[3,1:3,:],cat(2,3,1))),essential_hat3(permute(X[3,4:6,:],cat(2,3,1)))))
# essential/essentialfactory.m:104
    
    return HProjHoriz
    
if __name__ == '__main__':
    pass
    
    
    
    M.tangent = copy(lambda X=None,H=None: essential_sharp(multiskew(essential_flat(H))))
# essential/essentialfactory.m:108
    M.egrad2rgrad = copy(egrad2rgrad)
# essential/essentialfactory.m:110
    
@function
def egrad2rgrad(X=None,egrad=None,*args,**kwargs):
    varargin = egrad2rgrad.varargin
    nargin = egrad2rgrad.nargin

    rgrad=M.proj(X,egrad)
# essential/essentialfactory.m:112
    return rgrad
    
if __name__ == '__main__':
    pass
    
    
    M.ehess2rhess = copy(ehess2rhess)
# essential/essentialfactory.m:115
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,S=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    # Reminder: S contains skew-symmeric matrices. The actual
        # direction that the point X is moved along is X*S.
    RA=p1(X)
# essential/essentialfactory.m:119
    RB=p2(X)
# essential/essentialfactory.m:120
    SA=p1(S)
# essential/essentialfactory.m:121
    SB=p2(S)
# essential/essentialfactory.m:122
    G=copy(egrad)
# essential/essentialfactory.m:124
    GA=p1(G)
# essential/essentialfactory.m:125
    GB=p2(G)
# essential/essentialfactory.m:126
    H=copy(ehess)
# essential/essentialfactory.m:128
    
    # given by the curvature of the space (as opposed to a simple
        # Euclidean derivative).
    
    # The following is the vectorized version of connection=-[multisym(GA'*RA)*SA multisym(GB'*RB)*SB];
    connection=tangent2ambient(X,- cat(2,multiprod(multisym(multiprod(multitransp(GA),RA)),SA),multiprod(multisym(multiprod(multitransp(GB),RB)),SB)))
# essential/essentialfactory.m:135
    rhess=M.proj(X,H + connection)
# essential/essentialfactory.m:138
    return rhess
    
if __name__ == '__main__':
    pass
    
    
    
    
    M.exp = copy(exponential)
# essential/essentialfactory.m:143
    
@function
def exponential(X=None,U=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin == 3:
        U=dot(t,U)
# essential/essentialfactory.m:146
    
    
    UFlat=essential_flat(U)
# essential/essentialfactory.m:149
    exptUFlat=rot3_exp(UFlat)
# essential/essentialfactory.m:150
    Y=essential_sharp(multiprod(essential_flat(X),exptUFlat))
# essential/essentialfactory.m:151
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.retr = copy(exponential)
# essential/essentialfactory.m:154
    M.log = copy(logarithm)
# essential/essentialfactory.m:156
    
@function
def logarithm(X=None,Y=None,*args,**kwargs):
    varargin = logarithm.varargin
    nargin = logarithm.nargin

    
    QX=matlabarray(cat([X[:,1:3,:]],[X[:,4:6,:]]))
# essential/essentialfactory.m:159
    QY=matlabarray(cat([Y[:,1:3,:]],[Y[:,4:6,:]]))
# essential/essentialfactory.m:160
    QYr=essential_closestRepresentative(QX,QY,'flagSigned',flagSigned)
# essential/essentialfactory.m:161
    Yr=matlabarray(cat(QYr[1:3,:,:],QYr[4:6,:,:]))
# essential/essentialfactory.m:162
    U=zeros(size(X))
# essential/essentialfactory.m:163
    U[:,1:3,:]=rot3_log(multiprod(multitransp(X[:,1:3,:]),Yr[:,1:3,:]))
# essential/essentialfactory.m:164
    U[:,4:6,:]=rot3_log(multiprod(multitransp(X[:,4:6,:]),Yr[:,4:6,:]))
# essential/essentialfactory.m:165
    return U
    
if __name__ == '__main__':
    pass
    
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(ravel(X))))
# essential/essentialfactory.m:168
    M.rand = copy(lambda : randessential(k))
# essential/essentialfactory.m:170
    
@function
def randessential(N=None,*args,**kwargs):
    varargin = randessential.varargin
    nargin = randessential.nargin

    # Generates random essential matrices.
    
    # function Q = randessential(N)
    
    # Q is a [3x6] matrix where each [3x3] block is a uniformly distributed
        # matrix.
    
    # This file is part of Manopt: www.manopt.org.
        # Original author: Roberto Tron, Aug. 8, 2014
        # Contributors:
        # Change log:
    
    if nargin < 1:
        N=1
# essential/essentialfactory.m:185
    
    
    Q=matlabarray(cat(randrot(3,N),randrot(3,N)))
# essential/essentialfactory.m:188
    return Q
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# essential/essentialfactory.m:191
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    U=tangentProjection(X,essential_sharp(randskew(3,dot(2,k))))
# essential/essentialfactory.m:193
    U=U / sqrt(M.inner([],U,U))
# essential/essentialfactory.m:194
    return U
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# essential/essentialfactory.m:197
    M.zerovec = copy(lambda x=None: zeros(3,6,k))
# essential/essentialfactory.m:199
    M.transp = copy(transport)
# essential/essentialfactory.m:201
    
@function
def transport(X1=None,X2=None,S1=None,*args,**kwargs):
    varargin = transport.varargin
    nargin = transport.nargin

    # Transport a vector from the tangent space at X1 to the tangent
        # space at X2. This transport uses the left translation of the
        # ambient group and preserves the norm of S1. The left translation
        # aligns the vertical spaces at the two elements.
    
    # Group operation in the ambient group, X12=X2'*X1
    X12=essential_sharp(multiprod(multitransp(essential_flat(X2)),essential_flat(X1)))
# essential/essentialfactory.m:209
    X12Flat=essential_flat(X12)
# essential/essentialfactory.m:210
    
    S2=essential_sharp(multiprod(X12Flat,multiprod(essential_flat(S1),multitransp(X12Flat))))
# essential/essentialfactory.m:213
    return S2
    
if __name__ == '__main__':
    pass
    
    
    M.pairmean = copy(pairmean)
# essential/essentialfactory.m:216
    
@function
def pairmean(X1=None,X2=None,*args,**kwargs):
    varargin = pairmean.varargin
    nargin = pairmean.nargin

    V=M.log(X1,X2)
# essential/essentialfactory.m:218
    Y=M.exp(X1,dot(0.5,V))
# essential/essentialfactory.m:219
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.dist = copy(lambda x=None,y=None: M.norm(x,M.log(x,y)))
# essential/essentialfactory.m:222
    M.vec = copy(lambda x=None,u_mat=None: ravel(u_mat))
# essential/essentialfactory.m:224
    M.mat = copy(lambda x=None,u_vec=None: reshape(u_vec,cat(3,6,k)))
# essential/essentialfactory.m:225
    M.vecmatareisometries = copy(lambda : true)
# essential/essentialfactory.m:226
    p1=lambda X=None: X[:,1:3,:]
# essential/essentialfactory.m:230
    p2=lambda X=None: X[:,4:6,:]
# essential/essentialfactory.m:231
    vertproj=lambda X=None,H=None: multiprod(X[3,1:3,:],permute(vee3(H[:,1:3,:]),cat(1,3,2))) + multiprod(X[3,4:6,:],permute(vee3(H[:,4:6,:]),cat(1,3,2)))
# essential/essentialfactory.m:234
    tangent2ambient=lambda X=None,H=None: essential_sharp(multiprod(essential_flat(X),essential_flat(H)))
# essential/essentialfactory.m:236
    return Y
    
if __name__ == '__main__':
    pass
    
    ## Some functions used by the essential factory
    
    
@function
def vee3(V=None,*args,**kwargs):
    varargin = vee3.varargin
    nargin = vee3.nargin

    v=squeeze(cat([V[3,2,:] - V[2,3,:]],[V[1,3,:] - V[3,1,:]],[V[2,1,:] - V[1,2,:]])) / 2
# essential/essentialfactory.m:245
    return v
    
if __name__ == '__main__':
    pass
    
    # Compute the exponential map in SO(3) using Rodrigues' formula
#  function R = rot3_exp(V)
# V must be a [3x3xN] array of [3x3] skew-symmetric matrices.
    
@function
def rot3_exp(V=None,*args,**kwargs):
    varargin = rot3_exp.varargin
    nargin = rot3_exp.nargin

    v=vee3(V)
# essential/essentialfactory.m:253
    nv=cnorm(v)
# essential/essentialfactory.m:254
    idxZero=nv < 1e-15
# essential/essentialfactory.m:255
    nvMod=copy(nv)
# essential/essentialfactory.m:256
    nvMod[idxZero]=1
# essential/essentialfactory.m:257
    vNorm=v / (dot(cat([1],[1],[1]),nvMod))
# essential/essentialfactory.m:259
    
    nv=shiftdim(nv,- 1)
# essential/essentialfactory.m:262
    c=cos(nv)
# essential/essentialfactory.m:263
    s=sin(nv)
# essential/essentialfactory.m:264
    VNorm,vNormShift=essential_hat3(vNorm,nargout=2)
# essential/essentialfactory.m:265
    vNormvNormT=multiprod(vNormShift,multitransp(vNormShift))
# essential/essentialfactory.m:266
    R=multiprod(eye(3),c) + multiprod(VNorm,s) + multiprod(vNormvNormT,1 - c)
# essential/essentialfactory.m:267
    return R
    
if __name__ == '__main__':
    pass
    
    # Compute the logarithm map in SO(3)
#  function V = rot3_log(R)
# V is a [3x3xN] array of [3x3] skew-symmetric matrices
    
@function
def rot3_log(R=None,*args,**kwargs):
    varargin = rot3_log.varargin
    nargin = rot3_log.nargin

    skewR=multiskew(R)
# essential/essentialfactory.m:276
    ctheta=(multitrace(R).T - 1) / 2
# essential/essentialfactory.m:277
    stheta=cnorm(vee3(skewR))
# essential/essentialfactory.m:278
    theta=atan2(stheta,ctheta)
# essential/essentialfactory.m:279
    V=copy(skewR)
# essential/essentialfactory.m:281
    for ik in arange(1,size(R,3)).reshape(-1):
        V[:,:,ik]=V[:,:,ik] / sincN(theta[ik])
# essential/essentialfactory.m:283
    
    return V
    
if __name__ == '__main__':
    pass
    
    
@function
def sincN(x=None,*args,**kwargs):
    varargin = sincN.varargin
    nargin = sincN.nargin

    sx=sin(x) / x
# essential/essentialfactory.m:289
    sx[x == 0]=1
# essential/essentialfactory.m:290
    return sx
    
if __name__ == '__main__':
    pass
    
    
@function
def cnorm(v=None,*args,**kwargs):
    varargin = cnorm.varargin
    nargin = cnorm.nargin

    nv=sqrt(sum(v ** 2))
# essential/essentialfactory.m:294
    return nv
    
if __name__ == '__main__':
    pass
    