# Autogenerated with SMOP 
from smop.core import *
# grassmann/grassmanncomplexfactory.m

    
@function
def grassmanncomplexfactory(n=None,p=None,k=None,*args,**kwargs):
    varargin = grassmanncomplexfactory.varargin
    nargin = grassmanncomplexfactory.nargin

    # Returns a manifold struct to optimize over the set of subspaces in C^n.
    
    # function M = grassmanncomplexfactory(n, p)
# function M = grassmanncomplexfactory(n, p, k)
    
    # Complex Grassmann manifold: each point on this manifold is a collection
# of k vector subspaces of dimension p embedded in C^n.
    
    # The metric is obtained by making the Grassmannian a Riemannian quotient
# manifold of the complex Stiefel manifold, i.e., the manifold of
# orthonormal matrices, itself endowed with a metric by making it a
# Riemannian submanifold of the Euclidean space, endowed with the usual
# real-trace inner product, that is, it is the usual metric for the complex
# plane identified with R^2.
# 
# This structure deals with complex matrices X of size n x p x k
# (or n x p if k = 1, which is the default) such that each n x p matrix is
# orthonormal, i.e., X'*X = eye(p) if k = 1, or X(:, :, i)' * X(:, :, i) =
# eye(p) for i = 1 : k if k > 1. Each n x p matrix is a numerical
# representation of the vector subspace its columns span.
    
    # By default, k = 1.
    
    # See also: grassmannfactory, stiefelcomplexfactory, grassmanngeneralizedfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Hiroyuki Sato, May 21, 2015.
# Contributors: 
# Change log:
    
    assert_(n >= p,cat('The dimension n of the ambient space must be larger ','than the dimension p of the subspaces.'))
    if logical_not(exist('k','var')) or isempty(k):
        k=1
# grassmann/grassmanncomplexfactory.m:37
    
    
    if k == 1:
        M.name = copy(lambda : sprintf('Complex Grassmann manifold Gr(%d, %d)',n,p))
# grassmann/grassmanncomplexfactory.m:41
    else:
        if k > 1:
            M.name = copy(lambda : sprintf(cat('Multi complex Grassmann manifold ','Gr(%d, %d)^%d'),n,p,k))
# grassmann/grassmanncomplexfactory.m:43
        else:
            error('k must be an integer no less than 1.')
    
    
    M.dim = copy(lambda : dot(dot(dot(2,k),p),(n - p)))
# grassmann/grassmanncomplexfactory.m:49
    
    
    M.inner = copy(lambda x=None,d1=None,d2=None: real(dot(ravel(d1).T,ravel(d2))))
# grassmann/grassmanncomplexfactory.m:51
    
    
    M.norm = copy(lambda x=None,d=None: norm(ravel(d)))
# grassmann/grassmanncomplexfactory.m:53
    M.dist = copy(distance)
# grassmann/grassmanncomplexfactory.m:55
    
@function
def distance(x=None,y=None,*args,**kwargs):
    varargin = distance.varargin
    nargin = distance.nargin

    principal_angles=zeros(p,k)
# grassmann/grassmanncomplexfactory.m:57
    XHY=multiprod(multihconj(x),y)
# grassmann/grassmanncomplexfactory.m:58
    
    for i in arange(1,k).reshape(-1):
        cos_princ_angle=svd(XHY[:,:,i])
# grassmann/grassmanncomplexfactory.m:60
        principal_angles[:,i]=acos(cos_princ_angle)
# grassmann/grassmanncomplexfactory.m:61
    
    d=norm(real(principal_angles),'fro')
# grassmann/grassmanncomplexfactory.m:63
    return d
    
if __name__ == '__main__':
    pass
    
    
    M.typicaldist = copy(lambda : sqrt(dot(p,k)))
# grassmann/grassmanncomplexfactory.m:66
    
    # at X.
    M.proj = copy(projection)
# grassmann/grassmanncomplexfactory.m:70
    
@function
def projection(X=None,U=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    
    XHU=multiprod(multihconj(X),U)
# grassmann/grassmanncomplexfactory.m:73
    
    Up=U - multiprod(X,XHU)
# grassmann/grassmanncomplexfactory.m:74
    
    return Up
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(M.proj)
# grassmann/grassmanncomplexfactory.m:78
    M.egrad2rgrad = copy(M.proj)
# grassmann/grassmanncomplexfactory.m:80
    M.ehess2rhess = copy(ehess2rhess)
# grassmann/grassmanncomplexfactory.m:82
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,H=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    PXehess=projection(X,ehess)
# grassmann/grassmanncomplexfactory.m:84
    XHG=multiprod(multihconj(X),egrad)
# grassmann/grassmanncomplexfactory.m:85
    
    HXHG=multiprod(H,XHG)
# grassmann/grassmanncomplexfactory.m:86
    
    rhess=PXehess - HXHG
# grassmann/grassmanncomplexfactory.m:87
    
    return rhess
    
if __name__ == '__main__':
    pass
    
    
    M.retr = copy(retraction)
# grassmann/grassmanncomplexfactory.m:90
    
@function
def retraction(X=None,U=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# grassmann/grassmanncomplexfactory.m:93
    
    Y=X + dot(t,U)
# grassmann/grassmanncomplexfactory.m:95
    for i in arange(1,k).reshape(-1):
        # Compute the polar factorization of Y = X+tU
        u,s,v=svd(Y[:,:,i],'econ',nargout=3)
# grassmann/grassmanncomplexfactory.m:99
        Y[:,:,i]=dot(u,v.T)
# grassmann/grassmanncomplexfactory.m:100
        # As compared with the Stiefel factory, we do not need to
			# worry about flipping signs of columns here, since only
			# the column space is important, not the actual columns.
            # [Q, unused] = qr(Y(:, :, i), 0); ##ok
            # Y(:, :, i) = Q;
    
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# grassmann/grassmanncomplexfactory.m:112
    
@function
def exponential(X=None,U=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin == 3:
        tU=dot(t,U)
# grassmann/grassmanncomplexfactory.m:115
    else:
        tU=copy(U)
# grassmann/grassmanncomplexfactory.m:117
    
    Y=zeros(size(X))
# grassmann/grassmanncomplexfactory.m:119
    for i in arange(1,k).reshape(-1):
        u,s,v=svd(tU[:,:,i],0,nargout=3)
# grassmann/grassmanncomplexfactory.m:121
        cos_s=diag(cos(diag(s)))
# grassmann/grassmanncomplexfactory.m:122
        sin_s=diag(sin(diag(s)))
# grassmann/grassmanncomplexfactory.m:123
        Y[:,:,i]=dot(dot(dot(X[:,:,i],v),cos_s),v.T) + dot(dot(u,sin_s),v.T)
# grassmann/grassmanncomplexfactory.m:124
        # re-orthonormalize. This is overall quite expensive.
        q,unused=qr(Y[:,:,i],0,nargout=2)
# grassmann/grassmanncomplexfactory.m:127
        Y[:,:,i]=q
# grassmann/grassmanncomplexfactory.m:128
    
    return Y
    
if __name__ == '__main__':
    pass
    
    # Test code for the logarithm:
    # Gr = grassmanncomplexfactory(5, 2, 3);
    # x = Gr.rand()
    # y = Gr.rand()
    # u = Gr.log(x, y)
    # Gr.dist(x, y) # These two numbers should
    # Gr.norm(x, u) # be the same.
    # z = Gr.exp(x, u) # z needs not be the same matrix as y, but it should
    # v = Gr.log(x, z) # be the same point as y on Grassmann: dist almost 0.
    M.log = copy(logarithm)
# grassmann/grassmanncomplexfactory.m:141
    
@function
def logarithm(X=None,Y=None,*args,**kwargs):
    varargin = logarithm.varargin
    nargin = logarithm.nargin

    U=zeros(n,p,k)
# grassmann/grassmanncomplexfactory.m:143
    for i in arange(1,k).reshape(-1):
        x=X[:,:,i]
# grassmann/grassmanncomplexfactory.m:145
        y=Y[:,:,i]
# grassmann/grassmanncomplexfactory.m:146
        yHx=dot(y.T,x)
# grassmann/grassmanncomplexfactory.m:147
        AH=y.T - dot(yHx,x.T)
# grassmann/grassmanncomplexfactory.m:148
        BH=numpy.linalg.solve(yHx,AH)
# grassmann/grassmanncomplexfactory.m:149
        u,s,v=svd(BH.T,'econ',nargout=3)
# grassmann/grassmanncomplexfactory.m:150
        u=u[:,1:p]
# grassmann/grassmanncomplexfactory.m:152
        s=diag(s)
# grassmann/grassmanncomplexfactory.m:153
        s=s[1:p]
# grassmann/grassmanncomplexfactory.m:154
        v=v[:,1:p]
# grassmann/grassmanncomplexfactory.m:155
        U[:,:,i]=dot(dot(u,diag(atan(s))),v.T)
# grassmann/grassmanncomplexfactory.m:157
    
    return U
    
if __name__ == '__main__':
    pass
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(cat([real(ravel(X))],[imag(ravel(X))]))))
# grassmann/grassmanncomplexfactory.m:161
    
    
    M.rand = copy(random)
# grassmann/grassmanncomplexfactory.m:163
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    X=zeros(n,p,k)
# grassmann/grassmanncomplexfactory.m:165
    for j in arange(1,k).reshape(-1):
        Q,unused=qr(randn(n,p) + dot(1j,randn(n,p)),0,nargout=2)
# grassmann/grassmanncomplexfactory.m:167
        X[:,:,j]=Q
# grassmann/grassmanncomplexfactory.m:168
    
    return X
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# grassmann/grassmanncomplexfactory.m:172
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    U=projection(X,randn(n,p,k) + dot(1j,randn(n,p,k)))
# grassmann/grassmanncomplexfactory.m:174
    
    U=U / norm(ravel(U))
# grassmann/grassmanncomplexfactory.m:175
    return U
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# grassmann/grassmanncomplexfactory.m:178
    M.zerovec = copy(lambda x=None: zeros(n,p,k))
# grassmann/grassmanncomplexfactory.m:180
    
    M.transp = copy(lambda x1=None,x2=None,d=None: projection(x2,d))
# grassmann/grassmanncomplexfactory.m:183
    M.vec = copy(lambda x=None,u_mat=None: cat([real(ravel(u_mat))],[imag(ravel(u_mat))]))
# grassmann/grassmanncomplexfactory.m:185
    M.mat = copy(lambda x=None,u_vec=None: reshape(u_vec[1:(dot(dot(n,p),k))] + dot(1j,u_vec[(dot(dot(n,p),k) + 1):end()]),cat(n,p,k)))
# grassmann/grassmanncomplexfactory.m:186
    M.vecmatareisometries = copy(lambda : true)
# grassmann/grassmanncomplexfactory.m:187
    return U
    
if __name__ == '__main__':
    pass
    