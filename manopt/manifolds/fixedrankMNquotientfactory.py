# Autogenerated with SMOP 
from smop.core import *
# fixedrank/fixedrankMNquotientfactory.m

    
@function
def fixedrankMNquotientfactory(m=None,n=None,k=None,*args,**kwargs):
    varargin = fixedrankMNquotientfactory.varargin
    nargin = fixedrankMNquotientfactory.nargin

    # Manifold of m-by-n matrices of rank k with two factor quotient geometry.
    
    # function M = fixedrankMNquotientfactory(m, n, k)
    
    # This follows the quotient geometry described in the following paper:
# P.-A. Absil, L. Amodei and G. Meyer,
# "Two Newton methods on the manifold of fixed-rank matrices endowed
#  with Riemannian quotient geometries", arXiv, 2012.
    
    # Paper link: http://arxiv.org/abs/1209.0068
    
    # A point X on the manifold is represented as a structure with two
# fields: M and N. The matrix M (mxk) is orthonormal, while the matrix N
# (nxk) is full-rank such that X = M*N';
    
    # Tangent vectors are represented as a structure with two fields (M, N).
    
    # Please cite the Manopt paper as well as the research paper:
#     @Article{absil2014fixedrank,
#       Title   = {Two Newton methods on the manifold of fixed-rank matrices endowed with Riemannian quotient geometries},
#       Author  = {Absil, P.-A. and Amodei, L. and Meyer, G.},
#       Journal = {Computational Statistics},
#       Year    = {2014},
#       Number  = {3-4},
#       Pages   = {569--590},
#       Volume  = {29},
#       Doi     = {10.1007/s00180-013-0441-6}
#     }
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Dec. 30, 2012.
# Contributors:
# Change log:
    
    
    M.name = copy(lambda : sprintf('MN\' quotient manifold of %dx%d matrices of rank %d',m,n,k))
# fixedrank/fixedrankMNquotientfactory.m:37
    M.dim = copy(lambda : dot((m + n - k),k))
# fixedrank/fixedrankMNquotientfactory.m:39
    
    # space.
    M.inner = copy(lambda X=None,eta=None,zeta=None: dot(ravel(eta.M).T,ravel(zeta.M)) + dot(ravel(eta.N).T,ravel(zeta.N)))
# fixedrank/fixedrankMNquotientfactory.m:43
    M.norm = copy(lambda X=None,eta=None: sqrt(M.inner(X,eta,eta)))
# fixedrank/fixedrankMNquotientfactory.m:45
    M.dist = copy(lambda x=None,y=None: error('fixedrankMNquotientfactory.dist not implemented yet.'))
# fixedrank/fixedrankMNquotientfactory.m:47
    M.typicaldist = copy(lambda : dot(10,k))
# fixedrank/fixedrankMNquotientfactory.m:49
    symm=lambda X=None: dot(0.5,(X + X.T))
# fixedrank/fixedrankMNquotientfactory.m:51
    stiefel_proj=lambda M=None,H=None: H - dot(M,symm[dot(M.T,H)])
# fixedrank/fixedrankMNquotientfactory.m:52
    M.egrad2rgrad = copy(egrad2rgrad)
# fixedrank/fixedrankMNquotientfactory.m:54
    
@function
def egrad2rgrad(X=None,eta=None,*args,**kwargs):
    varargin = egrad2rgrad.varargin
    nargin = egrad2rgrad.nargin

    eta.M = copy(stiefel_proj[X.M,eta.M])
# fixedrank/fixedrankMNquotientfactory.m:56
    return eta
    
if __name__ == '__main__':
    pass
    
    
    M.ehess2rhess = copy(ehess2rhess)
# fixedrank/fixedrankMNquotientfactory.m:59
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,eta=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    
    # Directional derivative of the Riemannian gradient.
    Hess.M = copy(ehess.M - dot(eta.M,symm[dot(X.M.T,egrad.M)]))
# fixedrank/fixedrankMNquotientfactory.m:63
    Hess.M = copy(stiefel_proj[X.M,Hess.M])
# fixedrank/fixedrankMNquotientfactory.m:64
    Hess.N = copy(ehess.N)
# fixedrank/fixedrankMNquotientfactory.m:66
    
    Hess=M.proj(X,Hess)
# fixedrank/fixedrankMNquotientfactory.m:69
    return Hess
    
if __name__ == '__main__':
    pass
    
    
    
    M.proj = copy(projection)
# fixedrank/fixedrankMNquotientfactory.m:73
    
@function
def projection(X=None,eta=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    
    # Start by projecting the vector from Rmp x Rnp to the tangent
        # space to the total space, that is, eta.M should be in the
        # tangent space to Stiefel at X.M and eta.N is arbitrary.
    eta.M = copy(stiefel_proj[X.M,eta.M])
# fixedrank/fixedrankMNquotientfactory.m:79
    
    # is, take care of the quotient.
    
    # First solve a Sylvester equation (A symm., B skew-symm.)
    A=dot(X.N.T,X.N) + eye(k)
# fixedrank/fixedrankMNquotientfactory.m:85
    B=dot(eta.M.T,X.M) + dot(eta.N.T,X.N)
# fixedrank/fixedrankMNquotientfactory.m:86
    B=B - B.T
# fixedrank/fixedrankMNquotientfactory.m:87
    omega=lyap(A,- B)
# fixedrank/fixedrankMNquotientfactory.m:88
    
    etaproj.M = copy(eta.M + dot(X.M,omega))
# fixedrank/fixedrankMNquotientfactory.m:91
    etaproj.N = copy(eta.N + dot(X.N,omega))
# fixedrank/fixedrankMNquotientfactory.m:92
    return etaproj
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# fixedrank/fixedrankMNquotientfactory.m:96
    
@function
def exponential(X=None,eta=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin < 3:
        t=1.0
# fixedrank/fixedrankMNquotientfactory.m:99
    
    
    A=dot(dot(t,X.M.T),eta.M)
# fixedrank/fixedrankMNquotientfactory.m:102
    S=dot(dot(t ** 2,eta.M.T),eta.M)
# fixedrank/fixedrankMNquotientfactory.m:103
    Y.M = copy(dot(dot(dot(cat(X.M,dot(t,eta.M)),expm(cat([A,- S],[eye(k),A]))),eye(dot(2,k),k)),expm(- A)))
# fixedrank/fixedrankMNquotientfactory.m:104
    
    Q,R=qr(Y.M,0,nargout=2)
# fixedrank/fixedrankMNquotientfactory.m:107
    Y.M = copy(dot(Q,diag(sign(diag(R)))))
# fixedrank/fixedrankMNquotientfactory.m:108
    Y.N = copy(X.N + dot(t,eta.N))
# fixedrank/fixedrankMNquotientfactory.m:110
    return Y
    
if __name__ == '__main__':
    pass
    
    
    # Factor M lives on the Stiefel manifold, hence we will reuse its
    # random generator.
    stiefelm=stiefelfactory(m,k)
# fixedrank/fixedrankMNquotientfactory.m:116
    M.retr = copy(retraction)
# fixedrank/fixedrankMNquotientfactory.m:118
    
@function
def retraction(X=None,eta=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# fixedrank/fixedrankMNquotientfactory.m:121
    
    
    Y.M = copy(uf(X.M + dot(t,eta.M)))
# fixedrank/fixedrankMNquotientfactory.m:124
    
    Y.N = copy(X.N + dot(t,eta.N))
# fixedrank/fixedrankMNquotientfactory.m:125
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(cat([ravel(X.M)],[ravel(X.N)]))))
# fixedrank/fixedrankMNquotientfactory.m:128
    M.rand = copy(random)
# fixedrank/fixedrankMNquotientfactory.m:130
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    X.M = copy(stiefelm.rand())
# fixedrank/fixedrankMNquotientfactory.m:132
    X.N = copy(randn(n,k))
# fixedrank/fixedrankMNquotientfactory.m:133
    return X
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# fixedrank/fixedrankMNquotientfactory.m:136
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    eta.M = copy(randn(m,k))
# fixedrank/fixedrankMNquotientfactory.m:138
    eta.N = copy(randn(n,k))
# fixedrank/fixedrankMNquotientfactory.m:139
    eta=projection(X,eta)
# fixedrank/fixedrankMNquotientfactory.m:140
    nrm=M.norm(X,eta)
# fixedrank/fixedrankMNquotientfactory.m:141
    eta.M = copy(eta.M / nrm)
# fixedrank/fixedrankMNquotientfactory.m:142
    eta.N = copy(eta.N / nrm)
# fixedrank/fixedrankMNquotientfactory.m:143
    return eta
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(lincomb)
# fixedrank/fixedrankMNquotientfactory.m:146
    M.zerovec = copy(lambda X=None: struct('M',zeros(m,k),'N',zeros(n,k)))
# fixedrank/fixedrankMNquotientfactory.m:148
    M.transp = copy(lambda x1=None,x2=None,d=None: projection(x2,d))
# fixedrank/fixedrankMNquotientfactory.m:150
    return eta
    
if __name__ == '__main__':
    pass
    
    # Linear combination of tangent vectors
    
@function
def lincomb(x=None,a1=None,d1=None,a2=None,d2=None,*args,**kwargs):
    varargin = lincomb.varargin
    nargin = lincomb.nargin

    
    if nargin == 3:
        d.M = copy(dot(a1,d1.M))
# fixedrank/fixedrankMNquotientfactory.m:159
        d.N = copy(dot(a1,d1.N))
# fixedrank/fixedrankMNquotientfactory.m:160
    else:
        if nargin == 5:
            d.M = copy(dot(a1,d1.M) + dot(a2,d2.M))
# fixedrank/fixedrankMNquotientfactory.m:162
            d.N = copy(dot(a1,d1.N) + dot(a2,d2.N))
# fixedrank/fixedrankMNquotientfactory.m:163
        else:
            error('Bad use of fixedrankMNquotientfactory.lincomb.')
    
    
    return d
    
if __name__ == '__main__':
    pass
    
    
@function
def uf(A=None,*args,**kwargs):
    varargin = uf.varargin
    nargin = uf.nargin

    L,unused,R=svd(A,0,nargout=3)
# fixedrank/fixedrankMNquotientfactory.m:172
    A=dot(L,R.T)
# fixedrank/fixedrankMNquotientfactory.m:173
    return A
    
if __name__ == '__main__':
    pass
    