# Autogenerated with SMOP 
from smop.core import *
# symfixedrank/symfixedrankYYfactory.m

    
@function
def symfixedrankYYfactory(n=None,k=None,*args,**kwargs):
    varargin = symfixedrankYYfactory.varargin
    nargin = symfixedrankYYfactory.nargin

    # Manifold of n-by-n symmetric positive semidefinite matrices of rank k.
    
    # function M = symfixedrankYYfactory(n, k)
    
    # A point X on the manifold is parameterized as YY^T where Y is a matrix of
# size nxk. As such, X is symmetric, positive semidefinite. We restrict to
# full-rank Y's, such that X has rank exactly k. The point X is numerically
# represented by Y (this is more efficient than working with X, which may
# be big). Tangent vectors are represented as matrices of the same size as
# Y, call them Ydot, so that Xdot = Y Ydot' + Ydot Y. The metric is the
# canonical Euclidean metric on Y.
# 
# Since for any orthogonal Q of size k, it holds that (YQ)(YQ)' = YY',
# we "group" all matrices of the form YQ in an equivalence class. The set
# of equivalence classes is a Riemannian quotient manifold, implemented
# here.
    
    # Notice that this manifold is not complete: if optimization leads Y to be
# rank-deficient, the geometry will break down. Hence, this geometry should
# only be used if it is expected that the points of interest will have rank
# exactly k. Reduce k if that is not the case.
# 
# An alternative, complete, geometry for positive semidefinite matrices of
# rank k is described in Bonnabel and Sepulchre 2009, "Riemannian Metric
# and Geometric Mean for Positive Semidefinite Matrices of Fixed Rank",
# SIAM Journal on Matrix Analysis and Applications.
    
    
    # The geometry here implemented is the simplest case of the 2010 paper:
# M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,
# "Low-Rank Optimization on the Cone of Positive Semidefinite Matrices".
# Paper link: http://www.di.ens.fr/~fbach/journee2010_sdp.pdf
# 
# 
# Please cite the Manopt paper as well as the research paper:
#     @Article{journee2010low,
#       Title   = {Low-rank optimization on the cone of positive semidefinite matrices},
#       Author  = {Journ{\'e}e, M. and Bach, F. and Absil, P.-A. and Sepulchre, R.},
#       Journal = {SIAM Journal on Optimization},
#       Year    = {2010},
#       Number  = {5},
#       Pages   = {2327--2351},
#       Volume  = {20},
#       Doi     = {10.1137/080731359}
#     }
    
    # See also: elliptopefactory spectrahedronfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Bamdev Mishra, Dec. 30, 2012.
# Contributors:
# Change log:
    
    #  July 10, 2013 (NB):
#       Added vec, mat, tangent, tangent2ambient ;
#       Correction for the dimension of the manifold.
    
    #   April 2, 2015 (NB):
#       Replaced trace(A'*B) by A(:)'*B(:) (equivalent but faster).
    
    M.name = copy(lambda : sprintf('YY\' quotient manifold of %dx%d psd matrices of rank %d',n,k))
# symfixedrank/symfixedrankYYfactory.m:63
    M.dim = copy(lambda : dot(k,n) - dot(k,(k - 1)) / 2)
# symfixedrank/symfixedrankYYfactory.m:65
    
    M.inner = copy(lambda Y=None,eta=None,zeta=None: dot(ravel(eta).T,ravel(zeta)))
# symfixedrank/symfixedrankYYfactory.m:68
    M.norm = copy(lambda Y=None,eta=None: sqrt(M.inner(Y,eta,eta)))
# symfixedrank/symfixedrankYYfactory.m:70
    M.dist = copy(lambda Y=None,Z=None: error('symfixedrankYYfactory.dist not implemented yet.'))
# symfixedrank/symfixedrankYYfactory.m:72
    M.typicaldist = copy(lambda : dot(10,k))
# symfixedrank/symfixedrankYYfactory.m:74
    M.proj = copy(projection)
# symfixedrank/symfixedrankYYfactory.m:76
    
@function
def projection(Y=None,eta=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    # Projection onto the horizontal space
    YtY=dot(Y.T,Y)
# symfixedrank/symfixedrankYYfactory.m:79
    SS=copy(YtY)
# symfixedrank/symfixedrankYYfactory.m:80
    AS=dot(Y.T,eta) - dot(eta.T,Y)
# symfixedrank/symfixedrankYYfactory.m:81
    Omega=lyap(SS,- AS)
# symfixedrank/symfixedrankYYfactory.m:82
    etaproj=eta - dot(Y,Omega)
# symfixedrank/symfixedrankYYfactory.m:83
    return etaproj
    
if __name__ == '__main__':
    pass
    
    M.tangent = copy(M.proj)
# symfixedrank/symfixedrankYYfactory.m:86
    M.tangent2ambient = copy(lambda Y=None,eta=None: eta)
# symfixedrank/symfixedrankYYfactory.m:87
    M.retr = copy(retraction)
# symfixedrank/symfixedrankYYfactory.m:89
    
@function
def retraction(Y=None,eta=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# symfixedrank/symfixedrankYYfactory.m:92
    
    Ynew=Y + dot(t,eta)
# symfixedrank/symfixedrankYYfactory.m:94
    return Ynew
    
if __name__ == '__main__':
    pass
    
    M.egrad2rgrad = copy(lambda Y=None,eta=None: eta)
# symfixedrank/symfixedrankYYfactory.m:98
    M.ehess2rhess = copy(lambda Y=None,egrad=None,ehess=None,U=None: M.proj(Y,ehess))
# symfixedrank/symfixedrankYYfactory.m:99
    M.exp = copy(exponential)
# symfixedrank/symfixedrankYYfactory.m:101
    
@function
def exponential(Y=None,eta=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin < 3:
        t=1.0
# symfixedrank/symfixedrankYYfactory.m:104
    
    
    Ynew=retraction(Y,eta,t)
# symfixedrank/symfixedrankYYfactory.m:107
    warning('manopt:symfixedrankYYfactory:exp',cat('Exponential for symmetric, fixed-rank ','manifold not implemented yet. Used retraction instead.'))
    return Ynew
    
if __name__ == '__main__':
    pass
    
    # Notice that the hash of two equivalent points will be different...
    M.hash = copy(lambda Y=None: cat('z',hashmd5(ravel(Y))))
# symfixedrank/symfixedrankYYfactory.m:114
    M.rand = copy(random)
# symfixedrank/symfixedrankYYfactory.m:116
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    Y=randn(n,k)
# symfixedrank/symfixedrankYYfactory.m:118
    return Y
    
if __name__ == '__main__':
    pass
    
    M.randvec = copy(randomvec)
# symfixedrank/symfixedrankYYfactory.m:121
    
@function
def randomvec(Y=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    eta=randn(n,k)
# symfixedrank/symfixedrankYYfactory.m:123
    eta=projection(Y,eta)
# symfixedrank/symfixedrankYYfactory.m:124
    nrm=M.norm(Y,eta)
# symfixedrank/symfixedrankYYfactory.m:125
    eta=eta / nrm
# symfixedrank/symfixedrankYYfactory.m:126
    return eta
    
if __name__ == '__main__':
    pass
    
    M.lincomb = copy(matrixlincomb)
# symfixedrank/symfixedrankYYfactory.m:129
    M.zerovec = copy(lambda Y=None: zeros(n,k))
# symfixedrank/symfixedrankYYfactory.m:131
    M.transp = copy(lambda Y1=None,Y2=None,d=None: projection(Y2,d))
# symfixedrank/symfixedrankYYfactory.m:133
    M.vec = copy(lambda Y=None,u_mat=None: ravel(u_mat))
# symfixedrank/symfixedrankYYfactory.m:135
    M.mat = copy(lambda Y=None,u_vec=None: reshape(u_vec,cat(n,k)))
# symfixedrank/symfixedrankYYfactory.m:136
    M.vecmatareisometries = copy(lambda : true)
# symfixedrank/symfixedrankYYfactory.m:137
    return eta
    
if __name__ == '__main__':
    pass
    