# Autogenerated with SMOP 
from smop.core import *
# euclidean/centeredmatrixfactory.m

    
@function
def centeredmatrixfactory(m=None,n=None,rows_or_cols=None,*args,**kwargs):
    varargin = centeredmatrixfactory.varargin
    nargin = centeredmatrixfactory.nargin

    # Linear manifold struct. for optimization over matrices with centered cols
    
    # function M = centeredmatrixfactory(m, n)
# function M = centeredmatrixfactory(m, n, 'cols')
# function M = centeredmatrixfactory(m, n, 'rows')
    
    # Returns M, a structure for Manopt describing the Euclidean space of
# m-by-n matrices whose columns sum to zero (or whose rows sum to zero,
# if 'rows' is passed as last input).
    
    # The metric is the standard Frobenius distance and associated trace inner
# product. Matrices on M, denoted by X, have size mxn and obey
# X*ones(n, 1) = 0 (centered columns) or ones(1, m)*X = 0 (centered rows).
    
    # See also: euclideanfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, July 3, 2015.
# Contributors: 
# Change log:
    
    if logical_not(exist('rows_or_cols','var')) or isempty(rows_or_cols):
        rows_or_cols='cols'
# euclidean/centeredmatrixfactory.m:24
    
    
    # Define a centering operator: it subtracts the mean column or row.
    if 'cols' == lower(rows_or_cols):
        center=lambda X=None: bsxfun(minus,X,mean(X,2))
# euclidean/centeredmatrixfactory.m:30
        M.dim = copy(lambda : dot(m,n) - m)
# euclidean/centeredmatrixfactory.m:31
    else:
        if 'rows' == lower(rows_or_cols):
            center=lambda X=None: bsxfun(minus,X,mean(X,1))
# euclidean/centeredmatrixfactory.m:33
            M.dim = copy(lambda : dot(m,n) - n)
# euclidean/centeredmatrixfactory.m:34
        else:
            error('The third input must be either \'rows\' or \'cols\'.')
    
    
    # This is a non-standard function to have in a Manopt manifold.
    # It is included because it might be helpful in some situations.
    M.center = copy(center)
# euclidean/centeredmatrixfactory.m:41
    M.name = copy(lambda : sprintf('Space of size %d x %d matrices with centered %s',m,n,lower(rows_or_cols)))
# euclidean/centeredmatrixfactory.m:43
    M.inner = copy(lambda x=None,d1=None,d2=None: dot(ravel(d1).T,ravel(d2)))
# euclidean/centeredmatrixfactory.m:46
    M.norm = copy(lambda x=None,d=None: norm(d,'fro'))
# euclidean/centeredmatrixfactory.m:48
    M.dist = copy(lambda x=None,y=None: norm(x - y,'fro'))
# euclidean/centeredmatrixfactory.m:50
    M.typicaldist = copy(lambda : sqrt(M.dim()))
# euclidean/centeredmatrixfactory.m:52
    M.proj = copy(lambda X=None,U=None: center[U])
# euclidean/centeredmatrixfactory.m:54
    M.egrad2rgrad = copy(M.proj)
# euclidean/centeredmatrixfactory.m:56
    M.ehess2rhess = copy(lambda x=None,eg=None,eh=None,d=None: center[eh])
# euclidean/centeredmatrixfactory.m:58
    M.tangent = copy(lambda x=None,d=None: d)
# euclidean/centeredmatrixfactory.m:60
    M.exp = copy(exp)
# euclidean/centeredmatrixfactory.m:62
    
@function
def exp(x=None,d=None,t=None,*args,**kwargs):
    varargin = exp.varargin
    nargin = exp.nargin

    if nargin == 3:
        y=x + dot(t,d)
# euclidean/centeredmatrixfactory.m:65
    else:
        y=x + d
# euclidean/centeredmatrixfactory.m:67
    
    return y
    
if __name__ == '__main__':
    pass
    
    
    M.retr = copy(M.exp)
# euclidean/centeredmatrixfactory.m:71
    M.log = copy(lambda x=None,y=None: y - x)
# euclidean/centeredmatrixfactory.m:73
    M.hash = copy(lambda x=None: cat('z',hashmd5(ravel(x))))
# euclidean/centeredmatrixfactory.m:75
    M.randvec = copy(lambda X=None: randvec())
# euclidean/centeredmatrixfactory.m:77
    
@function
def randvec(*args,**kwargs):
    varargin = randvec.varargin
    nargin = randvec.nargin

    U=center[randn(m,n)]
# euclidean/centeredmatrixfactory.m:79
    U=U / norm(U,'fro')
# euclidean/centeredmatrixfactory.m:80
    return U
    
if __name__ == '__main__':
    pass
    
    
    M.rand = copy(lambda : center[randn(m,n)])
# euclidean/centeredmatrixfactory.m:83
    M.lincomb = copy(matrixlincomb)
# euclidean/centeredmatrixfactory.m:85
    M.zerovec = copy(lambda x=None: zeros(m,n))
# euclidean/centeredmatrixfactory.m:87
    M.transp = copy(lambda x1=None,x2=None,d=None: d)
# euclidean/centeredmatrixfactory.m:89
    M.pairmean = copy(lambda x1=None,x2=None: dot(0.5,(x1 + x2)))
# euclidean/centeredmatrixfactory.m:91
    M.vec = copy(lambda x=None,u_mat=None: ravel(u_mat))
# euclidean/centeredmatrixfactory.m:93
    M.mat = copy(lambda x=None,u_vec=None: reshape(u_vec,cat(m,n)))
# euclidean/centeredmatrixfactory.m:94
    M.vecmatareisometries = copy(lambda : true)
# euclidean/centeredmatrixfactory.m:95
    return U
    
if __name__ == '__main__':
    pass
    