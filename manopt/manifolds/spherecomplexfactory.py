# Autogenerated with SMOP 
from smop.core import *
# sphere/spherecomplexfactory.m

    
@function
def spherecomplexfactory(n=None,m=None,*args,**kwargs):
    varargin = spherecomplexfactory.varargin
    nargin = spherecomplexfactory.nargin

    # Returns a manifold struct to optimize over unit-norm complex matrices.
    
    # function M = spherecomplexfactory(n)
# function M = spherecomplexfactory(n, m)
    
    # Manifold of n-by-m complex matrices of unit Frobenius norm.
# By default, m = 1, which corresponds to the unit sphere in C^n. The
# metric is such that the sphere is a Riemannian submanifold of the space
# of 2nx2m real matrices with the usual trace inner product, i.e., the
# usual metric.
# 
# See also: spherefactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Dec. 30, 2012.
# Contributors: 
# Change log:
    
    #   Sep. 4, 2014 (NB):
#       Added ehess2rhess.
    
    #   April 7, 2015 (NB):
#       Added vec/mat pair (for use with hessianspectrum, for example).
    
    #   April 13, 2015 (NB):
#       Added logarithm
    
    #   Oct. 8, 2016 (NB)
#       Code for exponential was simplified to only treat the zero vector
#       as a particular case.
    
    #   Oct. 22, 2016 (NB)
#       Distance function dist now significantly more accurate for points
#       within 1e-7 and less from each other.
    
    
    if logical_not(exist('m','var')):
        m=1
# sphere/spherecomplexfactory.m:39
    
    if m == 1:
        M.name = copy(lambda : sprintf('Complex sphere S^%d',n - 1))
# sphere/spherecomplexfactory.m:43
    else:
        M.name = copy(lambda : sprintf('Unit F-norm %dx%d complex matrices',n,m))
# sphere/spherecomplexfactory.m:45
    
    
    M.dim = copy(lambda : dot(2,(dot(n,m))) - 1)
# sphere/spherecomplexfactory.m:48
    M.inner = copy(lambda x=None,d1=None,d2=None: real(dot(ravel(d1).T,ravel(d2))))
# sphere/spherecomplexfactory.m:50
    M.norm = copy(lambda x=None,d=None: norm(d,'fro'))
# sphere/spherecomplexfactory.m:52
    M.dist = copy(dist)
# sphere/spherecomplexfactory.m:54
    
@function
def dist(x=None,y=None,*args,**kwargs):
    varargin = dist.varargin
    nargin = dist.nargin

    d=real(acos(real(dot(ravel(x).T,ravel(y)))))
# sphere/spherecomplexfactory.m:56
    
    # close together. In that case, norm is a much better proxy.
    if d < 1e-07:
        d=norm(x - y,'fro')
# sphere/spherecomplexfactory.m:60
    
    return d
    
if __name__ == '__main__':
    pass
    
    
    M.typicaldist = copy(lambda : pi)
# sphere/spherecomplexfactory.m:64
    M.proj = copy(lambda x=None,d=None: reshape(ravel(d) - dot(ravel(x),(real(dot(ravel(x).T,ravel(d))))),n,m))
# sphere/spherecomplexfactory.m:66
    
    # Riemannian gradient amounts to an orthogonal projection.
    M.egrad2rgrad = copy(M.proj)
# sphere/spherecomplexfactory.m:70
    M.ehess2rhess = copy(ehess2rhess)
# sphere/spherecomplexfactory.m:72
    
@function
def ehess2rhess(x=None,egrad=None,ehess=None,u=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    rhess=M.proj(x,ehess) - dot(real((dot(ravel(x).T,ravel(egrad)))),u)
# sphere/spherecomplexfactory.m:74
    return rhess
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(M.proj)
# sphere/spherecomplexfactory.m:77
    M.exp = copy(exponential)
# sphere/spherecomplexfactory.m:79
    M.retr = copy(retraction)
# sphere/spherecomplexfactory.m:81
    M.log = copy(logarithm)
# sphere/spherecomplexfactory.m:83
    
@function
def logarithm(x1=None,x2=None,*args,**kwargs):
    varargin = logarithm.varargin
    nargin = logarithm.nargin

    v=M.proj(x1,x2 - x1)
# sphere/spherecomplexfactory.m:85
    di=M.dist(x1,x2)
# sphere/spherecomplexfactory.m:86
    
    if di > 1e-06:
        nv=norm(v,'fro')
# sphere/spherecomplexfactory.m:89
        v=dot(v,(di / nv))
# sphere/spherecomplexfactory.m:90
    
    return v
    
if __name__ == '__main__':
    pass
    
    
    M.hash = copy(lambda x=None: cat('z',hashmd5(cat([real(ravel(x))],[imag(ravel(x))]))))
# sphere/spherecomplexfactory.m:94
    M.rand = copy(lambda : random(n,m))
# sphere/spherecomplexfactory.m:96
    M.randvec = copy(lambda x=None: randomvec(n,m,x))
# sphere/spherecomplexfactory.m:98
    M.lincomb = copy(matrixlincomb)
# sphere/spherecomplexfactory.m:100
    M.zerovec = copy(lambda x=None: zeros(n,m))
# sphere/spherecomplexfactory.m:102
    M.transp = copy(lambda x1=None,x2=None,d=None: M.proj(x2,d))
# sphere/spherecomplexfactory.m:104
    M.pairmean = copy(pairmean)
# sphere/spherecomplexfactory.m:106
    
@function
def pairmean(x1=None,x2=None,*args,**kwargs):
    varargin = pairmean.varargin
    nargin = pairmean.nargin

    y=x1 + x2
# sphere/spherecomplexfactory.m:108
    y=y / norm(y,'fro')
# sphere/spherecomplexfactory.m:109
    return y
    
if __name__ == '__main__':
    pass
    
    mn=dot(m,n)
# sphere/spherecomplexfactory.m:112
    M.vec = copy(lambda x=None,u_mat=None: cat([real(ravel(u_mat))],[imag(ravel(u_mat))]))
# sphere/spherecomplexfactory.m:113
    M.mat = copy(lambda x=None,u_vec=None: reshape(u_vec[1:mn],m,n) + dot(1j,reshape(u_vec[(mn + 1):end()],m,n)))
# sphere/spherecomplexfactory.m:114
    M.vecmatareisometries = copy(lambda : true)
# sphere/spherecomplexfactory.m:115
    return y
    
if __name__ == '__main__':
    pass
    
    # Exponential on the sphere
    
@function
def exponential(x=None,d=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin == 2:
        # t = 1;
        td=copy(d)
# sphere/spherecomplexfactory.m:124
    else:
        td=dot(t,d)
# sphere/spherecomplexfactory.m:126
    
    
    nrm_td=norm(td,'fro')
# sphere/spherecomplexfactory.m:129
    if nrm_td > 0:
        y=dot(x,cos(nrm_td)) + dot(td,(sin(nrm_td) / nrm_td))
# sphere/spherecomplexfactory.m:132
    else:
        y=copy(x)
# sphere/spherecomplexfactory.m:134
    
    return y
    
if __name__ == '__main__':
    pass
    
    # Retraction on the sphere
    
@function
def retraction(x=None,d=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin == 2:
        t=1
# sphere/spherecomplexfactory.m:143
    
    
    y=x + dot(t,d)
# sphere/spherecomplexfactory.m:146
    y=y / norm(y,'fro')
# sphere/spherecomplexfactory.m:147
    return y
    
if __name__ == '__main__':
    pass
    
    # Uniform random sampling on the sphere.
    
@function
def random(n=None,m=None,*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    x=randn(n,m) + dot(1j,randn(n,m))
# sphere/spherecomplexfactory.m:154
    x=x / norm(x,'fro')
# sphere/spherecomplexfactory.m:155
    return x
    
if __name__ == '__main__':
    pass
    
    # Random normalized tangent vector at x.
    
@function
def randomvec(n=None,m=None,x=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    d=randn(n,m) + dot(1j,randn(n,m))
# sphere/spherecomplexfactory.m:162
    d=reshape(ravel(d) - dot(ravel(x),(real(dot(ravel(x).T,ravel(d))))),n,m)
# sphere/spherecomplexfactory.m:163
    d=d / norm(d,'fro')
# sphere/spherecomplexfactory.m:164
    return d
    
if __name__ == '__main__':
    pass
    