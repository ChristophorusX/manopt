# Autogenerated with SMOP 
from smop.core import *
# grassmann/grassmannfactory.m

    
@function
def grassmannfactory(n=None,p=None,k=None,*args,**kwargs):
    varargin = grassmannfactory.varargin
    nargin = grassmannfactory.nargin

    # Returns a manifold struct to optimize over the space of vector subspaces.
    
    # function M = grassmannfactory(n, p)
# function M = grassmannfactory(n, p, k)
    
    # Grassmann manifold: each point on this manifold is a collection of k
# vector subspaces of dimension p embedded in R^n.
    
    # The metric is obtained by making the Grassmannian a Riemannian quotient
# manifold of the Stiefel manifold, i.e., the manifold of orthonormal
# matrices, itself endowed with a metric by making it a Riemannian
# submanifold of the Euclidean space, endowed with the usual inner product.
# In short: it is the usual metric used in most cases.
# 
# This structure deals with matrices X of size n x p x k (or n x p if
# k = 1, which is the default) such that each n x p matrix is orthonormal,
# i.e., X'*X = eye(p) if k = 1, or X(:, :, i)' * X(:, :, i) = eye(p) for
# i = 1 : k if k > 1. Each n x p matrix is a numerical representation of
# the vector subspace its columns span.
    
    # By default, k = 1.
    
    # See also: stiefelfactory grassmanncomplexfactory grassmanngeneralizedfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Dec. 30, 2012.
# Contributors: 
# Change log: 
#   March 22, 2013 (NB) :
#       Implemented geodesic distance.
# 
#   April 17, 2013 (NB) :
#       Retraction changed to the polar decomposition, so that the vector
#       transport is now correct, in the sense that it is compatible with
#       the retraction, i.e., transporting a tangent vector G from U to V
#       where V = Retr(U, H) will give Z, and transporting GQ from UQ to VQ
#       will give ZQ: there is no dependence on the representation, which
#       is as it should be. Notice that the polar factorization requires an
#       SVD whereas the qfactor retraction requires a QR decomposition,
#       which is cheaper. Hence, if the retraction happens to be a
#       bottleneck in your application and you are not using vector
#       transports, you may want to replace the retraction with a qfactor.
# 
#   July  4, 2013 (NB) :
#       Added support for the logarithmic map 'log'.
    
    #   July  5, 2013 (NB) :
#       Added support for ehess2rhess.
    
    #   June 24, 2014 (NB) :
#       Small bug fix in the retraction, and added final
#       re-orthonormalization at the end of the exponential map. This
#       follows discussions on the forum where it appeared there is a
#       significant loss in orthonormality without that extra step. Also
#       changed the randvec function so that it now returns a globally
#       normalized vector, not a vector where each component is normalized
#       (this only matters if k>1).
    
    assert_(n >= p,cat('The dimension n of the ambient space must be larger ','than the dimension p of the subspaces.'))
    if logical_not(exist('k','var')) or isempty(k):
        k=1
# grassmann/grassmannfactory.m:65
    
    
    if k == 1:
        M.name = copy(lambda : sprintf('Grassmann manifold Gr(%d, %d)',n,p))
# grassmann/grassmannfactory.m:69
    else:
        if k > 1:
            M.name = copy(lambda : sprintf('Multi Grassmann manifold Gr(%d, %d)^%d',n,p,k))
# grassmann/grassmannfactory.m:71
        else:
            error('k must be an integer no less than 1.')
    
    
    M.dim = copy(lambda : dot(dot(k,p),(n - p)))
# grassmann/grassmannfactory.m:77
    M.inner = copy(lambda x=None,d1=None,d2=None: dot(ravel(d1).T,ravel(d2)))
# grassmann/grassmannfactory.m:79
    M.norm = copy(lambda x=None,d=None: norm(ravel(d)))
# grassmann/grassmannfactory.m:81
    M.dist = copy(distance)
# grassmann/grassmannfactory.m:83
    
@function
def distance(x=None,y=None,*args,**kwargs):
    varargin = distance.varargin
    nargin = distance.nargin

    square_d=0
# grassmann/grassmannfactory.m:85
    XtY=multiprod(multitransp(x),y)
# grassmann/grassmannfactory.m:86
    for i in arange(1,k).reshape(-1):
        cos_princ_angle=svd(XtY[:,:,i])
# grassmann/grassmannfactory.m:88
        square_d=square_d + sum(real(acos(cos_princ_angle)) ** 2)
# grassmann/grassmannfactory.m:89
    
    d=sqrt(square_d)
# grassmann/grassmannfactory.m:91
    return d
    
if __name__ == '__main__':
    pass
    
    
    M.typicaldist = copy(lambda : sqrt(dot(p,k)))
# grassmann/grassmannfactory.m:94
    
    # at X.
    M.proj = copy(projection)
# grassmann/grassmannfactory.m:98
    
@function
def projection(X=None,U=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    
    XtU=multiprod(multitransp(X),U)
# grassmann/grassmannfactory.m:101
    Up=U - multiprod(X,XtU)
# grassmann/grassmannfactory.m:102
    return Up
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(M.proj)
# grassmann/grassmannfactory.m:106
    M.egrad2rgrad = copy(M.proj)
# grassmann/grassmannfactory.m:108
    M.ehess2rhess = copy(ehess2rhess)
# grassmann/grassmannfactory.m:110
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,H=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    PXehess=projection(X,ehess)
# grassmann/grassmannfactory.m:112
    XtG=multiprod(multitransp(X),egrad)
# grassmann/grassmannfactory.m:113
    HXtG=multiprod(H,XtG)
# grassmann/grassmannfactory.m:114
    rhess=PXehess - HXtG
# grassmann/grassmannfactory.m:115
    return rhess
    
if __name__ == '__main__':
    pass
    
    
    M.retr = copy(retraction)
# grassmann/grassmannfactory.m:118
    
@function
def retraction(X=None,U=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# grassmann/grassmannfactory.m:121
    
    Y=X + dot(t,U)
# grassmann/grassmannfactory.m:123
    for i in arange(1,k).reshape(-1):
        # Compute the polar factorization of Y = X+tU
        u,s,v=svd(Y[:,:,i],'econ',nargout=3)
# grassmann/grassmannfactory.m:127
        Y[:,:,i]=dot(u,v.T)
# grassmann/grassmannfactory.m:128
        # As compared with the Stiefel factory, we do not need to
			# worry about flipping signs of columns here, since only
			# the column space is important, not the actual columns.
            # [Q, unused] = qr(Y(:, :, i), 0); ##ok
            # Y(:, :, i) = Q;
    
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# grassmann/grassmannfactory.m:140
    
@function
def exponential(X=None,U=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin == 3:
        tU=dot(t,U)
# grassmann/grassmannfactory.m:143
    else:
        tU=copy(U)
# grassmann/grassmannfactory.m:145
    
    Y=zeros(size(X))
# grassmann/grassmannfactory.m:147
    for i in arange(1,k).reshape(-1):
        u,s,v=svd(tU[:,:,i],0,nargout=3)
# grassmann/grassmannfactory.m:149
        cos_s=diag(cos(diag(s)))
# grassmann/grassmannfactory.m:150
        sin_s=diag(sin(diag(s)))
# grassmann/grassmannfactory.m:151
        Y[:,:,i]=dot(dot(dot(X[:,:,i],v),cos_s),v.T) + dot(dot(u,sin_s),v.T)
# grassmann/grassmannfactory.m:152
        # re-orthonormalize. This is overall quite expensive.
        q,unused=qr(Y[:,:,i],0,nargout=2)
# grassmann/grassmannfactory.m:155
        Y[:,:,i]=q
# grassmann/grassmannfactory.m:156
    
    return Y
    
if __name__ == '__main__':
    pass
    
    # Test code for the logarithm:
    # Gr = grassmannfactory(5, 2, 3);
    # x = Gr.rand()
    # y = Gr.rand()
    # u = Gr.log(x, y)
    # Gr.dist(x, y) # These two numbers should
    # Gr.norm(x, u) # be the same.
    # z = Gr.exp(x, u) # z needs not be the same matrix as y, but it should
    # v = Gr.log(x, z) # be the same point as y on Grassmann: dist almost 0.
    M.log = copy(logarithm)
# grassmann/grassmannfactory.m:169
    
@function
def logarithm(X=None,Y=None,*args,**kwargs):
    varargin = logarithm.varargin
    nargin = logarithm.nargin

    U=zeros(n,p,k)
# grassmann/grassmannfactory.m:171
    for i in arange(1,k).reshape(-1):
        x=X[:,:,i]
# grassmann/grassmannfactory.m:173
        y=Y[:,:,i]
# grassmann/grassmannfactory.m:174
        ytx=dot(y.T,x)
# grassmann/grassmannfactory.m:175
        At=y.T - dot(ytx,x.T)
# grassmann/grassmannfactory.m:176
        Bt=numpy.linalg.solve(ytx,At)
# grassmann/grassmannfactory.m:177
        u,s,v=svd(Bt.T,'econ',nargout=3)
# grassmann/grassmannfactory.m:178
        u=u[:,1:p]
# grassmann/grassmannfactory.m:180
        s=diag(s)
# grassmann/grassmannfactory.m:181
        s=s[1:p]
# grassmann/grassmannfactory.m:182
        v=v[:,1:p]
# grassmann/grassmannfactory.m:183
        U[:,:,i]=dot(dot(u,diag(atan(s))),v.T)
# grassmann/grassmannfactory.m:185
    
    return U
    
if __name__ == '__main__':
    pass
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(ravel(X))))
# grassmann/grassmannfactory.m:189
    M.rand = copy(random)
# grassmann/grassmannfactory.m:191
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    X=zeros(n,p,k)
# grassmann/grassmannfactory.m:193
    for i in arange(1,k).reshape(-1):
        Q,unused=qr(randn(n,p),0,nargout=2)
# grassmann/grassmannfactory.m:195
        X[:,:,i]=Q
# grassmann/grassmannfactory.m:196
    
    return X
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# grassmann/grassmannfactory.m:200
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    U=projection(X,randn(n,p,k))
# grassmann/grassmannfactory.m:202
    U=U / norm(ravel(U))
# grassmann/grassmannfactory.m:203
    return U
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(matrixlincomb)
# grassmann/grassmannfactory.m:206
    M.zerovec = copy(lambda x=None: zeros(n,p,k))
# grassmann/grassmannfactory.m:208
    
    M.transp = copy(lambda x1=None,x2=None,d=None: projection(x2,d))
# grassmann/grassmannfactory.m:211
    M.vec = copy(lambda x=None,u_mat=None: ravel(u_mat))
# grassmann/grassmannfactory.m:213
    M.mat = copy(lambda x=None,u_vec=None: reshape(u_vec,cat(n,p,k)))
# grassmann/grassmannfactory.m:214
    M.vecmatareisometries = copy(lambda : true)
# grassmann/grassmannfactory.m:215
    return U
    
if __name__ == '__main__':
    pass
    