# Autogenerated with SMOP 
from smop.core import *
# oblique/obliquefactory.m

    
@function
def obliquefactory(n=None,m=None,transposed=None,*args,**kwargs):
    varargin = obliquefactory.varargin
    nargin = obliquefactory.nargin

    # Returns a manifold struct to optimize over matrices w/ unit-norm columns.
    
    # function M = obliquefactory(n, m)
# function M = obliquefactory(n, m, transposed)
    
    # Oblique manifold: deals with matrices of size n x m such that each column
# has unit 2-norm, i.e., is a point on the unit sphere in R^n. The metric
# is such that the oblique manifold is a Riemannian submanifold of the
# space of nxm matrices with the usual trace inner product, i.e., the usual
# metric.
    
    # If transposed is set to true (it is false by default), then the matrices
# are transposed: a point Y on the manifold is a matrix of size m x n and
# each row has unit 2-norm. It is the same geometry, just a different
# representation.
    
    # See also: spherefactory obliquecomplexfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Dec. 30, 2012.
# Contributors: 
# Change log:
    
    #	July 16, 2013 (NB) :
#       Added 'transposed' option, mainly for ease of comparison with the
#       elliptope geometry.
    
    #	Nov. 29, 2013 (NB) :
#       Added normalize_columns function to make it easier to exploit the
#       bsxfun formulation of column normalization, which avoids using for
#       loops and provides performance gains. The exponential still uses a
#       for loop.
    
    #	April 4, 2015 (NB) :
#       Log function modified to avoid NaN's appearing for close by points.
    
    #	April 13, 2015 (NB) :
#       Exponential now without for-loops.
    
    #   Oct. 8, 2016 (NB)
#       Code for exponential was simplified to only treat the zero vector
#       as a particular case.
    
    #  Oct. 21, 2016 (NB)
#       Bug caught in M.log: the function called v = M.proj(x1, x2 - x1),
#       which internally applies transp to inputs and outputs. But since
#       M.log had already taken care of transposing things, this introduced
#       a bug (which only triggered if using M.log in transposed mode.)
#       The code no calls "v = projection(x1, x2 - x1);" since projection
#       assumes the inputs and outputs do not need to be transposed.
    
    
    if logical_not(exist('transposed','var')) or isempty(transposed):
        transposed=copy(false)
# oblique/obliquefactory.m:55
    
    
    if transposed:
        trnsp=lambda X=None: X.T
# oblique/obliquefactory.m:59
    else:
        trnsp=lambda X=None: X
# oblique/obliquefactory.m:61
    
    M.name = copy(lambda : sprintf('Oblique manifold OB(%d, %d)',n,m))
# oblique/obliquefactory.m:64
    M.dim = copy(lambda : dot((n - 1),m))
# oblique/obliquefactory.m:66
    M.inner = copy(lambda x=None,d1=None,d2=None: dot(ravel(d1).T,ravel(d2)))
# oblique/obliquefactory.m:68
    M.norm = copy(lambda x=None,d=None: norm(ravel(d)))
# oblique/obliquefactory.m:70
    M.dist = copy(lambda x=None,y=None: norm(real(acos(sum(multiply(trnsp[x],trnsp[y]),1)))))
# oblique/obliquefactory.m:72
    M.typicaldist = copy(lambda : dot(pi,sqrt(m)))
# oblique/obliquefactory.m:74
    M.proj = copy(lambda X=None,U=None: trnsp[projection(trnsp[X],trnsp[U])])
# oblique/obliquefactory.m:76
    M.tangent = copy(M.proj)
# oblique/obliquefactory.m:78
    
    # Riemannian gradient amounts to an orthogonal projection.
    M.egrad2rgrad = copy(M.proj)
# oblique/obliquefactory.m:82
    M.ehess2rhess = copy(ehess2rhess)
# oblique/obliquefactory.m:84
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,U=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    X=trnsp[X]
# oblique/obliquefactory.m:86
    egrad=trnsp[egrad]
# oblique/obliquefactory.m:87
    ehess=trnsp[ehess]
# oblique/obliquefactory.m:88
    U=trnsp[U]
# oblique/obliquefactory.m:89
    PXehess=projection(X,ehess)
# oblique/obliquefactory.m:91
    inners=sum(multiply(X,egrad),1)
# oblique/obliquefactory.m:92
    rhess=PXehess - bsxfun(times,U,inners)
# oblique/obliquefactory.m:93
    rhess=trnsp[rhess]
# oblique/obliquefactory.m:95
    return rhess
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# oblique/obliquefactory.m:98
    
    
@function
def exponential(x=None,d=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    x=trnsp[x]
# oblique/obliquefactory.m:101
    d=trnsp[d]
# oblique/obliquefactory.m:102
    if nargin < 3:
        # t = 1;
        td=copy(d)
# oblique/obliquefactory.m:106
    else:
        td=dot(t,d)
# oblique/obliquefactory.m:108
    
    nrm_td=sqrt(sum(td ** 2,1))
# oblique/obliquefactory.m:111
    y=bsxfun(times,x,cos(nrm_td)) + bsxfun(times,td,sin(nrm_td) / nrm_td)
# oblique/obliquefactory.m:113
    
    exclude=(nrm_td == 0)
# oblique/obliquefactory.m:117
    y[:,exclude]=x[:,exclude]
# oblique/obliquefactory.m:118
    y=trnsp[y]
# oblique/obliquefactory.m:120
    return y
    
if __name__ == '__main__':
    pass
    
    M.log = copy(logarithm)
# oblique/obliquefactory.m:123
    
@function
def logarithm(x1=None,x2=None,*args,**kwargs):
    varargin = logarithm.varargin
    nargin = logarithm.nargin

    x1=trnsp[x1]
# oblique/obliquefactory.m:125
    x2=trnsp[x2]
# oblique/obliquefactory.m:126
    v=projection(x1,x2 - x1)
# oblique/obliquefactory.m:128
    dists=real(acos(sum(multiply(x1,x2),1)))
# oblique/obliquefactory.m:129
    norms=real(sqrt(sum(v ** 2,1)))
# oblique/obliquefactory.m:130
    factors=dists / norms
# oblique/obliquefactory.m:131
    
    # that their ratio approaches zero. But in practice, dist can be
        # inaccurate for nearby points. Thus, below a certain threshold, we
        # force the ratio to 1. This also avoids issues of divisions by 0.
    factors[dists <= 1e-06]=1
# oblique/obliquefactory.m:136
    v=bsxfun(times,v,factors)
# oblique/obliquefactory.m:137
    v=trnsp[v]
# oblique/obliquefactory.m:139
    return v
    
if __name__ == '__main__':
    pass
    
    M.retr = copy(retraction)
# oblique/obliquefactory.m:142
    
    
@function
def retraction(x=None,d=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    x=trnsp[x]
# oblique/obliquefactory.m:145
    d=trnsp[d]
# oblique/obliquefactory.m:146
    if nargin < 3:
        # t = 1;
        td=copy(d)
# oblique/obliquefactory.m:150
    else:
        td=dot(t,d)
# oblique/obliquefactory.m:152
    
    
    y=normalize_columns(x + td)
# oblique/obliquefactory.m:155
    y=trnsp[y]
# oblique/obliquefactory.m:157
    return y
    
if __name__ == '__main__':
    pass
    
    M.hash = copy(lambda x=None: cat('z',hashmd5(ravel(x))))
# oblique/obliquefactory.m:160
    M.rand = copy(lambda : trnsp[random(n,m)])
# oblique/obliquefactory.m:162
    M.randvec = copy(lambda x=None: trnsp[randomvec(n,m,trnsp[x])])
# oblique/obliquefactory.m:164
    M.lincomb = copy(matrixlincomb)
# oblique/obliquefactory.m:166
    M.zerovec = copy(lambda x=None: trnsp[zeros(n,m)])
# oblique/obliquefactory.m:168
    M.transp = copy(lambda x1=None,x2=None,d=None: M.proj(x2,d))
# oblique/obliquefactory.m:170
    M.pairmean = copy(pairmean)
# oblique/obliquefactory.m:172
    
@function
def pairmean(x1=None,x2=None,*args,**kwargs):
    varargin = pairmean.varargin
    nargin = pairmean.nargin

    y=trnsp[x1 + x2]
# oblique/obliquefactory.m:174
    y=normalize_columns(y)
# oblique/obliquefactory.m:175
    y=trnsp[y]
# oblique/obliquefactory.m:176
    return y
    
if __name__ == '__main__':
    pass
    
    # vec returns a vector representation of an input tangent vector which
    # is represented as a matrix. mat returns the original matrix
    # representation of the input vector representation of a tangent
    # vector. vec and mat are thus inverse of each other. They are
    # furthermore isometries between a subspace of R^nm and the tangent
    # space at x.
    vect=lambda X=None: ravel(X)
# oblique/obliquefactory.m:185
    M.vec = copy(lambda x=None,u_mat=None: vect[trnsp[u_mat]])
# oblique/obliquefactory.m:186
    M.mat = copy(lambda x=None,u_vec=None: trnsp[reshape(u_vec,cat(n,m))])
# oblique/obliquefactory.m:187
    M.vecmatareisometries = copy(lambda : true)
# oblique/obliquefactory.m:188
    return y
    
if __name__ == '__main__':
    pass
    
    # Given a matrix X, returns the same matrix but with each column scaled so
# that they have unit 2-norm.
    
@function
def normalize_columns(X=None,*args,**kwargs):
    varargin = normalize_columns.varargin
    nargin = normalize_columns.nargin

    # This is faster than norms(X, 2, 1) for small X, and as fast for large X.
    nrms=sqrt(sum(X ** 2,1))
# oblique/obliquefactory.m:196
    X=bsxfun(times,X,1.0 / nrms)
# oblique/obliquefactory.m:197
    return X
    
if __name__ == '__main__':
    pass
    
    # Orthogonal projection of the ambient vector H onto the tangent space at X
    
@function
def projection(X=None,H=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    # Compute the inner product between each vector H(:, i) with its root
    # point X(:, i), that is, X(:, i).' * H(:, i). Returns a row vector.
    inners=sum(multiply(X,H),1)
# oblique/obliquefactory.m:205
    
    # the root points X(:, i).
    PXH=H - bsxfun(times,X,inners)
# oblique/obliquefactory.m:209
    
    # m = size(X, 2);
    # PXH = zeros(size(H));
    # for i = 1 : m
    #     PXH(:, i) = H(:, i) - X(:, i) * (X(:, i)'*H(:, i));
    # end
    
    return PXH
    
if __name__ == '__main__':
    pass
    
    # Uniform random sampling on the sphere.
    
@function
def random(n=None,m=None,*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    x=normalize_columns(randn(n,m))
# oblique/obliquefactory.m:223
    return x
    
if __name__ == '__main__':
    pass
    
    # Random normalized tangent vector at x.
    
@function
def randomvec(n=None,m=None,x=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    d=randn(n,m)
# oblique/obliquefactory.m:230
    d=projection(x,d)
# oblique/obliquefactory.m:231
    d=d / norm(ravel(d))
# oblique/obliquefactory.m:232
    return d
    
if __name__ == '__main__':
    pass
    