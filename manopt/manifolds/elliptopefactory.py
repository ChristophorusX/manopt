# Autogenerated with SMOP 
from smop.core import *
# symfixedrank/elliptopefactory.m

    
@function
def elliptopefactory(n=None,k=None,*args,**kwargs):
    varargin = elliptopefactory.varargin
    nargin = elliptopefactory.nargin

    # Manifold of n-by-n psd matrices of rank k with unit diagonal elements.
    
    # function M = elliptopefactory(n, k)
    
    # A point X on the manifold is parameterized as YY^T where Y is a matrix of
# size nxk. As such, X is symmetric, positive semidefinite. We restrict to
# full-rank Y's, such that X has rank exactly k. The point X is numerically
# represented by Y (this is more efficient than working with X, which may
# be big). Tangent vectors are represented as matrices of the same size as
# Y, call them Ydot, so that Xdot = Y Ydot' + Ydot Y and diag(Xdot) == 0.
# The metric is the canonical Euclidean metric on Y.
# 
# The diagonal constraints on X (X(i, i) == 1 for all i) translate to
# unit-norm constraints on the rows of Y: norm(Y(i, :)) == 1 for all i.
# The set of such Y's forms the oblique manifold. But because for any
# orthogonal Q of size k, it holds that (YQ)(YQ)' = YY', we "group" all
# matrices of the form YQ in an equivalence class. The set of equivalence
# classes is a Riemannian quotient manifold, implemented here.
    
    # Note that this geometry formally breaks down at rank-deficient Y's.
# This does not appear to be a major issue in practice when optimization
# algorithms converge to rank-deficient Y's, but convergence theorems no
# longer hold. As an alternative, you may use the oblique manifold (it has
# larger dimension, but does not break down at rank drop.)
    
    # The geometry is taken from the 2010 paper:
# M. Journee, P.-A. Absil, F. Bach and R. Sepulchre,
# "Low-Rank Optimization on the Cone of Positive Semidefinite Matrices".
# Paper link: http://www.di.ens.fr/~fbach/journee2010_sdp.pdf
# 
# 
# Please cite the Manopt paper as well as the research paper:
#     @Article{journee2010low,
#       Title   = {Low-rank optimization on the cone of positive semidefinite matrices},
#       Author  = {Journ{\'e}e, M. and Bach, F. and Absil, P.-A. and Sepulchre, R.},
#       Journal = {SIAM Journal on Optimization},
#       Year    = {2010},
#       Number  = {5},
#       Pages   = {2327--2351},
#       Volume  = {20},
#       Doi     = {10.1137/080731359}
#     }
#
    
    # See also: obliquefactory symfixedrankYYfactory spectrahedronfactory
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Bamdev Mishra, July 12, 2013.
# Contributors:
# Change log:
#   July 18, 2013 (NB):
#       Fixed projection operator for rank-deficient Y'Y.
# 
#   Aug.  8, 2013 (NB):
#       No longer using nested functions, to aim at Octave compatibility.
#       Sign error in right hand side of the call to minres corrected.
# 
#   June 24, 2014 (NB):
#       Used code snippets from obliquefactory to speed up projection,
#       retraction, egrad2rgrad and rand: the code now uses bsxfun for this.
# 
#   April 3, 2015 (NB):
#       Replaced trace(A'*B) by A(:)'*B(:) : equivalent but faster.
    
    # TODO: modify normalize_rows and project_rows to work without transposes.
# TODO: enhance ehess2rhess to also use bsxfun.
    
    
    if logical_not(exist('lyap','file')):
        warning('manopt:elliptopefactory:slowlyap',cat('The function lyap to solve Lyapunov equations seems not to ','be available. This may slow down optimization over this ','manifold significantly. lyap is part of the control system ','toolbox.'))
    
    
    
    M.name = copy(lambda : sprintf('YY\' quotient manifold of %dx%d psd matrices of rank %d with diagonal elements being 1',n,k))
# symfixedrank/elliptopefactory.m:79
    M.dim = copy(lambda : dot(n,(k - 1)) - dot(k,(k - 1)) / 2)
# symfixedrank/elliptopefactory.m:81
    
    
    # Euclidean metric on the total space
    M.inner = copy(lambda Y=None,eta=None,zeta=None: dot(ravel(eta).T,ravel(zeta)))
# symfixedrank/elliptopefactory.m:84
    M.norm = copy(lambda Y=None,eta=None: sqrt(M.inner(Y,eta,eta)))
# symfixedrank/elliptopefactory.m:86
    M.dist = copy(lambda Y=None,Z=None: error('elliptopefactory.dist not implemented yet.'))
# symfixedrank/elliptopefactory.m:88
    M.typicaldist = copy(lambda : dot(10,k))
# symfixedrank/elliptopefactory.m:90
    M.proj = copy(projection)
# symfixedrank/elliptopefactory.m:92
    M.tangent = copy(M.proj)
# symfixedrank/elliptopefactory.m:94
    M.tangent2ambient = copy(lambda Y=None,eta=None: eta)
# symfixedrank/elliptopefactory.m:95
    M.retr = copy(retraction)
# symfixedrank/elliptopefactory.m:97
    M.egrad2rgrad = copy(egrad2rgrad)
# symfixedrank/elliptopefactory.m:99
    M.ehess2rhess = copy(ehess2rhess)
# symfixedrank/elliptopefactory.m:101
    M.exp = copy(exponential)
# symfixedrank/elliptopefactory.m:103
    
    M.hash = copy(lambda Y=None: cat('z',hashmd5(ravel(Y))))
# symfixedrank/elliptopefactory.m:106
    M.rand = copy(lambda : random(n,k))
# symfixedrank/elliptopefactory.m:108
    M.randvec = copy(randomvec)
# symfixedrank/elliptopefactory.m:110
    M.lincomb = copy(matrixlincomb)
# symfixedrank/elliptopefactory.m:112
    M.zerovec = copy(lambda Y=None: zeros(n,k))
# symfixedrank/elliptopefactory.m:114
    M.transp = copy(lambda Y1=None,Y2=None,d=None: projection(Y2,d))
# symfixedrank/elliptopefactory.m:116
    M.vec = copy(lambda Y=None,u_mat=None: ravel(u_mat))
# symfixedrank/elliptopefactory.m:118
    M.mat = copy(lambda Y=None,u_vec=None: reshape(u_vec,cat(n,k)))
# symfixedrank/elliptopefactory.m:119
    M.vecmatareisometries = copy(lambda : true)
# symfixedrank/elliptopefactory.m:120
    return M
    
if __name__ == '__main__':
    pass
    
    # Given a matrix X, returns the same matrix but with each column scaled so
# that they have unit 2-norm.
# See obliquefactory.
    
@function
def normalize_rows(X=None,*args,**kwargs):
    varargin = normalize_rows.varargin
    nargin = normalize_rows.nargin

    X=X.T
# symfixedrank/elliptopefactory.m:128
    norms=sqrt(sum(X ** 2,1))
# symfixedrank/elliptopefactory.m:129
    X=bsxfun(times,X,1.0 / norms)
# symfixedrank/elliptopefactory.m:130
    X=X.T
# symfixedrank/elliptopefactory.m:131
    return X
    
if __name__ == '__main__':
    pass
    
    # Orthogonal projection of each row of H to the tangent space at the
# corresponding row of X, seen as a point on a sphere.
# See obliquefactory.
    
@function
def project_rows(X=None,H=None,*args,**kwargs):
    varargin = project_rows.varargin
    nargin = project_rows.nargin

    X=X.T
# symfixedrank/elliptopefactory.m:138
    H=H.T
# symfixedrank/elliptopefactory.m:139
    
    # point X(:, i), that is, X(:, i).' * H(:, i). Returns a row vector.
    inners=sum(multiply(X,H),1)
# symfixedrank/elliptopefactory.m:142
    
    # the root points X(:, i).
    PXH=H - bsxfun(times,X,inners)
# symfixedrank/elliptopefactory.m:145
    PXH=PXH.T
# symfixedrank/elliptopefactory.m:146
    return PXH
    
if __name__ == '__main__':
    pass
    
    # Projection onto the tangent space, i.e., on the tangent space of
# ||Y(i, :)|| = 1
    
@function
def projection(Y=None,eta=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    unused,k=size(Y,nargout=2)
# symfixedrank/elliptopefactory.m:153
    
    eta=project_rows(Y,eta)
# symfixedrank/elliptopefactory.m:154
    
    YtY=dot(Y.T,Y)
# symfixedrank/elliptopefactory.m:157
    SS=copy(YtY)
# symfixedrank/elliptopefactory.m:158
    AS=dot(Y.T,eta) - dot(eta.T,Y)
# symfixedrank/elliptopefactory.m:159
    try:
        # This is supposed to work and indeed return a skew-symmetric
        # solution Omega.
        Omega=lyap(SS,- AS)
# symfixedrank/elliptopefactory.m:163
    finally:
        pass
    
    # # Make sure the result is skew-symmetric (does not seem necessary).
    # Omega = (Omega-Omega')/2;
    etaproj=eta - dot(Y,Omega)
# symfixedrank/elliptopefactory.m:183
    return etaproj
    
if __name__ == '__main__':
    pass
    
    # Retraction
    
@function
def retraction(Y=None,eta=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# symfixedrank/elliptopefactory.m:189
    
    Ynew=Y + dot(t,eta)
# symfixedrank/elliptopefactory.m:191
    Ynew=normalize_rows(Ynew)
# symfixedrank/elliptopefactory.m:192
    return Ynew
    
if __name__ == '__main__':
    pass
    
    # Exponential map
    
@function
def exponential(Y=None,eta=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin < 3:
        t=1.0
# symfixedrank/elliptopefactory.m:198
    
    Ynew=retraction(Y,eta,t)
# symfixedrank/elliptopefactory.m:201
    warning('manopt:elliptopefactory:exp',cat('Exponential for fixed rank spectrahedron ','manifold not implemented yet. Used retraction instead.\\n','To disable this warning: warning(\'off\', \'manopt:elliptopefactory:exp\')'))
    return Ynew
    
if __name__ == '__main__':
    pass
    
    # Euclidean gradient to Riemannian gradient conversion.
# We only need the ambient space projection: the remainder of the
# projection function is not necessary because the Euclidean gradient must
# already be orthogonal to the vertical space.
    
@function
def egrad2rgrad(Y=None,egrad=None,*args,**kwargs):
    varargin = egrad2rgrad.varargin
    nargin = egrad2rgrad.nargin

    rgrad=project_rows(Y,egrad)
# symfixedrank/elliptopefactory.m:213
    return rgrad
    
if __name__ == '__main__':
    pass
    
    # Euclidean Hessian to Riemannian Hessian conversion.
# TODO: speed this function up using bsxfun.
    
@function
def ehess2rhess(Y=None,egrad=None,ehess=None,eta=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    k=size(Y,2)
# symfixedrank/elliptopefactory.m:219
    
    scaling_grad=sum((multiply(egrad,Y)),2)
# symfixedrank/elliptopefactory.m:222
    
    scaling_grad_repeat=dot(scaling_grad,ones(1,k))
# symfixedrank/elliptopefactory.m:223
    Hess=ehess - multiply(scaling_grad_repeat,eta)
# symfixedrank/elliptopefactory.m:225
    scaling_hess=sum((multiply(eta,egrad)) + (multiply(Y,ehess)),2)
# symfixedrank/elliptopefactory.m:227
    scaling_hess_repeat=dot(scaling_hess,ones(1,k))
# symfixedrank/elliptopefactory.m:228
    
    Hess=Hess - multiply(scaling_hess_repeat,Y)
# symfixedrank/elliptopefactory.m:230
    
    Hess=projection(Y,Hess)
# symfixedrank/elliptopefactory.m:233
    return Hess
    
if __name__ == '__main__':
    pass
    
    # Random point generation on the manifold
    
@function
def random(n=None,k=None,*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    Y=randn(n,k)
# symfixedrank/elliptopefactory.m:238
    Y=normalize_rows(Y)
# symfixedrank/elliptopefactory.m:239
    return Y
    
if __name__ == '__main__':
    pass
    
    # Random vector generation at Y
    
@function
def randomvec(Y=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    eta=randn(size(Y))
# symfixedrank/elliptopefactory.m:244
    eta=projection(Y,eta)
# symfixedrank/elliptopefactory.m:245
    nrm=norm(eta,'fro')
# symfixedrank/elliptopefactory.m:246
    eta=eta / nrm
# symfixedrank/elliptopefactory.m:247
    return eta
    
if __name__ == '__main__':
    pass
    