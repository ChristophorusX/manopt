# Autogenerated with SMOP 
from smop.core import *
# fixedrank/fixedrankfactory_3factors_preconditioned.m

    
@function
def fixedrankfactory_3factors_preconditioned(m=None,n=None,k=None,*args,**kwargs):
    varargin = fixedrankfactory_3factors_preconditioned.varargin
    nargin = fixedrankfactory_3factors_preconditioned.nargin

    # Manifold of m-by-n matrices of rank k with three factor quotient geometry.
    
    # function M = fixedrankfactory_3factors_preconditioned(m, n, k)
    
    # This geometry is tuned to least squares problems such as low-rank matrix
# completion with ell-2 loss.
    
    # A point X on the manifold is represented as a structure with three
# fields: L, S and R. The matrices L (mxk) and R (nxk) are orthonormal,
# while the matrix S (kxk) is a full rank matrix such that X = L*S*R'.
    
    # Tangent vectors are represented as a structure with three fields: L, S
# and R.
    
    # Please cite the Manopt paper as well as the research paper:
#     @InProceedings{mishra2014r3mc,
#       Title        = {{R3MC}: A {R}iemannian three-factor algorithm for low-rank matrix completion},
#       Author       = {Mishra, B. and Sepulchre, R.},
#       Booktitle    = {{53rd IEEE Conference on Decision and Control}},
#       Year         = {2014},
#       Organization = {{IEEE CDC}}
#     }
    
    
    # See also: fixedrankfactory_3factors fixedrankfactory_2factors_preconditioned
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Bamdev Mishra, Dec. 30, 2012.
# Contributors:
# Change log:
    
    #	April 04, 2015 (BM):
#       Cosmetic changes including avoiding storing the inverse of a kxk matrix.
    
    
    M.name = copy(lambda : sprintf('LSR\' (tuned for least square problems) quotient manifold of %dx%d matrices of rank %d',m,n,k))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:37
    M.dim = copy(lambda : dot((m + n - k),k))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:39
    
    # pretty much everywhere else).
    
@function
def prepare(X=None,*args,**kwargs):
    varargin = prepare.varargin
    nargin = prepare.nargin

    if logical_not(all(isfield(X,cellarray(['StS','SSt'])) == 1)):
        X.SSt = copy(dot(X.S,X.S.T))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:45
        X.StS = copy(dot(X.S.T,X.S))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:46
    
    return X
    
if __name__ == '__main__':
    pass
    
    
    # The choice of metric is motivated by symmetry and tuned to least square
    # objective function.
    M.inner = copy(iproduct)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:52
    
@function
def iproduct(X=None,eta=None,zeta=None,*args,**kwargs):
    varargin = iproduct.varargin
    nargin = iproduct.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:54
    ip=trace(dot(X.SSt,(dot(eta.L.T,zeta.L)))) + trace(dot(X.StS,(dot(eta.R.T,zeta.R)))) + trace(dot(eta.S.T,zeta.S))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:56
    return ip
    
if __name__ == '__main__':
    pass
    
    
    M.norm = copy(lambda X=None,eta=None: sqrt(M.inner(X,eta,eta)))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:60
    M.dist = copy(lambda x=None,y=None: error('fixedrankfactory_3factors_preconditioned.dist not implemented yet.'))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:62
    M.typicaldist = copy(lambda : dot(10,k))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:64
    skew=lambda X=None: dot(0.5,(X - X.T))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:66
    symm=lambda X=None: dot(0.5,(X + X.T))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:67
    M.egrad2rgrad = copy(egrad2rgrad)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:69
    
@function
def egrad2rgrad(X=None,egrad=None,*args,**kwargs):
    varargin = egrad2rgrad.varargin
    nargin = egrad2rgrad.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:71
    SSL=X.SSt
# fixedrank/fixedrankfactory_3factors_preconditioned.m:73
    ASL=dot(2,symm[dot(SSL,(dot(egrad.S,X.S.T)))])
# fixedrank/fixedrankfactory_3factors_preconditioned.m:74
    SSR=X.StS
# fixedrank/fixedrankfactory_3factors_preconditioned.m:76
    ASR=dot(2,symm[dot(SSR,(dot(egrad.S.T,X.S)))])
# fixedrank/fixedrankfactory_3factors_preconditioned.m:77
    BL,BR=tangent_space_lyap(X.S,ASL,ASR,nargout=2)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:79
    
    
    rgrad.L = copy((egrad.L - dot(X.L,BL)) / X.SSt)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:81
    rgrad.R = copy((egrad.R - dot(X.R,BR)) / X.StS)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:82
    rgrad.S = copy(egrad.S)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:83
    
    #         BL1 = lyap(SSL, -ASL); # Alternate way
        #         BR1 = lyap(SSR, -ASR);
        #         norm(skew(X.SSt*(rgrad.L'*X.L) + rgrad.S*X.S'), 'fro')
        #         norm(skew(X.StS*(rgrad.R'*X.R) - X.S'*rgrad.S), 'fro')
    
    return rgrad
    
if __name__ == '__main__':
    pass
    
    
    
    
    M.ehess2rhess = copy(ehess2rhess)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:95
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,eta=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:97
    
    SSL=X.SSt
# fixedrank/fixedrankfactory_3factors_preconditioned.m:100
    ASL=dot(2,symm[dot(SSL,(dot(egrad.S,X.S.T)))])
# fixedrank/fixedrankfactory_3factors_preconditioned.m:101
    SSR=X.StS
# fixedrank/fixedrankfactory_3factors_preconditioned.m:102
    ASR=dot(2,symm[dot(SSR,(dot(egrad.S.T,X.S)))])
# fixedrank/fixedrankfactory_3factors_preconditioned.m:103
    BL,BR=tangent_space_lyap(X.S,ASL,ASR,nargout=2)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:104
    rgrad.L = copy((egrad.L - dot(X.L,BL)) / X.SSt)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:106
    rgrad.R = copy((egrad.R - dot(X.R,BR)) / X.StS)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:107
    rgrad.S = copy(egrad.S)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:108
    
    ASLdot=dot(2,symm[(dot(dot(2,symm[dot(X.S,eta.S.T)]),(dot(egrad.S,X.S.T)))) + dot(X.SSt,(dot(ehess.S,X.S.T) + dot(egrad.S,eta.S.T)))]) - dot(4,symm[dot(symm[dot(eta.S,X.S.T)],BL)])
# fixedrank/fixedrankfactory_3factors_preconditioned.m:111
    ASRdot=dot(2,symm[(dot(dot(2,symm[dot(X.S.T,eta.S)]),(dot(egrad.S.T,X.S)))) + dot(X.StS,(dot(ehess.S.T,X.S) + dot(egrad.S.T,eta.S)))]) - dot(4,symm[dot(symm[dot(eta.S.T,X.S)],BR)])
# fixedrank/fixedrankfactory_3factors_preconditioned.m:112
    
    #         SSRdot = X.StS;
        #         BLdot = lyap(SSLdot, -ASLdot);
        #         BRdot = lyap(SSRdot, -ASRdot);
    
    BLdot,BRdot=tangent_space_lyap(X.S,ASLdot,ASRdot,nargout=2)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:119
    Hess.L = copy((ehess.L - dot(eta.L,BL) - dot(X.L,BLdot) - dot(dot(2,rgrad.L),symm[dot(eta.S,X.S.T)])) / X.SSt)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:121
    Hess.R = copy((ehess.R - dot(eta.R,BR) - dot(X.R,BRdot) - dot(dot(2,rgrad.R),symm[dot(eta.S.T,X.S)])) / X.StS)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:122
    Hess.S = copy(ehess.S)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:123
    
    # We still need a correction factor for the non-constant metric
        # that is imposed.
        # The computation of the correction factor owes itself to the Koszul formula.
        # This corresponds to the Riemannian connection in the Euclidean space with the
        # scaled metric.
    Hess.L = copy(Hess.L + (dot(eta.L,symm[dot(rgrad.S,X.S.T)]) + dot(rgrad.L,symm[dot(eta.S,X.S.T)])) / X.SSt)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:133
    Hess.R = copy(Hess.R + (dot(eta.R,symm[dot(rgrad.S.T,X.S)]) + dot(rgrad.R,symm[dot(eta.S.T,X.S)])) / X.StS)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:134
    Hess.S = copy(Hess.S - dot(symm[dot(rgrad.L.T,eta.L)],X.S) - dot(X.S,symm[dot(rgrad.R.T,eta.R)]))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:135
    
    # projection of the Riemmian connection in the ambient space onto the tangent space of the total space and
        # then onto the horizontal space. 
        # This is accomplished by the following operation.
    Hess=M.proj(X,Hess)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:141
    
    #         norm(skew(X.SSt*(Hess.L'*X.L) + Hess.S*X.S'))
        #         norm(skew(X.StS*(Hess.R'*X.R) - X.S'*Hess.S))
    
    return Hess
    
if __name__ == '__main__':
    pass
    
    
    
    
    
    M.proj = copy(projection)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:152
    
@function
def projection(X=None,eta=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    X=prepare(X)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:154
    
    SSL=X.SSt
# fixedrank/fixedrankfactory_3factors_preconditioned.m:157
    ASL=dot(2,symm[dot(dot(X.SSt,(dot(X.L.T,eta.L))),X.SSt)])
# fixedrank/fixedrankfactory_3factors_preconditioned.m:158
    BL=lyap(SSL,- ASL)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:159
    eta.L = copy(eta.L - dot(X.L,(BL / X.SSt)))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:160
    SSR=X.StS
# fixedrank/fixedrankfactory_3factors_preconditioned.m:162
    ASR=dot(2,symm[dot(dot(X.StS,(dot(X.R.T,eta.R))),X.StS)])
# fixedrank/fixedrankfactory_3factors_preconditioned.m:163
    BR=lyap(SSR,- ASR)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:164
    eta.R = copy(eta.R - dot(X.R,(BR / X.StS)))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:165
    
    PU=skew[dot((dot(X.L.T,eta.L)),X.SSt)] + skew[dot(X.S,eta.S.T)]
# fixedrank/fixedrankfactory_3factors_preconditioned.m:168
    PV=skew[dot((dot(X.R.T,eta.R)),X.StS)] + skew[dot(X.S.T,eta.S)]
# fixedrank/fixedrankfactory_3factors_preconditioned.m:169
    Omega1,Omega2=coupled_lyap(X.S,PU,PV,nargout=2)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:170
    
    #         norm(2*skew(Omega2*X.StS) - PV -(X.S'*Omega1*X.S),'fro' )
    
    
    etaproj.L = copy(eta.L - (dot(X.L,Omega1)))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:175
    etaproj.S = copy(eta.S - (dot(X.S,Omega2) - dot(Omega1,X.S)))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:176
    etaproj.R = copy(eta.R - (dot(X.R,Omega2)))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:177
    
    #         norm(skew(X.SSt*(etaproj.L'*X.L) + etaproj.S*X.S'))
        #         norm(skew(X.StS*(etaproj.R'*X.R) - X.S'*etaproj.S))
    
    #         norm(skew(X.SSt*(etaproj.L'*X.L) - X.S*etaproj.S'))
        #         norm(skew(X.StS*(etaproj.R'*X.R) + etaproj.S'*X.S))
    
    return etaproj
    
if __name__ == '__main__':
    pass
    
    
    
    M.tangent = copy(M.proj)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:190
    M.tangent2ambient = copy(lambda X=None,eta=None: eta)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:191
    M.retr = copy(retraction)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:193
    
@function
def retraction(X=None,eta=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# fixedrank/fixedrankfactory_3factors_preconditioned.m:196
    
    
    Y.S = copy((X.S + dot(t,eta.S)))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:199
    Y.L = copy(uf((X.L + dot(t,eta.L))))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:200
    Y.R = copy(uf((X.R + dot(t,eta.R))))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:201
    Y=prepare(Y)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:203
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:206
    
@function
def exponential(X=None,eta=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin < 3:
        t=1.0
# fixedrank/fixedrankfactory_3factors_preconditioned.m:209
    
    Y=retraction(X,eta,t)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:211
    warning('manopt:fixedrankfactory_3factors_preconditioned:exp',cat('Exponential for fixed rank ','manifold not implemented yet. Used retraction instead.'))
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(cat([ravel(X.L)],[ravel(X.S)],[ravel(X.R)]))))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:217
    M.rand = copy(random)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:219
    
    # their random generator.
    stiefelm=stiefelfactory(m,k)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:222
    stiefeln=stiefelfactory(n,k)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:223
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    X.L = copy(stiefelm.rand())
# fixedrank/fixedrankfactory_3factors_preconditioned.m:225
    X.R = copy(stiefeln.rand())
# fixedrank/fixedrankfactory_3factors_preconditioned.m:226
    X.S = copy(diag(1 + rand(k,1)))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:227
    X=prepare(X)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:229
    return X
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:232
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    # A random vector on the horizontal space
    eta.L = copy(randn(m,k))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:235
    eta.R = copy(randn(n,k))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:236
    eta.S = copy(randn(k,k))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:237
    eta=projection(X,eta)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:238
    nrm=M.norm(X,eta)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:239
    eta.L = copy(eta.L / nrm)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:240
    eta.R = copy(eta.R / nrm)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:241
    eta.S = copy(eta.S / nrm)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:242
    return eta
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(lincomb)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:245
    M.zerovec = copy(lambda X=None: struct('L',zeros(m,k),'S',zeros(k,k),'R',zeros(n,k)))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:247
    M.transp = copy(lambda x1=None,x2=None,d=None: projection(x2,d))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:250
    
    M.vec = copy(lambda X=None,U=None: cat([ravel(U.L)],[ravel(U.S)],[ravel(U.R)]))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:253
    M.mat = copy(lambda X=None,u=None: struct('L',reshape(u[1:(dot(m,k))],m,k),'S',reshape(u[(dot(m,k) + 1):dot(m,k) + dot(k,k)],k,k),'R',reshape(u[(dot(m,k) + dot(k,k) + 1):end()],n,k)))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:254
    M.vecmatareisometries = copy(lambda : false)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:257
    return eta
    
if __name__ == '__main__':
    pass
    
    # Linear combination of tangent vectors
    
@function
def lincomb(x=None,a1=None,d1=None,a2=None,d2=None,*args,**kwargs):
    varargin = lincomb.varargin
    nargin = lincomb.nargin

    
    if nargin == 3:
        d.L = copy(dot(a1,d1.L))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:265
        d.R = copy(dot(a1,d1.R))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:266
        d.S = copy(dot(a1,d1.S))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:267
    else:
        if nargin == 5:
            d.L = copy(dot(a1,d1.L) + dot(a2,d2.L))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:269
            d.R = copy(dot(a1,d1.R) + dot(a2,d2.R))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:270
            d.S = copy(dot(a1,d1.S) + dot(a2,d2.S))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:271
        else:
            error('Bad use of fixedrankfactory_3factors_preconditioned.lincomb.')
    
    
    return d
    
if __name__ == '__main__':
    pass
    
    
@function
def uf(A=None,*args,**kwargs):
    varargin = uf.varargin
    nargin = uf.nargin

    L,unused,R=svd(A,0,nargout=3)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:279
    
    A=dot(L,R.T)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:280
    return A
    
if __name__ == '__main__':
    pass
    
    
@function
def tangent_space_lyap(R=None,E=None,F=None,*args,**kwargs):
    varargin = tangent_space_lyap.varargin
    nargin = tangent_space_lyap.nargin

    # We intent to solve a linear system    RR^T  BU + BU RR^T  = E
    #                                       R^T R BV + BV R^T R = F
    # for BU and BV.
    
    # This can be solved using two calls to the Matlab's lyap.
    # However, we can still have a more efficient implementation
    # that does not require the full functionaliyt of Matlab's lyap.
    
    U,Sigma,V=svd(R,nargout=3)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:292
    E_mod=dot(dot(U.T,E),U)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:293
    F_mod=dot(dot(V.T,F),V)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:294
    b1=ravel(E_mod)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:295
    b2=ravel(F_mod)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:296
    r=size(Sigma,1)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:298
    sig=diag(Sigma)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:299
    
    sig1=dot(sig,ones(1,r))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:300
    
    sig1t=sig1.T
# fixedrank/fixedrankfactory_3factors_preconditioned.m:301
    
    s1=ravel(sig1)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:302
    s2=ravel(sig1t)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:303
    
    a=s1 ** 2 + s2 ** 2
# fixedrank/fixedrankfactory_3factors_preconditioned.m:306
    
    
    # Solve the linear system of equations
    cu=b1 / a
# fixedrank/fixedrankfactory_3factors_preconditioned.m:309
    
    cv=b2 / a
# fixedrank/fixedrankfactory_3factors_preconditioned.m:310
    
    
    # Matricize
    CU=reshape(cu,r,r)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:313
    CV=reshape(cv,r,r)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:314
    
    BU=dot(dot(U,CU),U.T)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:317
    BV=dot(dot(V,CV),V.T)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:318
    
    
    # norm(R*R'*BU + BU*R*R' - E, 'fro');
    # norm((Sigma.^2)*CU + CU*(Sigma.^2) - E_mod, 'fro');
    # norm(a.*cu - b1, 'fro');
    
    # norm(R'*R*BV + BV*R'*R - F, 'fro');
    
    # BU1 = lyap(R*R', - E);
    # norm(R*R'*BU1 + BU1*R*R' - E, 'fro');
    
    # BV1 = lyap(R'*R, - F);
    # norm(R'*R*BV1 + BV1*R'*R - F, 'fro');
    
    # # as accurate as the lyap
    # norm(BU - BU1, 'fro')
    # norm(BV - BV1, 'fro')
    return BU,BV
    
if __name__ == '__main__':
    pass
    
    
@function
def coupled_lyap(R=None,E=None,F=None,*args,**kwargs):
    varargin = coupled_lyap.varargin
    nargin = coupled_lyap.nargin

    # We intent to solve the coupled system of Lyapunov equations
    
    # RR^T Omega1 + Omega1 RR^T  - R Omega2 R^T = E
    # R^T R Omega2 + Omega1 R^T R  - R^T Omega2 R = F,
    
    # for Omega1 and Omega2, both are skew symmetric matrices.
    
    # Below is an efficient implementation
    
    U,Sigma,V=svd(R,nargout=3)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:351
    E_mod=dot(dot(U.T,E),U)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:352
    F_mod=dot(dot(V.T,F),V)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:353
    b1=ravel(E_mod)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:354
    b2=ravel(F_mod)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:355
    r=size(Sigma,1)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:357
    sig=diag(Sigma)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:358
    
    sig1=dot(sig,ones(1,r))
# fixedrank/fixedrankfactory_3factors_preconditioned.m:359
    
    sig1t=sig1.T
# fixedrank/fixedrankfactory_3factors_preconditioned.m:360
    
    s1=ravel(sig1)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:361
    s2=ravel(sig1t)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:362
    
    a=s1 ** 2 + s2 ** 2
# fixedrank/fixedrankfactory_3factors_preconditioned.m:365
    
    c=multiply(s1,s2)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:366
    
    # A = diag(a);
    # C = diag(c);
    # Y1_sol = (A*(C\A) - C) \ (b2 + A*(C\b1));
    # Y2_sol = A\(b2 + C*Y1_sol);
    
    Y1_sol=(b2 + multiply((a / c),b1)) / ((a ** 2) / c - c)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:374
    Y2_sol=(b2 + multiply(c,Y1_sol)) / a
# fixedrank/fixedrankfactory_3factors_preconditioned.m:375
    
    Omega1=reshape(Y1_sol,r,r)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:378
    Omega2=reshape(Y2_sol,r,r)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:379
    
    Omega1=dot(dot(U,Omega1),U.T)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:382
    Omega2=dot(dot(V,Omega2),V.T)
# fixedrank/fixedrankfactory_3factors_preconditioned.m:383
    
    # norm(R*R'*Omega1 + Omega1*R*R'  - R*Omega2*R' - E, 'fro')
    # norm(R'*R*Omega2 + Omega2*R'*R  - R'*Omega1*R - F, 'fro')
    return Omega1,Omega2
    
if __name__ == '__main__':
    pass
    