# Autogenerated with SMOP 
from smop.core import *
# fixedrank/fixedrankfactory_3factors.m

    
@function
def fixedrankfactory_3factors(m=None,n=None,k=None,*args,**kwargs):
    varargin = fixedrankfactory_3factors.varargin
    nargin = fixedrankfactory_3factors.nargin

    # Manifold of m-by-n matrices of rank k with polar quotient geometry.
    
    # function M = fixedrankfactory_3factors(m, n, k)
    
    # The first-order geometry follows the balanced quotient geometry described 
# in the paper, 
# "Linear regression under fixed-rank constraints: a Riemannian approach",
# G. Meyer, S. Bonnabel and R. Sepulchre, ICML 2011.
    
    # Paper link: http://www.icml-2011.org/papers/350_icmlpaper.pdf.
    
    # The second-order geometry follows from the paper
# "Fixed-rank matrix factorizations and Riemannian low-rank optimization",
# B. Mishra, R. Meyer, S. Bonnabel and R. Sepulchre,
# Computational Statistics, 29(3 - 4), pp. 591 - 621, 2014.
    
    # A point X on the manifold is represented as a structure with three
# fields: L, S and R. The matrices L (mxk) and R (nxk) are orthonormal,
# while the matrix S (kxk) is a symmetric positive definite full rank
# matrix.
    
    # Tangent vectors are represented as a structure with three fields: L, S
# and R.
    
    # 
# For first-order geometry, please cite the Manopt paper as well as the research paper:
#     @InProceedings{meyer2011linear,
#       Title        = {Linear regression under fixed-rank constraints: a {R}iemannian approach},
#       Author       = {Meyer, G. and Bonnabel, S. and Sepulchre, R.},
#       Booktitle    = {{28th International Conference on Machine Learning}},
#       Year         = {2011},
#       Organization = {{ICML}}
#     }
# For second-order geometry, please cite the Manopt paper as well as the research paper:
#     @Article{mishra2014fixedrank,
#       Title   = {Fixed-rank matrix factorizations and {Riemannian} low-rank optimization},
#       Author  = {Mishra, B. and Meyer, G. and Bonnabel, S. and Sepulchre, R.},
#       Journal = {Computational Statistics},
#       Year    = {2014},
#       Number  = {3-4},
#       Pages   = {591--621},
#       Volume  = {29},
#       Doi     = {10.1007/s00180-013-0464-z}
#     }
    
    
    # See also fixedrankembeddedfactory fixedrankfactory_2factors fixedrankfactory_3factors_preconditioned
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Bamdev Mishra, Dec. 30, 2012.
# Contributors:
# Change log:
    
    M.name = copy(lambda : sprintf('LSR\' quotient manifold of %dx%d matrices of rank %d',m,n,k))
# fixedrank/fixedrankfactory_3factors.m:55
    M.dim = copy(lambda : dot((m + n - k),k))
# fixedrank/fixedrankfactory_3factors.m:57
    
    # space. The metric on the positive definite space is its natural metric.
    M.inner = copy(lambda X=None,eta=None,zeta=None: dot(ravel(eta.L).T,ravel(zeta.L)) + dot(ravel(eta.R).T,ravel(zeta.R)) + trace(dot((numpy.linalg.solve(X.S,eta.S)),(numpy.linalg.solve(X.S,zeta.S)))))
# fixedrank/fixedrankfactory_3factors.m:61
    M.norm = copy(lambda X=None,eta=None: sqrt(M.inner(X,eta,eta)))
# fixedrank/fixedrankfactory_3factors.m:64
    M.dist = copy(lambda x=None,y=None: error('fixedrankfactory_3factors.dist not implemented yet.'))
# fixedrank/fixedrankfactory_3factors.m:66
    M.typicaldist = copy(lambda : dot(10,k))
# fixedrank/fixedrankfactory_3factors.m:68
    skew=lambda X=None: dot(0.5,(X - X.T))
# fixedrank/fixedrankfactory_3factors.m:70
    symm=lambda X=None: dot(0.5,(X + X.T))
# fixedrank/fixedrankfactory_3factors.m:71
    stiefel_proj=lambda L=None,H=None: H - dot(L,symm[dot(L.T,H)])
# fixedrank/fixedrankfactory_3factors.m:72
    M.egrad2rgrad = copy(egrad2rgrad)
# fixedrank/fixedrankfactory_3factors.m:74
    
@function
def egrad2rgrad(X=None,egrad=None,*args,**kwargs):
    varargin = egrad2rgrad.varargin
    nargin = egrad2rgrad.nargin

    rgrad.L = copy(stiefel_proj[X.L,egrad.L])
# fixedrank/fixedrankfactory_3factors.m:76
    rgrad.S = copy(dot(dot(X.S,symm[egrad.S]),X.S))
# fixedrank/fixedrankfactory_3factors.m:77
    rgrad.R = copy(stiefel_proj[X.R,egrad.R])
# fixedrank/fixedrankfactory_3factors.m:78
    return rgrad
    
if __name__ == '__main__':
    pass
    
    
    
    M.ehess2rhess = copy(ehess2rhess)
# fixedrank/fixedrankfactory_3factors.m:82
    
@function
def ehess2rhess(X=None,egrad=None,ehess=None,eta=None,*args,**kwargs):
    varargin = ehess2rhess.varargin
    nargin = ehess2rhess.nargin

    
    # Riemannian gradient for the factor S.
    rgrad.S = copy(dot(dot(X.S,symm[egrad.S]),X.S))
# fixedrank/fixedrankfactory_3factors.m:86
    
    Hess.L = copy(ehess.L - dot(eta.L,symm[dot(X.L.T,egrad.L)]))
# fixedrank/fixedrankfactory_3factors.m:89
    Hess.L = copy(stiefel_proj[X.L,Hess.L])
# fixedrank/fixedrankfactory_3factors.m:90
    Hess.R = copy(ehess.R - dot(eta.R,symm[dot(X.R.T,egrad.R)]))
# fixedrank/fixedrankfactory_3factors.m:92
    Hess.R = copy(stiefel_proj[X.R,Hess.R])
# fixedrank/fixedrankfactory_3factors.m:93
    Hess.S = copy(dot(dot(X.S,symm[ehess.S]),X.S) + dot(2,symm[dot(dot(eta.S,symm[egrad.S]),X.S)]))
# fixedrank/fixedrankfactory_3factors.m:95
    
    Hess.S = copy(Hess.S - symm[dot(eta.S,(numpy.linalg.solve(X.S,rgrad.S)))])
# fixedrank/fixedrankfactory_3factors.m:98
    
    Hess=M.proj(X,Hess)
# fixedrank/fixedrankfactory_3factors.m:101
    return Hess
    
if __name__ == '__main__':
    pass
    
    
    
    M.proj = copy(projection)
# fixedrank/fixedrankfactory_3factors.m:105
    
@function
def projection(X=None,eta=None,*args,**kwargs):
    varargin = projection.varargin
    nargin = projection.nargin

    # First, projection onto the tangent space of the total space.
    eta.L = copy(stiefel_proj[X.L,eta.L])
# fixedrank/fixedrankfactory_3factors.m:108
    eta.R = copy(stiefel_proj[X.R,eta.R])
# fixedrank/fixedrankfactory_3factors.m:109
    eta.S = copy(symm[eta.S])
# fixedrank/fixedrankfactory_3factors.m:110
    
    SS=dot(X.S,X.S)
# fixedrank/fixedrankfactory_3factors.m:113
    AS=dot(dot(X.S,(skew[dot(X.L.T,eta.L)] + skew[dot(X.R.T,eta.R)] - dot(2,skew[numpy.linalg.solve(X.S,eta.S)]))),X.S)
# fixedrank/fixedrankfactory_3factors.m:114
    omega=lyap(SS,- AS)
# fixedrank/fixedrankfactory_3factors.m:115
    etaproj.L = copy(eta.L - dot(X.L,omega))
# fixedrank/fixedrankfactory_3factors.m:117
    etaproj.S = copy(eta.S - (dot(X.S,omega) - dot(omega,X.S)))
# fixedrank/fixedrankfactory_3factors.m:118
    etaproj.R = copy(eta.R - dot(X.R,omega))
# fixedrank/fixedrankfactory_3factors.m:119
    return etaproj
    
if __name__ == '__main__':
    pass
    
    
    M.tangent = copy(M.proj)
# fixedrank/fixedrankfactory_3factors.m:122
    M.tangent2ambient = copy(lambda X=None,eta=None: eta)
# fixedrank/fixedrankfactory_3factors.m:123
    M.retr = copy(retraction)
# fixedrank/fixedrankfactory_3factors.m:125
    
@function
def retraction(X=None,eta=None,t=None,*args,**kwargs):
    varargin = retraction.varargin
    nargin = retraction.nargin

    if nargin < 3:
        t=1.0
# fixedrank/fixedrankfactory_3factors.m:128
    
    
    L=chol(X.S)
# fixedrank/fixedrankfactory_3factors.m:131
    Y.S = copy(dot(dot(L.T,expm(numpy.linalg.solve(L.T,(dot(t,eta.S))) / L)),L))
# fixedrank/fixedrankfactory_3factors.m:132
    Y.L = copy(uf(X.L + dot(t,eta.L)))
# fixedrank/fixedrankfactory_3factors.m:133
    Y.R = copy(uf(X.R + dot(t,eta.R)))
# fixedrank/fixedrankfactory_3factors.m:134
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.exp = copy(exponential)
# fixedrank/fixedrankfactory_3factors.m:137
    
@function
def exponential(X=None,eta=None,t=None,*args,**kwargs):
    varargin = exponential.varargin
    nargin = exponential.nargin

    if nargin < 3:
        t=1.0
# fixedrank/fixedrankfactory_3factors.m:140
    
    Y=retraction(X,eta,t)
# fixedrank/fixedrankfactory_3factors.m:142
    warning('manopt:fixedrankfactory_3factors:exp',cat('Exponential for fixed rank ','manifold not implemented yet. Lsed retraction instead.'))
    return Y
    
if __name__ == '__main__':
    pass
    
    
    M.hash = copy(lambda X=None: cat('z',hashmd5(cat([ravel(X.L)],[ravel(X.S)],[ravel(X.R)]))))
# fixedrank/fixedrankfactory_3factors.m:148
    M.rand = copy(random)
# fixedrank/fixedrankfactory_3factors.m:150
    
    # their random generators.
    stiefelm=stiefelfactory(m,k)
# fixedrank/fixedrankfactory_3factors.m:153
    stiefeln=stiefelfactory(n,k)
# fixedrank/fixedrankfactory_3factors.m:154
    
@function
def random(*args,**kwargs):
    varargin = random.varargin
    nargin = random.nargin

    X.L = copy(stiefelm.rand())
# fixedrank/fixedrankfactory_3factors.m:156
    X.R = copy(stiefeln.rand())
# fixedrank/fixedrankfactory_3factors.m:157
    X.S = copy(diag(1 + rand(k,1)))
# fixedrank/fixedrankfactory_3factors.m:158
    return X
    
if __name__ == '__main__':
    pass
    
    
    M.randvec = copy(randomvec)
# fixedrank/fixedrankfactory_3factors.m:161
    
@function
def randomvec(X=None,*args,**kwargs):
    varargin = randomvec.varargin
    nargin = randomvec.nargin

    # A random vector on the horizontal space.
    eta.L = copy(randn(m,k))
# fixedrank/fixedrankfactory_3factors.m:164
    eta.R = copy(randn(n,k))
# fixedrank/fixedrankfactory_3factors.m:165
    eta.S = copy(randn(k,k))
# fixedrank/fixedrankfactory_3factors.m:166
    eta=projection(X,eta)
# fixedrank/fixedrankfactory_3factors.m:167
    nrm=M.norm(X,eta)
# fixedrank/fixedrankfactory_3factors.m:168
    eta.L = copy(eta.L / nrm)
# fixedrank/fixedrankfactory_3factors.m:169
    eta.R = copy(eta.R / nrm)
# fixedrank/fixedrankfactory_3factors.m:170
    eta.S = copy(eta.S / nrm)
# fixedrank/fixedrankfactory_3factors.m:171
    return eta
    
if __name__ == '__main__':
    pass
    
    
    M.lincomb = copy(lincomb)
# fixedrank/fixedrankfactory_3factors.m:174
    M.zerovec = copy(lambda X=None: struct('L',zeros(m,k),'S',zeros(k,k),'R',zeros(n,k)))
# fixedrank/fixedrankfactory_3factors.m:176
    M.transp = copy(lambda x1=None,x2=None,d=None: projection(x2,d))
# fixedrank/fixedrankfactory_3factors.m:179
    
    M.vec = copy(lambda X=None,U=None: cat([ravel(U.L)],[ravel(U.S)],[ravel(U.R)]))
# fixedrank/fixedrankfactory_3factors.m:182
    M.mat = copy(lambda X=None,u=None: struct('L',reshape(u[1:(dot(m,k))],m,k),'S',reshape(u[(dot(m,k) + 1):dot(m,k) + dot(k,k)],k,k),'R',reshape(u[(dot(m,k) + dot(k,k) + 1):end()],n,k)))
# fixedrank/fixedrankfactory_3factors.m:183
    M.vecmatareisometries = copy(lambda : false)
# fixedrank/fixedrankfactory_3factors.m:186
    return eta
    
if __name__ == '__main__':
    pass
    
    # Linear combination of tangent vectors.
    
@function
def lincomb(x=None,a1=None,d1=None,a2=None,d2=None,*args,**kwargs):
    varargin = lincomb.varargin
    nargin = lincomb.nargin

    
    if nargin == 3:
        d.L = copy(dot(a1,d1.L))
# fixedrank/fixedrankfactory_3factors.m:194
        d.R = copy(dot(a1,d1.R))
# fixedrank/fixedrankfactory_3factors.m:195
        d.S = copy(dot(a1,d1.S))
# fixedrank/fixedrankfactory_3factors.m:196
    else:
        if nargin == 5:
            d.L = copy(dot(a1,d1.L) + dot(a2,d2.L))
# fixedrank/fixedrankfactory_3factors.m:198
            d.R = copy(dot(a1,d1.R) + dot(a2,d2.R))
# fixedrank/fixedrankfactory_3factors.m:199
            d.S = copy(dot(a1,d1.S) + dot(a2,d2.S))
# fixedrank/fixedrankfactory_3factors.m:200
        else:
            error('Bad use of fixedrankfactory_3factors.lincomb.')
    
    
    return d
    
if __name__ == '__main__':
    pass
    
    
@function
def uf(A=None,*args,**kwargs):
    varargin = uf.varargin
    nargin = uf.nargin

    L,unused,R=svd(A,0,nargout=3)
# fixedrank/fixedrankfactory_3factors.m:208
    
    A=dot(L,R.T)
# fixedrank/fixedrankfactory_3factors.m:209
    return A
    
if __name__ == '__main__':
    pass
    