# Autogenerated with SMOP 
from smop.core import *
# getHessian.m

    
@function
def getHessian(problem=None,x=None,d=None,storedb=None,key=None,*args,**kwargs):
    varargin = getHessian.varargin
    nargin = getHessian.nargin

    # Computes the Hessian of the cost function at x along d.
    
    # function hess = getHessian(problem, x, d)
# function hess = getHessian(problem, x, d, storedb)
# function hess = getHessian(problem, x, d, storedb, key)
    
    # Returns the Hessian at x along d of the cost function described in the
# problem structure.
    
    # storedb is a StoreDB object, key is the StoreDB key to point x.
    
    # If an exact Hessian is not provided, an approximate Hessian is returned
# if possible, without warning. If not possible, an exception will be
# thrown. To check whether an exact Hessian is available or not (typically
# to issue a warning if not), use canGetHessian.
    
    # See also: getPrecon getApproxHessian canGetHessian
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, Dec. 30, 2012.
# Contributors: 
# Change log:
    
    #   April 3, 2015 (NB):
#       Works with the new StoreDB class system.
    
    # Allow omission of the key, and even of storedb.
    if logical_not(exist('key','var')):
        if logical_not(exist('storedb','var')):
            storedb=StoreDB()
# getHessian.m:31
        key=storedb.getNewKey()
# getHessian.m:33
    
    
    
    if isfield(problem,'hess'):
        ## Compute the Hessian using hess.
        # Check whether this function wants to deal with storedb or not.
        if 2 == nargin(problem.hess):
            hess=problem.hess(x,d)
# getHessian.m:43
        else:
            if 3 == nargin(problem.hess):
                # Obtain, pass along, and save the store for x.
                store=storedb.getWithShared(key)
# getHessian.m:46
                hess,store=problem.hess(x,d,store,nargout=2)
# getHessian.m:47
                storedb.setWithShared(store,key)
            else:
                if 4 == nargin(problem.hess):
                    # Pass along the whole storedb (by reference), with key.
                    hess=problem.hess(x,d,storedb,key)
# getHessian.m:51
                else:
                    up=MException('manopt:getHessian:badhess','hess should accept 2, 3 or 4 inputs.')
# getHessian.m:53
                    throw(up)
    else:
        if isfield(problem,'ehess') and canGetEuclideanGradient(problem):
            ## Compute the Hessian using ehess.
            # We will need the Euclidean gradient for the conversion from the
        # Euclidean Hessian to the Riemannian Hessian.
            egrad=getEuclideanGradient(problem,x,storedb,key)
# getHessian.m:63
            if 2 == nargin(problem.ehess):
                ehess=problem.ehess(x,d)
# getHessian.m:68
            else:
                if 3 == nargin(problem.ehess):
                    # Obtain, pass along, and save the store for x.
                    store=storedb.getWithShared(key)
# getHessian.m:71
                    ehess,store=problem.ehess(x,d,store,nargout=2)
# getHessian.m:72
                    storedb.setWithShared(store,key)
                else:
                    if 4 == nargin(problem.ehess):
                        # Pass along the whole storedb (by reference), with key.
                        ehess=problem.ehess(x,d,storedb,key)
# getHessian.m:76
                    else:
                        up=MException('manopt:getHessian:badehess','ehess should accept 2, 3 or 4 inputs.')
# getHessian.m:78
                        throw(up)
            # Convert to the Riemannian Hessian
            hess=problem.M.ehess2rhess(x,egrad,ehess,d)
# getHessian.m:84
        else:
            ## Attempt the computation of an approximation of the Hessian.
            hess=getApproxHessian(problem,x,d,storedb,key)
# getHessian.m:89
    
    
    return hess
    
if __name__ == '__main__':
    pass
    