# Autogenerated with SMOP 
from smop.core import *
# getPartialEuclideanGradient.m

    
@function
def getPartialEuclideanGradient(problem=None,x=None,I=None,storedb=None,key=None,*args,**kwargs):
    varargin = getPartialEuclideanGradient.varargin
    nargin = getPartialEuclideanGradient.nargin

    # Computes the Euclidean gradient of a subset of terms in cost function.
    
    # function egrad = getPartialEuclideanGradient(problem, x, I)
# function egrad = getPartialEuclideanGradient(problem, x, I, storedb)
# function egrad = getPartialEuclideanGradient(problem, x, I, storedb, key)
    
    # Assume the cost function described in the problem structure is a sum of
# many terms, as
    
    #    f(x) = sum_i f_i(x) for i = 1:d,
    
    # where d is specified as d = problem.ncostterms.
# 
# For a subset I of 1:d, getPartialEuclideanGradient obtains the Euclidean
# gradient of the partial cost function
# 
#    f_I(x) = sum_i f_i(x) for i = I.
    
    # storedb is a StoreDB object, key is the StoreDB key to point x.
    
    # See also: getGradient canGetPartialEuclidean Gradient getPartialGradient
    
    # This file is part of Manopt: www.manopt.org.
# Original author: Nicolas Boumal, June 28, 2016
# Contributors: 
# Change log:
    
    # Allow omission of the key, and even of storedb.
    if logical_not(exist('key','var')):
        if logical_not(exist('storedb','var')):
            storedb=StoreDB()
# getPartialEuclideanGradient.m:33
        key=storedb.getNewKey()
# getPartialEuclideanGradient.m:35
    
    
    # Make sure I is a row vector, so that it is natural to loop over it
    # with " for i = I ".
    I=(ravel(I)).T
# getPartialEuclideanGradient.m:40
    if isfield(problem,'partialegrad'):
        ## Compute the partial Euclidean gradient using partialegrad.
        # Check whether this function wants to deal with storedb or not.
        if 2 == nargin(problem.partialegrad):
            egrad=problem.partialegrad(x,I)
# getPartialEuclideanGradient.m:49
        else:
            if 3 == nargin(problem.partialegrad):
                # Obtain, pass along, and save the store for x.
                store=storedb.getWithShared(key)
# getPartialEuclideanGradient.m:52
                egrad,store=problem.partialegrad(x,I,store,nargout=2)
# getPartialEuclideanGradient.m:53
                storedb.setWithShared(store,key)
            else:
                if 4 == nargin(problem.partialegrad):
                    # Pass along the whole storedb (by reference), with key.
                    egrad=problem.partialegrad(x,I,storedb,key)
# getPartialEuclideanGradient.m:57
                else:
                    up=MException('manopt:getPartialEuclideanGradient:badpartialegrad','partialegrad should accept 2, 3 or 4 inputs.')
# getPartialEuclideanGradient.m:59
                    throw(up)
    else:
        ## Abandon computing the partial Euclidean gradient.
        up=MException('manopt:getPartialEuclideanGradient:fail',cat('The problem description is not explicit enough to ','compute the partial Euclidean gradient of the cost.'))
# getPartialEuclideanGradient.m:67
        throw(up)
    
    
    return egrad
    
if __name__ == '__main__':
    pass
    